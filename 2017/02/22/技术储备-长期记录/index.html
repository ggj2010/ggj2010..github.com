<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="笔记," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="最近几年总觉得脑子不够用，一会想学这个，一会想看哪个，一天可能一行代码也没写就这么度过了。 这个文章就当自己的学习记录吧，想到什么写什么，虽然有有道笔记，但是里面的记录的东西太乱了， 感觉就是个查问题的笔记库，有时间再整理下吧。 201702221.关于数据库的分库分表，主从技术落地。 201702231.以后面试要首先问涨薪体系！2.批处理数据的时候，要控制数据的数量，比如批量插入的时候，每次循">
<meta name="keywords" content="笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="技术储备-长期记录">
<meta property="og:url" content="http://ggj2010.github.io/2017/02/22/技术储备-长期记录/index.html">
<meta property="og:site_name" content="高广金博客">
<meta property="og:description" content="最近几年总觉得脑子不够用，一会想学这个，一会想看哪个，一天可能一行代码也没写就这么度过了。 这个文章就当自己的学习记录吧，想到什么写什么，虽然有有道笔记，但是里面的记录的东西太乱了， 感觉就是个查问题的笔记库，有时间再整理下吧。 201702221.关于数据库的分库分表，主从技术落地。 201702231.以后面试要首先问涨薪体系！2.批处理数据的时候，要控制数据的数量，比如批量插入的时候，每次循">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://o8c5x5dg6.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170317152838.png">
<meta property="og:updated_time" content="2017-11-22T08:16:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="技术储备-长期记录">
<meta name="twitter:description" content="最近几年总觉得脑子不够用，一会想学这个，一会想看哪个，一天可能一行代码也没写就这么度过了。 这个文章就当自己的学习记录吧，想到什么写什么，虽然有有道笔记，但是里面的记录的东西太乱了， 感觉就是个查问题的笔记库，有时间再整理下吧。 201702221.关于数据库的分库分表，主从技术落地。 201702231.以后面试要首先问涨薪体系！2.批处理数据的时候，要控制数据的数量，比如批量插入的时候，每次循">
<meta name="twitter:image" content="http://o8c5x5dg6.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170317152838.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ggj2010.github.io/2017/02/22/技术储备-长期记录/"/>





  <title> 技术储备-长期记录 | 高广金博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">高广金博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-webmagic">
          <a href="http://scedai.com/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            爬虫
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ggj2010.github.io/2017/02/22/技术储备-长期记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ggj2010">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ocg3iebmc.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160922230125.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高广金博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                技术储备-长期记录
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-22T12:41:14+08:00">
                2017-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javabase/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <pre><code>最近几年总觉得脑子不够用，一会想学这个，一会想看哪个，一天可能一行代码也没写就这么度过了。
这个文章就当自己的学习记录吧，想到什么写什么，虽然有有道笔记，但是里面的记录的东西太乱了，
感觉就是个查问题的笔记库，有时间再整理下吧。
</code></pre><h3 id="20170222"><a href="#20170222" class="headerlink" title="20170222"></a>20170222</h3><p>1.关于数据库的分库分表，主从技术落地。</p>
<h3 id="20170223"><a href="#20170223" class="headerlink" title="20170223"></a>20170223</h3><p>1.以后面试要首先问涨薪体系！<br>2.批处理数据的时候，要控制数据的数量，比如批量插入的时候，每次循环1000条插入一次，不要一次性插入N条，防止堆内存溢出。</p>
<h3 id="20170224"><a href="#20170224" class="headerlink" title="20170224"></a>20170224</h3><p>1.日志输出规范</p>
<h3 id="20170227"><a href="#20170227" class="headerlink" title="20170227"></a>20170227</h3><p>1.el字符串按照指定规则截取</p>
<pre><code>&lt;c:set value=&quot;${ fn:split(cate.services , &apos; &apos;) }&quot; var=&quot;service&quot; /&gt;
   &lt;c:forEach items=&quot;${service}&quot; var=&quot;s&quot;&gt;
      &lt;c:if test=&quot;${s==7}&quot;&gt;
         &lt;c:set var=&quot;freePost&quot; value=&quot;true&quot; /&gt;
    &lt;/c:if&gt;
 &lt;/c:forEach&gt;
</code></pre><p>2.mysql查询分页limit写法优化</p>
<pre><code>写法一：
 select * from tb_order  LIMIT 999999 ,10 
写法二：
 select * from tb_order where id&gt;=( 
 select id from tb_order LIMIT 999999,1) LIMIT 10
 mysql limit会扫描n行，如果这个n偏移量过大会导致性能下降，
 在id递增的情况下建议使用下面的写法
</code></pre><h3 id="20170228"><a href="#20170228" class="headerlink" title="20170228"></a>20170228</h3><p>1.防止xss需要对输入内容进行转译保存，页面显示是转译后的标签。</p>
<pre><code>StringEscapeUtils.escapeHtml4()
spring 可以这样写
@InitBinder
    protected void initBinder2(WebDataBinder binder) {
        // String类型转换，将所有传递进来的String进行HTML编码，防止XSS攻击
        binder.registerCustomEditor(String.class, new PropertyEditorSupport() {

            public String getAsText() {
                Object value = getValue();
                return value != null ? value.toString() : &quot;&quot;;
            }

            public void setAsText(String text) {
                setValue(text == null ? null : StringEscapeUtils.escapeHtml4(text.trim()));
            }
        });
    }
</code></pre><p>2.高并发下面redis的小问题</p>
<pre><code>redis因为是单线程的，如果在高并发的情况下 reidis服务器没有设置集群或者主从，连接数都是有限的，
在大量请求过来后，如果redis连接不够用会导致请求响应非常慢。我们可以在团购开始时间之前，将热数据
先从库同步到redis，同时定时也在项目里面缓存一份，拿数据的时候优先从本地缓存里面拿，定时再从redis
里面同步数据到本地缓存。
整个数据链路是  DB==&gt;REDIS==&gt;本地缓存
</code></pre><h3 id="20170301"><a href="#20170301" class="headerlink" title="20170301"></a>20170301</h3><p>1.tomcat的日志问题</p>
<pre><code>昨天线上突然挂机，想去看下tomcat挂机时候的日志，没想到catalina.log里面打了一堆乱七八糟的日志，
catalina.log会记录一些RunTimeException 和 System.out.println(） 和 e.printStackTrace()，为了防止
catalina.out日志过大，不要在代码里面这样输出内容。
</code></pre><h3 id="20170302"><a href="#20170302" class="headerlink" title="20170302"></a>20170302</h3><p>1.java垃圾回收知识点回顾</p>
<pre><code>java垃圾回收采用复制算法，将内存分为一块较大的eden空间和两块较小的survivor空间。每次都是使用eden和其中的一块survivor空间。
当回收时，将eden和survivor中还存活着的对象一次性的拷贝到另外一块survivor空间上，最后清理掉刚刚用掉的eden和survivor的空间
新生代=eden+surviror1+surviror2垃圾回收时候首先 
先将eden+surviror1 移到surviror2  如果surviror2内存不够 就移到老年代  如果老年代还不够放，那就进行fulg
JVM的方法区，也被称为永久代。在这里都是放着一些被虚拟机加载的类信息，静态变量，常量等数据。这个区中的东西比老年代和新生代更不容易回收
当年轻代内存满时，会引发一次普通GC，该GC仅回收年轻代。需要强调的时，年轻代满是指Eden代满，Survivor满不会引发GC
当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代
当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载
</code></pre><p>2.系统流量控制<br>     <a href="&#39;http://jinnianshilongnian.iteye.com/blog/2305117&#39;">参考博客</a></p>
<pre><code>分流：不需要我们控制，h5
降级：
    当业务系统挂了的时候，可以进行降级，降级方式有手动降级和自动降级
</code></pre><p>   <a href="&#39;http://iamzhongyong.iteye.com/blog/1897694?utm_source=tuicool&amp;utm_medium=referral&#39;">参考博客</a></p>
<pre><code>缓存：
    本地缓存==》redis缓存==》DB
限流：
    限流总并发/连接/请求数：Apache和tomcat做
    限流某个接口的总并发/请求数：apiAuthJAR可以做
    限流某个接口的时间窗请求数：apiAuthJAR可以做
    平滑限流某个接口的请求数：令牌桶算法可以应对突发请求 apiAuthJAR可以做

接入层：nginx限流    
</code></pre><h3 id="20170306"><a href="#20170306" class="headerlink" title="20170306"></a>20170306</h3><ol>
<li>java 性能监控常用命令<ol>
<li>jstack 查看线程<br>   jstack pid  需要注意dump文件里面的 deadlock和blocked  </li>
<li>jmap(查看内存)<br>  jmap -dump:format=b,file=/tmp/dump.dat 4813<br>  可以dump出java当前内存的情况，然后用工具MemoryAnalyzer或者HeapAnalyzer进行分析</li>
<li>jstat(性能分析)</li>
</ol>
</li>
<li><p>jvm 性能优化</p>
<ol>
<li><p>堆和栈常用参数  </p>
<pre><code>java堆：
-Xms2560m -Xmx2560m 限制java堆大小为 2560MB，且不可扩展，如果程序Headp
 java栈：
-Xss256k  设置java线程栈的大小，如果程序 StackOverflow就需要将xss设置大一点
 java年轻代：
 -XX:NewSize=1024m # 年轻代默认初始大小
 -XX:MaxNewSize=1024m # 年轻代最大值
 以上两个等于-Xmn1024M 年轻代大小
java永久代
-XX:PermSize=384m # 永久代默认初始大小（方法区，类、接口、方法等）
-XX:MaxPermSize=512m # 永久代最大值
SurvivorRatio=8 表示8:1：1 新生代=一个eden+两个survivor区
-XX:SurvivorRatio=8  设置年轻代中Eden区与Survivor区的大小比值
-XX:NewRatio=3  表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）
</code></pre></li>
<li><p>垃圾回收信息和内存溢出dump</p>
<pre><code>stop-the-world耗时过长可能是由于GC参数不合理或者代码实现不正确 
使用-XX:+PrintFlagsFinal and -XX:+PrintFlagsInitial 可以打印jvm启动时候加载的配置项
gc时候打印详情
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationConcurrentTime 
-XX:+PrintHeapAtGC -Xloggc:/data/applogs/heap_trace.txt 
内存溢出dump
-XX:-HeapDumpOnOutOfMemoryError 
-XX:HeapDumpPath=/data/applogs/HeapDumpOnOutOfMemoryError
</code></pre></li>
<li><p>垃圾收集器</p>
<pre><code>使用 ParNew 收集器 （只有 Serial 和 ParNew 这两个年轻代收集器可以和老年代的 CMS 收集器一起使用，ParNew 是多线程的）
-XX:+UseParNewGC：设置并行收集器
使用 ParNew + CMS + Serial Old，Serial Old 会在 CMS 预留内存超过 CMSInitiatingOccupancyFraction 设置的比例时触发使用
-XX:+UseConcMarkSweepGC  设置并发收集器
 CMS 无法做彻底清除，需预留一部分空间供并发收集时程序使用，这个设置预留比例40%
-XX:CMSInitiatingOccupancyFraction=60
如果没有这个参数, 只有第一次会使用 CMSInitiatingPermOccupancyFraction=70 这个值，后面的情况会自动调整
-XX:+UseCMSInitiatingOccupancyOnly
设置永久代使用超过 70% 触发 CMS GC
-XX:CMSInitiatingPermOccupancyFraction=70 
</code></pre></li>
<li><p>并发收集器设置  </p>
<pre><code> 并行 GC 时进行内存回收的线程数
-XX:ParallelGCThreads=4 
设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代
 对象每坚持一次 Minor GC 后年龄+1，当超过这个数值后进入老年代
-XX:MaxTenuringThreshold=9 
# 为了减少 CMS 重新标记的暂停时间，开启并行remark
-XX:+CMSParallelRemarkEnabled 
# 当使用 CMS 时希望又保留部分 System.gc() 的功能，只不过这种情况下触发的不是系统GC，而是 CMS GC
-XX:+ExplicitGCInvokesConcurrent 
 # 早期版本也需要设置这个才会回收永久代
-XX:+CMSPermGenSweepingEnabled
 # 只有设置才会让永久代触发 CMS GC
-XX:+CMSClassUnloadingEnabled
</code></pre></li>
</ol>
</li>
<li><p>调优总结</p>
<pre><code>[参考文章](&quot;http://www.importnew.com/13954.html&quot;)
</code></pre><ol>
<li><p>年轻代大小选择</p>
<pre><code>响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制
吞吐量优先的应用：尽可能的设置大
</code></pre></li>
<li><p>年老代大小选择</p>
<pre><code>吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代
</code></pre></li>
</ol>
</li>
</ol>
<h3 id="20170308"><a href="#20170308" class="headerlink" title="20170308"></a>20170308</h3><ol>
<li><p>linux常用命令值删除多个进程</p>
<pre><code>grep -v 是用来排除某一行数据的
ps -ef|grep  &apos;java&apos; |grep -v grep|cut -c 9-15|xargs kill -9
</code></pre></li>
<li><p>elasticsearch 安装插件</p>
<pre><code>安装集群管理软件
elasticsearch/bin/plugin install mobz/elasticsearch-head
安装zk分词
git checkout tags/{version}
mvn package
copy and unzip target/releases/elasticsearch-analysis-ik-{version}.zip to your-es-root/plugins/ik
</code></pre><p>3.ela启动不能用root</p>
<pre><code>因为安全问题elasticsearch 不让用root用户直接运行，所以要创建新用户
userAdd ela
启动时候 切换到su ela用户
./elasticserach -d 需要修改配置文件的端口号和elasticserarch.sh里面启动的Xms和Xmx的堆大小
</code></pre></li>
</ol>
<h3 id="20170309"><a href="#20170309" class="headerlink" title="20170309"></a>20170309</h3><ol>
<li><p>redis两种持久化方式</p>
<pre><code>一、Snapshot
    以快照的形式保存某一时刻的数据在磁盘,
    save &lt;seconds&gt; &lt;changes&gt;
    #在bgsave遇到error的时候是否停止持久化，默认是yes代表是，no代表不是
    stop-writes-on-bgsave-error yes
    #是否压缩，默认是yes代表是，no代表不是，如果想节省CPU的话就设为no，但是rdb文件会比较大
    rdbcompression yes
    #持久化的文件名字，默认是dump.rdb
    dbfilename dump.rdb
    #文件存放目录默认是redis.conf所在的目录./
    dir ./
    save &lt;seconds&gt; &lt;changes&gt;：在X秒内如果key有至少X次改变就触发持久化，
    例如save 900 1的话就是在900秒如果key有至少1次改变就触发持久化。
    如果想关闭此功能的话，可以把全部save行都注释或删除或者使用save 

二、append-only file(aof)
    以追加的方式记录所有写操作的命令到磁盘文件里面，
    #appendonly：是否启动aof，默认是no代表不启用，yes代表启用
    appendonly no
    #aof的文件名，默认是appendonly.aof
    appendfilename &quot;appendonly.aof&quot;
    #触发的间隔，默认是everysec代表每秒，另外还有always代表有改变都触发，性能最差但数据最安全，
    #no代表让OS自己决定什么时候执行，性能最好但数据不安全
    appendfsync everysec
    dir ./
三、Snapshot和AOF的对比  
 snapshot 如果在保存前服务器down了，那么在上次snapshot之后修改的数据会丢失。
 而AOF是记录所有的写操作，在数据完整性来说，AOF比snapshot要好
 aof一般是比rdb文件较大，恢复时间较长，因为要重新执行所有的写操作
 所以如果你可以容忍数据丢失的话，可以使用snapshot方式，
 而且也是比AOF要节省资源，否则的话就使用AOF方式，
 或者同时使用2种方式（重启的时候会优先使用AOF）。
</code></pre></li>
</ol>
<ol>
<li><p>redis 关闭命令</p>
<pre><code> 以前都是kill 太暴力了
src/redis-cli -a gaoguangjin shutdown
</code></pre></li>
<li><p>redis 批量处理</p>
<pre><code>如批量根据key查询结果或者批量插入 用pipeline管道操作。
</code></pre></li>
<li>redis hgetAll 有性能问题，不能一次性存储大量数据。 </li>
<li><p>redis pipeline原理</p>
<pre><code>一开始觉得redis transation 与redis的pipeline类似，都是把所有命令打包后，再一起发给服务端，其实这种理解是错误的。
一般情况下redis是request-&gt;response request-&gt;response request-&gt;response 这种阻塞是请求流程，当如果有批量的操作的时候
这种请求模式会有性能瓶颈的。
pipeline模式不用等待请求结果，一直发送命令，最后一次性获取。
transtaion模式是一次性发，一次性取，保证操作一致性。
如果有非常多的命令，也并不是一次性全部发送完最好，毕竟服务器是需要维护一个队列存储结果的，
如果命令太多，最好是分批，redis对此的建议是一万个
</code></pre><h3 id="20170310"><a href="#20170310" class="headerlink" title="20170310"></a>20170310</h3><ol>
<li><p>nginx安装ssl模块</p>
<pre><code>nginx -V 可以查看原来编译时都带了哪些参数
原来的参数：
--prefix=/app/nginx
添加的参数:
--with-http_stub_status_module --with-http_ssl_module --with-http_realip_module
步骤如下：
1. 使用参数重新配置:
./configure --prefix=/app/nginx -user=nobody -group=nobody --with-http_stub_status_module \
--with-http_ssl_module --with-http_realip_module \
--add-module=../nginx_upstream_hash-0.3.1/ \
--add-module=../gnosek-nginx-upstream-fair-2131c73/
2. 编译:
make
#不要make install，否则就是覆盖安装
3. 替换nginx二进制文件:./objs/是新编译后文件的目录
cp /app/nginx/sbin/nginx /app/nginx/sbin/nginx.bak
cp ./objs/nginx /app/nginx/sbin/
</code></pre></li>
<li><p>nginx开启websocket与https</p>
<p>#websocket<br>proxy_http_version 1.1;<br>proxy_set_header Upgrade $http_upgrade;<br>proxy_set_header Connection “Upgrade”;<br>#https<br>listen 443 ssl ;<br>#注意证书目录<br>ssl_certificate   cert/214040861080304.pem;<br>ssl_certificate_key  cert/214040861080304.key;<br>ssl_session_timeout 5m;<br>ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;<br>ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>ssl_prefer_server_ciphers on;</p>
</li>
</ol>
</li>
</ol>
<h3 id="20170313"><a href="#20170313" class="headerlink" title="20170313"></a>20170313</h3><ol>
<li><p>instanceof 与 isinstanceof()</p>
<pre><code>instanceof 是一个操作符（类似new， ==等)
 if (ins instanceof String) {
      //logic
  }
isInstance是Class类的一个方法:
if (String.class.isInstance(ins)){
}
</code></pre></li>
</ol>
<h3 id="20170314"><a href="#20170314" class="headerlink" title="20170314"></a>20170314</h3><ol>
<li><p>java 浅拷贝和深拷贝</p>
<pre><code>浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。
深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。
举例来说更加清楚：对象A1中包含对B1的引用，B1中包含对C1的引用。浅拷贝A1得到A2，A2 中依然包含对B1的引用，B1中依然包含对C1的引用。
深拷贝则是对浅拷贝的递归，深拷贝A1得到A2，A2中包含对B2（B1的copy）的引用，B2 中包含对C2（C1的copy）的引用。

所谓浅复制：则是只复制对象的引用，两个引用仍然指向同一个对象，在内存中占用同一块内存。
被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。
换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。
深复制：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。
那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。
换言之，深复制把要复制的对象所引用的对象都复制了一遍。

java中如果要实现深拷贝，必须要重写clone()方法来拷贝对象里面的应用类型变量
</code></pre></li>
</ol>
<h3 id="20170317"><a href="#20170317" class="headerlink" title="20170317"></a>20170317</h3><ol>
<li><p>java spi机制</p>
<pre><code>SPI为某个接口寻找服务实现的机制,例如日志模块的方案，xml解析模块、jdbc模块。
当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。
该文件里就是实现该服务接口的具体实现类。
而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。
基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。jdk提供服务实现查找的一个工具类：java.util.ServiceLoader
在项目class目录下面 META-INF/services/ 会有待实现的接口，文件名称就是接口名称例如：java.sql.Driver 
文件里面存放的内容就是接口的实现类名称。
ServiceLoader.load(XX.class) 就可以得到该类的实现类了
</code></pre><p><img src="http://o8c5x5dg6.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170317152838.png" alt="截图" title="截图"></p>
</li>
</ol>
<h3 id="20170323"><a href="#20170323" class="headerlink" title="20170323"></a>20170323</h3><ol>
<li><p>苹果javaPan推送时候报错：Received fatal alert: certificate_revoked </p>
<pre><code>证书过期了，没有及时更新接收推送的设备的客户端的证书和token
</code></pre></li>
</ol>
<h3 id="20170327"><a href="#20170327" class="headerlink" title="20170327"></a>20170327</h3><ol>
<li><p>java日志框架兼容 </p>
<pre><code>commons-logging和slf4j 都是定义日志框架的接口
log4j和logback 都是实现上面接口的类
java-util-logging：俗称jul
commons-logging:简称 jcl
**-over-slf4j都是为了适配用的，比如log4j-over-slf4j是将原来log4j打印的转换成logback打印
使用以下架包可以兼容使用logback时候的各种冲突
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre></li>
</ol>
<h3 id="20170330"><a href="#20170330" class="headerlink" title="20170330"></a>20170330</h3><ol>
<li><p>代码性能监控类StopWatch</p>
<pre><code>spring提供的StopWatch可以很容易实现对多个方法调用时间的监控，比较简单明了。当然如果代码里面有多线程代码肯定是不适用的。
</code></pre></li>
</ol>
<h3 id="20170412"><a href="#20170412" class="headerlink" title="20170412"></a>20170412</h3><ol>
<li><p>集合类初始容量和负载因子设置</p>
<pre><code>容器类：初始长度/扩容倍数 默认的。如果设置不到导致频繁的resize扩容
- ArrayList：10/1.5 没有扩容因子
- ArrayDeque：8/2
- BitSet：64/2
- HashMap：16/2 扩容因子0.75
- HashSet/TreeSet：同HashMap(基于HashMap实现，value为空Object) 扩容因子0.75
- Hashtable：11/2 扩容因子0.75
- WeakHashMap：同HashMap 扩容因子0.75
- PriorityQueue：11/Double size if small; else grow by 50%
- StringBuilder：16/按需
</code></pre><h3 id="20170418"><a href="#20170418" class="headerlink" title="20170418"></a>20170418</h3></li>
<li><p>ThreadLocal内存溢出</p>
<pre><code>使用ThreadLocal的时候 记得手动调用remove方法
</code></pre></li>
</ol>
<h3 id="20170425"><a href="#20170425" class="headerlink" title="20170425"></a>20170425</h3><ol>
<li>关于代码解耦</li>
</ol>
<pre><code>1、可以使用spring的事件驱动模型，订阅者和消费者。
ApplicationContextAware是用来实现发布消息的，ApplicationListener是用来订阅消息的
2、使用google的eventbus 轻量级别的代码层次解耦。
</code></pre><h3 id="20170510-hs-err-pid-log"><a href="#20170510-hs-err-pid-log" class="headerlink" title="20170510-hs_err_pid.log"></a>20170510-hs_err_pid.log</h3><ol>
<li><p>JVM致命错误日志（hs_err_pid.log）解读</p>
<pre><code>一般错误原因在第一行就可以看到
# There is insufficient memory for the Java Runtime Environment to continue.
# Native memory allocation (mmap) failed to map 6987776 bytes for committing reserved memory.
# Possible reasons:
#   The system is out of physical RAM or swap space
#   In 32 bit mode, the process size limit was hit
# Possible solutions:
#   Reduce memory load on the system
#   Increase physical memory or swap space
#   Check if swap backing store is full
#   Use 64 bit Java on a 64 bit OS
#   Decrease Java heap size (-Xmx/-Xms)
#   Decrease number of Java threads
#   Decrease Java thread stack sizes (-Xss)
#   Set larger code cache with -XX:ReservedCodeCacheSize=
# This output file may be truncated or incomplete.
#
#  Out of Memory Error (os_linux.cpp:2627), pid=15974, tid=139667856946944
</code></pre></li>
</ol>
<h3 id="20170512-高可用消息推送平台"><a href="#20170512-高可用消息推送平台" class="headerlink" title="20170512-高可用消息推送平台"></a>20170512-高可用消息推送平台</h3><p>1.公司现有的推送系统和<a href="http://www.infoq.com/cn/articles/HA-mobile-message-push-platform#anch147737" target="_blank" rel="external">参考文章</a></p>
<h3 id="20170605-mybatis动态参数"><a href="#20170605-mybatis动态参数" class="headerlink" title="20170605-mybatis动态参数"></a>20170605-mybatis动态参数</h3><p>1.对于日期类型判断只能判断是否为空，不能这样判断 <if test="createTime != null and createTime !='' "></if></p>
<pre><code>&lt;if test=&quot;createTime != null&quot;&gt;
  date(create_time) = date(#{createTime,jdbcType=TIMESTAMP})
&lt;/if&gt;
如果类型为Integer类型，就去掉 ！= ”的判断，只判断!=null即可。
如果是字符串类型比较
&lt;if test=&quot; name==&apos;你好&apos; &quot;&gt;
&lt;if&gt;
这样会有问题，换成
&lt;if test=&apos; name==&quot;你好&quot; &apos;&gt;
&lt;if&gt;
</code></pre><p>2.mybatis特殊字符处理<br>    &lt;![CDATA[ ]]&gt;<br>3.mybatis 批量插入和插入后获取主键的id值</p>
<pre><code>useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;
&lt;insert id=&quot;saveBatchArticle&quot; parameterType=&quot;java.util.List&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
   insert into tb_article (custom_id,
    media_name,title, custom_name,
    custom_price,  verify_url,
   status, flag, create_date,
   verify_date)
   &lt;foreach collection=&quot;list&quot; item=&quot;article&quot; separator=&quot; union all &quot;&gt;
     select
     #{article.customId},#{article.mediaName},#{article.title},#{article.customName},
     #{article.customPrice},#{article.verifyUrl},#{article.status},#{article.flag},
     #{article.createDate},#{article.verifyDate} from dual
   &lt;/foreach&gt;
 &lt;/insert&gt;
</code></pre><p>4.mybatis in（1,2）条件特殊处理</p>
<pre><code>&lt;select id=&quot;findByIdsMap&quot; resultMap=&quot;BaseResultMap&quot;&gt;
 Select
 &lt;include refid=&quot;Base_Column_List&quot; /&gt;
 from jria where ID in
 &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
  #{item}
 &lt;/foreach&gt;
&lt;/select&gt;
</code></pre><h3 id="20170614-表添加索引"><a href="#20170614-表添加索引" class="headerlink" title="20170614-表添加索引"></a>20170614-表添加索引</h3><p>1.好久没有写sql,提个数据库修改单还得按照dba的要求来。</p>
<pre><code>添加索引有以下两种方式
ALTER TABLE API_USERTOKEN add index idx_API_USERTOKEN_TOKEN (TOKEN);
create index  IDX_API_USERTOKEN_TOKEN on API_USERTOKEN(TOKEN);
</code></pre><p>2.删除指定日期数据</p>
<pre><code>delete from MQTT_PUSH_INFO where create_time&lt;(select DATE_FORMAT(date_add(now(), interval -3 MONTH),&apos;%Y-%m-%d 00:00:00&apos;))
</code></pre><p>3.删除大量数据,truncate不记录日志速度快</p>
<pre><code>truncate table MB_LOG_WAP_VISIT;
</code></pre><h3 id="20170615-equal和hashcode"><a href="#20170615-equal和hashcode" class="headerlink" title="20170615-equal和hashcode"></a>20170615-equal和hashcode</h3><pre><code>如果两个对象equal相等则hashCode一定相等，因为对象的equal比较的是引用地址，
而object的hashcode是native方法返回的也是object的引用地址
String类型重写了native的hashCode方法，只要长度一致，hashCode都是一样的。
如果判断两个对象是否相等最好重写equal和hashCode方法，例如set和map里面的key值
</code></pre><h3 id="20170615-replace空指针"><a href="#20170615-replace空指针" class="headerlink" title="20170615-replace空指针"></a>20170615-replace空指针</h3><pre><code>如果有多个replace例如
&quot;test&quot;.replace(&quot;param1&quot;,params.getParam1()).replace(&quot;param2&quot;,params.getParam2()).
       replace(&quot;param3&quot;,params.getParam3()).replace(&quot;param4&quot;,params.getParam4()).
       replace(&quot;param5&quot;,params.getParam5())
 params.getParam1()..params.getParam5()的值不可以为null
</code></pre><h3 id="20170619-为什么HashMap里面的数组size必须是2的次幂？"><a href="#20170619-为什么HashMap里面的数组size必须是2的次幂？" class="headerlink" title="20170619-为什么HashMap里面的数组size必须是2的次幂？"></a>20170619-为什么HashMap里面的数组size必须是2的次幂？</h3><pre><code>//http://nanguocoffee.iteye.com/blog/907824
//hashMap里面有这段源码，将number改成2的次幂
 private static int roundUpToPowerOf2(int number) {
      // assert number &gt;= 0 : &quot;number must be non-negative&quot;;
      return number &gt;= MAXIMUM_CAPACITY
              ? MAXIMUM_CAPACITY
              : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;
  }
    //然后将number-1 得到2进制1的个数越多，hash分布的就越均匀
    static int indexFor(int h, int length) {
         // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;
         return h &amp; (length-1);
     }
 //最终都是为了让hash分布的更加均匀点
</code></pre><h3 id="20170620-http协议复习"><a href="#20170620-http协议复习" class="headerlink" title="20170620-http协议复习"></a>20170620-http协议复习</h3><h3 id="20170621-深入java虚拟机复习"><a href="#20170621-深入java虚拟机复习" class="headerlink" title="20170621-深入java虚拟机复习"></a>20170621-深入java虚拟机复习</h3><h4 id="java虚拟机运行时数据区域"><a href="#java虚拟机运行时数据区域" class="headerlink" title="java虚拟机运行时数据区域"></a>java虚拟机运行时数据区域</h4><pre><code>1、程序计数器：
    【1】作用可以定义成查看当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计时器的值来选取下一条需要执行的字节码指令。例如分支，循环异常。线程恢复等功能，
    【2】因为多线程是通过线程轮流切换来实现的。在任何一个指定的时刻，一个处理器指挥处理一条线程中的指令，所以每个线程都需要一个独立的程序计数器，是 线程私有
    【3】如果线程执行的是ntive方法 则计数器为空。此区域是唯一一个在虚拟机规范中没有任何OutMeoryError

2、java虚拟机栈(Xss) stack
   【1】线程私有，描述的是Java方法的内存模型。每个方法被执行都会创建一个栈帧用来存放局部变量表，操作栈、动态链接等。
   【2】局部变量表存放了各种基本数据类型 boolean byte char short int float long double 、对象的引用 reference类型（可能是对象起始地址的引用指针）
   【3】64位的长度long和double的数据会占用两个局部变量空间（Sloat）【会导致线程安全问题】，其余的都只占用一个。
   【4】局部变量表所需要的内存空间都是在编译器完成分配的，在方法运行期间不会改变局部变量表的大小。全局变量是在堆里面，
   【5】 线程请求栈深度大于虚拟机允许的深度会抛出StackOverFlowError。如果虚拟机可以动态扩展，当扩展无法申请到足够的内存会抛出OutOfMemoryError异常

3、本地方法栈
  【1】 与虚拟机栈发挥作用相似，区别在于本地方法栈执行的是虚拟机使用到的Native方法。而虚拟机栈使用的是java方法服务 。
  【2】 线程请求栈深度大于虚拟机允许的深度会抛出StackOverFlowError。如果虚拟机可以动态扩展，当扩展无法申请到足够的内存会抛出OutOfMemoryError异常


4、java堆（-Xmx  和-Xms）heap
 【1】Java Heap 是java虚拟机中管理内存最大的一块，所有线程共享的一块内存区域。虚拟机启动时候创建，目的就是存放对象实例，几乎所有对象都在这里分配内存。
 【2】Java 虚拟机规范中描述：所有的对象实例以及数组都要在堆上面分配内存。
 【3】Java 堆是垃圾收集器管理的主要区域。java堆可分为：新生代和老年代。  再细致点有Eden空间、From Survivor 空间、To Survivor空间,
 【4】Java 堆处于物理上不连续的内存空间中。可以通过设定 -Xmx 和 -Xms设定jvm内存大小


5、方法区
 【1】、多个线程共享内存区域，用于存储已被虚拟机加载的类信息、静态变量，及时编译器后的代码。
 【2】、垃圾收集行为在这个区域是比较少出现的

6、运行时常量池(-XX:PermSize -XX:MaxPremSize)
 【1】、是方法区的一个部分，.class文件中除了有类的版本、字段、方法、接口等信息外，还有常量池用于存放编译期生成的各种字面量的符号引用，这部分内容将在类加载后存放到方法区的运行时常量池，可以在运行期间将常量放入池中。

7、本机内存（-XX:MaxDirectMemorySize指定。）如果不指定那就是默认和java堆的最大值一样（-Mmx）
java.lang.OutOfMemoryError
</code></pre><h4 id="java垃圾回收知识点"><a href="#java垃圾回收知识点" class="headerlink" title="java垃圾回收知识点"></a>java垃圾回收知识点</h4><ul>
<li><p>垃圾回收判断</p>
<pre><code>判断对象已死根据引用计数算法是不行的，因为如果两个对象相互引用那么他们的计数就不可能为0，
根据可达性分析算法，如果一个对象无法到达其GC ROOTs时候，则可以判断这个对象为可回收对象，
可作为GC ROOTS的对象有 方法区中静态属性引用的对象和常量引用的对象，还有虚拟机栈中引用的对象和本地方法栈引用的对象
一个对象的死亡会经历两次标记，如果对象在进行可达性分析后没有与GC ROOTS相连接的引用链，会进行第一次标记和进行
一次刷选， 刷选的条件就是此对象是否有必要执行finalize()方法，当对象没有重写finalize()或者finalize（）方法已经被
执行过了，这就没必要执行刷选了。如果对象在finalize（）方法里面重写与引用链上的对象关联，就不会被回收。
如果对象没有必要执行finalize（）则这些对象会放到F-quenen队列中，由虚拟机去触发执行 然后进行第二次标记
</code></pre></li>
<li><p>垃圾收集算法</p>
<pre><code>标记-清除算法：标率低，会有不连续的内存碎片
复制算法：将内存分成一半，代价就是内存缩下一半了，如果对象存活率较高就需要进行过多的复制操作
标记-整理算法： 和标记清除算法类似
分代收集算法：新生代使用复制算法，老年代因为对象存活高使用标记-清理或者标记-整理算法
</code></pre></li>
<li><p>垃圾收集器</p>
<pre><code>新生代：
    Serial收集器：单线程的
    ParNew收集器：多线程的
    CMS收集器：并发收集、低停顿 一般互联网网站使用多，重视服务响应速度，
    收集的时候是一种以最短回收停顿时间为目标的收集器，是基于“标记-清除”算法实现的
    G1收集器：
</code></pre></li>
</ul>
<h4 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h4><ul>
<li><p>类的生命周期</p>
<pre><code>加载-》【验证-&gt;准备-&gt;解析】（可以合并为连接）-》初始化=》使用=》卸载
</code></pre></li>
<li><p>类必须要进行初始化</p>
<pre><code>1、遇到new，getstatic等字节码指令。生成这些字节码的java 场景有new关键字，设置一个类的静态子段。
2、利用reflect方法对类进行反射调用。
3、当初始化一个类，如果父类没初始化，首先初始化父类
4、虚拟机启动时候，需要指定一个要执行的类，也就是main方法。
</code></pre></li>
<li><p>加载</p>
<pre><code>1、通过类名去获取定义此类的二进制字节流。
2、将这个字节流所代表的静态存储结构转换成运行时方法区的数据结构。
3、在java堆中生成代表这个类的对象，作为方法区这些参数访问的入口。
</code></pre></li>
<li><p>验证</p>
<pre><code>1、文件格式验证，是否以魔数开头，主版本是否在当前虚拟机处理范围内。
2、元数据验证
3、字节码验证
4、符号引用验证
</code></pre></li>
<li><p>准备</p>
<pre><code>为类变量分配内存，并设置类变量初始值。（static修饰的变量）例如给int赋值0
</code></pre></li>
<li><p>解析</p>
<pre><code>类和接口的解析、字段解析、类方法解析、接口方法解析
</code></pre></li>
<li><p>初始化</p>
<pre><code>调用static{}方法，如果有父类的话会先调用父类的static方法
</code></pre></li>
<li><p>类的加载器</p>
<pre><code>双亲委派模型：是为了安全考虑而设计的
某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，
如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。
加载器有 启动类加载器（bootstarp classLoader）==&gt;
扩展类加载器（Extension ClassLoader）==&gt;应用程序加载器（Application ClassLoader）==&gt;自定义类加载器

启动（Bootstrap）类加载器：是用本地代码实现的类装入器，它负责将 &lt;Java_Runtime_Home&gt;/lib下面的类库加载到内存中（比如rt.jar）。
由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。

标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。
它负责将&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。

系统（System）类加载器：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。
它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。
</code></pre></li>
</ul>
<h4 id="早期编译器优化"><a href="#早期编译器优化" class="headerlink" title="早期编译器优化"></a>早期编译器优化</h4><ul>
<li><p>泛型与类型擦除</p>
<pre><code>泛型的代码通过反编译后查看编译后的字节码，所有的类型都变成了原生类型，并且在相应的地方进行强制转换
</code></pre></li>
<li><p>自动装箱、拆箱与遍历循环</p>
<pre><code>遍历循环会变成迭代器实现方式
int方法会自动装箱变成integer
</code></pre><h4 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h4><pre><code>java线程-&gt;工作内存-》（save和load操作）-》主内存
java线程-&gt;工作内存-》（save和load操作）-》主内存
java线程-&gt;工作内存-》（save和load操作）-》主内存
java线程-&gt;工作内存-》（save和load操作）-》主内存

java内存操作指令：
lock/unlock/read/write 主内存
load/user/assign/store 工作内存
read and load 从主存赋值变量到工作内存
user and assign 执行代码和改变共享变量（可能出现多次）
store and write  写到工作内存，同时拷贝到主内存
</code></pre><h4 id="并发编程三个概念"><a href="#并发编程三个概念" class="headerlink" title="并发编程三个概念"></a>并发编程三个概念</h4><p>   原子性：一个操作要么全部执行，并且执行过程中不被打断，要么不执行。<br>   synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性<br>   可见性：多个线程对变量操作之后，别的线程可以立即感知到。</p>
<pre><code>volatile,synchronized和Lock也能够保证可见性
</code></pre><p>   有序性：防止指令重排序,它只会对不存在数据依赖性的指令进行重排序.<br>   synchronized和Lock来保证有序性</p>
</li>
</ul>
<h4 id="happens-before原则（先行发生原则"><a href="#happens-before原则（先行发生原则" class="headerlink" title="happens-before原则（先行发生原则)"></a>happens-before原则（先行发生原则)</h4><pre><code>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
</code></pre><h3 id="20170622-transient关键字"><a href="#20170622-transient关键字" class="headerlink" title="20170622-transient关键字"></a>20170622-transient关键字</h3><pre><code>transient 修饰的变量都不参与序列化，当反序列化的时候所有transient 修饰的成员变量字段值都是null
</code></pre><h3 id="20170622-数据库复习"><a href="#20170622-数据库复习" class="headerlink" title="20170622-数据库复习"></a>20170622-数据库复习</h3><h4 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h4><pre><code>数据库事务的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，
这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。
读未提交（会出现脏读、重复读、幻读）、读已提交（会出现重复读、幻读）、重复读（会出现幻读）、序列化
读未提交场景：A、B同时开启事物，A修改数据但没提交，B这时候读取到A修改的数据继续后面的操作，
但是如果A事物回滚了，就会导致B读取到的脏数据
读已提交：可以解决脏读的情况，但是会有重复读的情况
大多数数据库的默认级别就是Read committed。
重复读：A、B同时开启事物，A将某表字段值从1000修改成500 ，但是还没提交事物，B这时候读取到是1000，这时候
A再提交事物，B再重新读取该字段，发现值变成了500，这就会导致重复读的情况了。这是MySQL的默认事务隔离级别。
如果将事物级别设置成重复读，在同一个事务内的查询都是事务开始时刻一致的，也就是无论查询多少次值都是一样的，
也就可以解决重复读的情况
幻读情况：虽然数据库事物级别设置成重复读，但是如果会出现幻读的情况 比如A事物执行select * from table,返回了
5条数据，这时候另外一个操作往这个表里面添加一条数据，再次执行select * from table,发现返回了6条数据，这就是
幻读的情况！
</code></pre><h4 id="死锁情况"><a href="#死锁情况" class="headerlink" title="死锁情况"></a>死锁情况</h4><pre><code>不同表相同记录行锁冲突
相同表相同记录行
不同索引锁冲突
比如 update table where id&gt;1 和 update table where id=2  会导致死锁
</code></pre><h4 id="spring事物传播特性"><a href="#spring事物传播特性" class="headerlink" title="spring事物传播特性"></a>spring事物传播特性</h4><pre><code>PROPAGATION_REQUIRED ：用的最多的，如果当前方法没有事物那就先建立一个事物，如果有，那就加入到这个事物。
PROPAGATION_SUPPORTS ：支持当前事务，如果当前没有事务，就以非事务方式执行。
PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。
PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。
PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作
</code></pre><h3 id="20170622-动态代理"><a href="#20170622-动态代理" class="headerlink" title="20170622-动态代理"></a>20170622-动态代理</h3><pre><code>底层原理：
都是在代理类目录生成一个**$**.class带有$的代理编译后的类，调用的时候就是调用这个代理类
spring aop使用的有jdk和cglib，jdk创建代理对象的时间比cglib短，但是代理方法的执行时间比cglib慢
如果spring里面用到的对象单例模式的比较多，就建议使用cglib模式，虽然启动时间会长点，但是提高程序效率
dubbo里面使用较多的就是avassist代理，因为有时候不需要代理整个类，只用代理某个方法
</code></pre><h4 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h4><pre><code>针对接口进行代理的，不可以对普通类进行代理
核心代码：
InterfaceInvocationHandler implements InvocationHandler{
public Object invoke(Object object, Method method, Object[] objects){}
}
Interface jdkProxy = (Interface) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),
new Class[] { Interface.class }, new InterfaceInvocationHandler(interfaceImp))
</code></pre><h4 id="cglib"><a href="#cglib" class="headerlink" title="cglib"></a>cglib</h4><pre><code>针对类进行代理的，比较自由
核心代码：
Enhancer enhancer = new Enhancer();
enhancer.setCallback(new CglibInterceptor(delegate));
enhancer.setInterfaces(new Class[] { CountService.class });
CountService cglibProxy = (CountService) enhancer.create();
class CglibInterceptor implements MethodInterceptor {
public Object intercept(Object object, Method method,
        Object[] objects,MethodProxy methodProxy) throws Throwable {
}
</code></pre><h4 id="JAVAASSIST字节码"><a href="#JAVAASSIST字节码" class="headerlink" title="JAVAASSIST字节码"></a>JAVAASSIST字节码</h4><pre><code>只需用字符串拼接出Java源码，便可生成相应字节码
</code></pre><h3 id="20170703-for-each原理和java迭代注意"><a href="#20170703-for-each原理和java迭代注意" class="headerlink" title="20170703-for each原理和java迭代注意"></a>20170703-for each原理和java迭代注意</h3><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>For-each语法内部，对collection是用nested iteratoration来实现的，对数组是用下标遍历来实现。
</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><pre><code>对于集合尽量不要用for each 因为本质都是转换成iterator
LinkedHashMap 不要在迭代器iterator里面使用get方法，因为get()方法会修改LinkedHashMap中的链表结构，
以便将最近访问的元素放置到链表的末尾
在集合内部维护一个字段modCount用于记录集合被修改的次数，每当集合内部结构发生变化(add,remove，set)时，modCount+1。
List在迭代器内部也维护一个字段expectedModCount，同样记录当前集合修改的次数，初始化为集合的modCount值。
当我们在调用Iterator进行遍历操作时，如果有其他线程修改list会出现modCount!=expectedModCount的情况，
就会报并发修改异常java.util.ConcurrentModificationException。
</code></pre><h4 id="for-each对象"><a href="#for-each对象" class="headerlink" title="for each对象"></a>for each对象</h4><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(1);
for (Integer i : list) {
    System.out.println(&quot;&quot; + i);
}
通过编译后的字节码，虚拟机将以上代码转换成了迭代器
INVOKEINTERFACE java/util/List.iterator ()Ljava/util/Iterator;
FRAME APPEND [java/util/List java/util/Iterator]
INVOKEINTERFACE java/util/Iterator.hasNext ()Z
INVOKEINTERFACE java/util/Iterator.next ()Ljava/lang/Object;
</code></pre><h3 id="20170704-linux线程gc查询"><a href="#20170704-linux线程gc查询" class="headerlink" title="20170704-linux线程gc查询"></a>20170704-linux线程gc查询</h3><pre><code>jstat -gc pid 250 4 //每隔250ms 打印四次Java垃圾回收详情
jstat -gc pid 250 //每隔250ms 打印Java垃圾回收详情
S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC     CCSU      YGC     YGCT    FGC    FGCT     GCT
6080.0 6080.0  0.0   3014.3 48640.0  22188.1   121148.0   62950.3   62720.0 61800.1 7936.0 7742.1    277    1.328   6      0.784    2.111
6080.0 6080.0  0.0   3014.3 48640.0  22190.5   121148.0   62950.3   62720.0 61800.1 7936.0 7742.1    277    1.328   6      0.784    2.111
S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）
EC、EU：Eden区容量和使用量
OC、OU：年老代容量和使用量
PC、PU：永久代容量和使用量
YGC、YGT：年轻代GC次数和GC耗时
FGC、FGCT：Full GC次数和Full GC耗时
GCT：GC总耗时
</code></pre><h3 id="20170705-java对象的强、软、弱、虚引用"><a href="#20170705-java对象的强、软、弱、虚引用" class="headerlink" title="20170705-java对象的强、软、弱、虚引用"></a>20170705-java对象的强、软、弱、虚引用</h3><pre><code>强引用：垃圾回收期不会主动去回收，哪怕Java虚拟机报OutOfMemoryError
软引用：当Java堆内存不够的时候，才会进行回收
弱引用：比软引用更容易被回收，当垃圾回收期线程执行的时候，不管当前堆内存是否够，都会回收
不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
</code></pre><h4 id="ThreadLocal原理与内存泄露"><a href="#ThreadLocal原理与内存泄露" class="headerlink" title="ThreadLocal原理与内存泄露"></a>ThreadLocal原理与内存泄露</h4><pre><code>    ThreadLocal为每一个线程创建的单独变量副本，底层是有ThreadLocal.ThreadLocalMap去维护的，每一个
线程都有一个独立的ThreadLocalMap，ThreadLocal实例就是map对应的key。
例如set的时候，首先获取当前线程的ThreadLocalMap 然后再放值。
    ThreadLocalMap的key是弱引用，当我们吧threadLocal置为null时候，thread会被gc,
  但是value缺不会被回收，因为还有value还有强引用，只有当当前thread结束后，value
  才会被回收。比如我们使用线程池的时候，Thread是不会被回收的，所以就会发生内存泄露的。
  最好的方法就是手动调用remove();
</code></pre><h3 id="20170706-设计模式回顾"><a href="#20170706-设计模式回顾" class="headerlink" title="20170706-设计模式回顾"></a>20170706-设计模式回顾</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><pre><code>懒汉、饿汉、doublecheck、匿名类
</code></pre><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><pre><code>简单工厂：例如获取jdbc的方式
工厂方法模式：父类定义抽象接口，子类负责生成具体的对象，将类的实例化操作延迟到子类。
抽象工厂模式：抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。
它针对的是有多个产品的等级结构。而工厂方法模式针对的是一个产品的等级结构。
在只有一个产品族的情况下，抽象工厂模式实际上退化到工厂方法模式
</code></pre><h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><pre><code>例如 io流 new FileInputStream（new File()）
</code></pre><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><pre><code>例如jdk的动态代理
</code></pre><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><pre><code>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化
</code></pre><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><pre><code>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换
</code></pre><h4 id="迭代模式"><a href="#迭代模式" class="headerlink" title="迭代模式"></a>迭代模式</h4><pre><code>list迭代器
</code></pre><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><pre><code>spring 里面用到了ApplicationEvent 和ApplicationListener，
applicationContext.publishEvent（Event）;
观察者订阅，订阅者发生变动时候通知所有观察者。
</code></pre><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><pre><code>当第三方定义好了接口AInterface，但是并没有给具体的实现，我们就可以定义一个适配类Adapter，
适配器类也实现了AInterface的所有方法。
AInterfaceImp extends Adapter implement AInterface{
     method (){
     super.method();
     }
}
</code></pre><h3 id="20170707-通过Java字节码去看原理"><a href="#20170707-通过Java字节码去看原理" class="headerlink" title="20170707-通过Java字节码去看原理"></a>20170707-通过Java字节码去看原理</h3><pre><code>idea 可以安装ASM ByteCode 插件直接查看编译后的字节码
将一个局部变量加载到操纵栈的指令包括：iload、iload_、lload…
将一个数值从操作数栈存储到局部变量表的指令包括：istore、istore_、lstore…
一般都是先将局部变量加载到操作数栈，然后对操作数栈这个数据进行处理后再
将操作数栈的数据存储到局部变量表
</code></pre><h4 id="i-与-i的原理"><a href="#i-与-i的原理" class="headerlink" title="i++与++i的原理"></a>i++与++i的原理</h4><pre><code>①int i = 0;  ②int i = 0;  3、int i = 0;
  i = i++;    i = ++i;      i++ 
 对应的字节码。
   ①iconst_0        ②iconst_0 
    istore_1          istore_1
    iload_1           iinc 1,1 该命令给局部变量表的1号位置的int值增加1
    iinc 1,1          iload_1
    istore_1          istore_1
 ①虽然都有 iinc 1,1的操作，但是1在自增后没有将局部变量i自增后的值load到操作数栈（缺少 iload_1命令），
 导致自增的值被istore_1 原来操作数栈0的值给覆盖了。
 2与3的效果作用一样，都是包含iload的操作
</code></pre><h4 id="for-each的处理"><a href="#for-each的处理" class="headerlink" title="for each的处理"></a>for each的处理</h4><pre><code>For-each语法内部，对collection是用nested iteratoration来实现的，对数组是用下标遍历来实现。
</code></pre><h4 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h4><pre><code>Integer i = 10;
int n = i;
对应的字节码：装箱的时候是用到包装类的valueof(),拆箱时候用到的是包装类的intValue();
INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
INVOKEVIRTUAL java/lang/Integer.intValue ()
Integer包装类在加载的时候会初始化-128到127的缓存对象值，所以比较==的时候需要注意。
</code></pre><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><pre><code>List&lt;String&gt; list=new ArrayList&lt;&gt;();
list.add(&quot;1&quot;);
String a=list.get(1);
对应字节码：没有一点泛型的信息。
INVOKEINTERFACE java/util/List.add (Ljava/lang/Object;)Z
ALOAD 0
ICONST_1
INVOKEINTERFACE java/util/List.get (I)Ljava/lang/Object;
CHECKCAST java/lang/String
ASTORE 1
java泛型的实现原理是类型擦除。Java的泛型是伪泛型。在编译期间，所有的泛型信息都会被擦除掉。
JAVA的泛型只是一个语法糖，实际上在运行时还是有类型转换的过程，从JVM生成的代码来看，
和传递一个Object（或者extends的类型）没什么区别。当然泛型的最大好处是编绎期的类型错误检查
</code></pre><h3 id="20170711-linux常用命令复习"><a href="#20170711-linux常用命令复习" class="headerlink" title="20170711-linux常用命令复习"></a>20170711-linux常用命令复习</h3><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><pre><code>例如 777 rwx rwx rwx
从左至右，1-3位数字代表文件所有者的权限，4-6位数字代表同组用户的权限，7-9数字代表其他用户的权限。
r=4，w=2，x=1
</code></pre><h3 id="20170712-QPS"><a href="#20170712-QPS" class="headerlink" title="20170712-QPS"></a>20170712-QPS</h3><pre><code>qps类似于tps，是可以反映系统吞吐量的重要指标。
QPS（TPS）= 并发数/平均响应时间    或者   并发数 = QPS*平均响应时间。
qps是和并发数有关的，相同qps的如果并发数越大，证明系统性能越好。
当别人说系统qps的时候先问下是在多大并发下的指标
</code></pre><h3 id="20170713-TCP-IP相关"><a href="#20170713-TCP-IP相关" class="headerlink" title="20170713-TCP/IP相关"></a>20170713-TCP/IP相关</h3><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><pre><code>https使用对称加密+非对称加密+CA(赛门铁克CA)认证 三个技术合并到一起，才保证数据传输的安全。
首先使用RSA算法生产一对秘钥 K1和K2，K1是公钥，k2是秘钥，K1加密后的数据必须要K2才可以解密。
服务端发送K1到目的地，然后目的地在生成一个用来对称加密传输的秘钥K3,然后再用k1就加密k3
再传输给服务端，服务端再用k2去解密得到秘钥k3,这样双方就可以进行aes对称加密算法进行传输
</code></pre><h4 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h4><pre><code>200 - 服务器成功返回网页
404 - 请求的网页不存在
503 - 服务器超时
3xx -重定向
</code></pre><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><pre><code>应用层：应用软件使用的协议，例如pop3/smtp/http协议
表示层： 决定数据的展现方式，比如图片可以是jpeg/bmp/png
会话层:为两端通信实体建立连接
传输层：将数据分成很多小段，进行传输
网络层：路由选择，选择通信使用协议http,ftp ，指定路由策略
数据链路层：根据端口与MAC地址，做分组（VLAN）隔离、端口安全、访问控制。
物理层：将数据最终编码为用0、1标识的比特流，然后传输
</code></pre><h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h4><pre><code>应用层：
    FTP、DNS、HTTP协议
    可以对应osi的应用层、表示层、会话层。
传输层：tcp与udp协议
网络层：
链路层：硬件部分如 网卡、光纤
</code></pre><h4 id="TCP数据段格式"><a href="#TCP数据段格式" class="headerlink" title="TCP数据段格式"></a>TCP数据段格式</h4><pre><code> 顺序号字段：Seq序号，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。　　
 确认号字段：只有ACK标志为1时，确认号字段才有效。　
 SYN：发起一个连接
 ACK：确认序号有效
 FIN:释放一个连接
 需要注意的是：
（A）不要将确认序号Ack与标志位中的ACK搞混了。
（B）确认方Ack=发起方Req+1，两端配对。
</code></pre><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><pre><code>    第一次握手：client端将标志位syn置为1，随机产生一个序号seq=j,然后将该数据包发送给
server端，client进入syn_sent状态，等待server确认。
     第二次握手：server端收到数据包后，通过标志位syn=1知道client端要请求建立连接，server
端将标志位SYN和ACK都置为1，ack=j+1（确认序号）,随机产生一个seq=K,并将该数据包发给client以确认请求，
server端进入syn_rcvd状态。
      第三次握手：client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将ACK置为1，
ack=K+1，并将该数据包发给server，server检查ack是否为K+1,ACK是否为1，如果正确则建立成功
，client和server进入established状态，完成三次握手，随后进行数据传输。established
</code></pre><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><pre><code>主动关闭流程，客户端先发起申请
第一次挥手：client端发送FIN，用来关闭client到server端的数据传输，client进入fin_wait_!状态。
第二次挥手：server端收到FIN后，发送一个ACK到client端，确认序号为收到序号+1，server进入close_wait状态
第三次挥手：server发送一个FIN,用来关闭server到client的数据传输，server进入last_ack状态
第四次挥手：client收到FIN，client进入TIME_WAIT状态，接着发送一个ACK给server 确认序号为收到序号+1，
server进入closed状态，完成四次挥手。
为什么建立连接是三次握手，而关闭连接却是四次挥手呢
服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，
仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，
也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。
通俗说就是挥手的时候是server端先发送ACK 然后再发送FIN
</code></pre><h4 id="syn攻击"><a href="#syn攻击" class="headerlink" title="syn攻击"></a>syn攻击</h4><pre><code>    在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，
当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，
Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，
这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。
SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，
使用如下命令可以让之现行：
#netstat -nap | grep SYN_RECV
</code></pre><h4 id="与http相关协议"><a href="#与http相关协议" class="headerlink" title="与http相关协议"></a>与http相关协议</h4><pre><code>ip协议:使用 ARP 协议凭借 MAC 地址进行通信
tcp协议:TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对,
为了确保信息能够确保准确无误的到达，TCP采用了著名的三次握手策略.
dns:DNS(Domain names System) 和HTTP协议一样是处于应用层的服务，提供域名到IP地址之间的解析服务
</code></pre><h4 id="time-wait与close-wait"><a href="#time-wait与close-wait" class="headerlink" title="time_wait与close_wait"></a>time_wait与close_wait</h4><pre><code>服务器在处理客户端请求的时候，如果你的程序设计为服务器主动关闭，那么你才有可能需要关注这个TIMEWAIT状态过多的问题。
如果你的服务器设计为被动关闭，那么你首先要关注的是CLOSE_WAIT。
</code></pre><h5 id="time-wait"><a href="#time-wait" class="headerlink" title="time_wait"></a>time_wait</h5><pre><code>主动正常关闭TCP连接，都会出现TIMEWAIT。
在高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接这个场景下，会出现大量socket处于TIMEWAIT状态。
如果客户端的并发量持续很高，此时部分客户端就会显示连接不上
高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。
如何尽量处理TIMEWAIT过多
linux没有在sysctl或者proc文件系统暴露修改这个TIMEWAIT超时时间的接口，可以修改内核协议栈代码中关于这个TIMEWAIT的超时时间参数，重编内核，让它缩短超时时间，加快回收
sysctl改两个内核参数就行了，如下：
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
</code></pre><h5 id="close-wait"><a href="#close-wait" class="headerlink" title="close_wait"></a>close_wait</h5><pre><code>    服务器A是一台爬虫服务器，它使用简单的HttpClient去请求资源服务器B上面的apache获取文件资源，正常情况下，如果请求成功，那么在抓取完 资源后，
服务器A会主动发出关闭连接的请求，这个时候就是主动关闭连接，服务器A的连接状态我们可以看到是TIME_WAIT。
如果一旦发生异常呢？假设 请求的资源服务器B上并不存在，那么这个时候就会由服务器B发出关闭连接的请求，服务器A就是被动的关闭了连接，
如果服务器A被动关闭连接之后程序员忘了 让HttpClient释放连接，那就会造成CLOSE_WAIT的状态了
</code></pre><h4 id="如何提高单机短连接QPS"><a href="#如何提高单机短连接QPS" class="headerlink" title="如何提高单机短连接QPS"></a>如何提高单机短连接QPS</h4><pre><code>http://weibo.com/ttarticle/p/show?id=2309404037884855362229
tcp应该有客户端发起连接关闭，默认情况下客户端关闭TCP连接后本地的临时端口
会进入time_wait状态，这对qps提升有很大限制
增加临时端口的数量，增加可被消耗的临时端口资源
sysctl -w &quot;net.ipv4.ip_local_port_range=1024 65535”
第一种方法是启用tw_reuse，tw_reuse能加速TIME_WAIT状态端口在几秒时间内安全的回收
sysctl -w net.ipv4.tcp_timestamps=1
sysctl -w net.ipv4.tcp_tw_reuse=1
2.6.32内核下启动tw_reuse短连接可以达到2w，性能并不稳定；
第二种方法更激进些，启用tw_recycle，tw_recycle允许在两个RTT。当多个客户端处于NAT后时，在服务器端开启tw_recycle会引起丢包问题，如果丢SYN包，就会造成新建连接失败
sysctl -w net.ipv4.tcp_timestamps=1
sysctl -w net.ipv4.tcp_tw_recycle=1
2.6.32内核下启动tw_recycle短连接可以达到6w，比较稳定；
</code></pre><h4 id="etc-sysctl-conf"><a href="#etc-sysctl-conf" class="headerlink" title="/etc/sysctl.conf"></a>/etc/sysctl.conf</h4><pre><code>#对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃,不应该大于255，默认值是5，对应于180秒左右时间
net.ipv4.tcp_syn_retries=2
#net.ipv4.tcp_synack_retries=2
#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为300秒
net.ipv4.tcp_keepalive_time=1200
net.ipv4.tcp_orphan_retries=3
#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间
net.ipv4.tcp_fin_timeout=30
#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。
net.ipv4.tcp_max_syn_backlog = 4096
#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭
net.ipv4.tcp_syncookies = 1

#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭
net.ipv4.tcp_tw_reuse = 1
#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭
net.ipv4.tcp_tw_recycle = 1

##减少超时前的探测次数
net.ipv4.tcp_keepalive_probes=5
##优化网络设备接收队列
net.core.netdev_max_backlog=3000
修改完之后执行/sbin/sysctl -p让参数生效。
这里头主要注意到的是net.ipv4.tcp_tw_reuse
net.ipv4.tcp_tw_recycle
net.ipv4.tcp_fin_timeout
net.ipv4.tcp_keepalive_*
这几个参数。
net.ipv4.tcp_tw_reuse和net.ipv4.tcp_tw_recycle的开启都是为了回收处于TIME_WAIT状态的资源。
net.ipv4.tcp_fin_timeout这个时间可以减少在异常情况下服务器从FIN-WAIT-2转到TIME_WAIT的时间。
net.ipv4.tcp_keepalive_*一系列参数，是用来设置服务器检测连接存活的相关配置。
</code></pre><h3 id="20170714-mysql相关"><a href="#20170714-mysql相关" class="headerlink" title="20170714-mysql相关"></a>20170714-mysql相关</h3><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><pre><code>1. 优化更需要优化的Query；
2. 定位优化对象的性能瓶颈；
3. 明确的优化目标；
4. 从Explain 入手；
5. 多使用profile
6. 永远用小结果集驱动大的结果集；
7. 尽可能在索引中完成排序；
8. 只取出自己需要的Columns；
9. 仅仅使用最有效的过滤条件；
10. 尽可能避免复杂的Join 和子查询；
</code></pre><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><pre><code>1. MyISAM 存储引擎索引键长度总和不能超过1000 字节；
2. BLOB 和TEXT 类型的列只能创建前缀索引；
3. MySQL 目前不支持函数索引；
4. 使用不等于（!= 或者&lt;&gt;）的时候MySQL 无法使用索引；
5. 过滤字段使用了函数运算后（如abs(column)），MySQL 无法使用索引；
6. Join 语句中Join 条件字段类型不一致的时候MySQL 无法使用索引；
7. 使用LIKE 操作的时候如果条件以通配符开始（ &apos;%abc...&apos;）MySQL 无法使用索引；
8. 使用非等值查询的时候MySQL 无法使用Hash 索引；
9. 某字段类型为varchar类型，根据查询关键字段查询时，写入值为Int类型，导致无法命中索引
10.查询条件左边写入函数，导致无法命中索引
</code></pre><h4 id="10条SQL技巧"><a href="#10条SQL技巧" class="headerlink" title="10条SQL技巧"></a>10条SQL技巧</h4><pre><code>1.负向条件查询不能使用索引
select * from order where status!=0 and stauts!=1
    not in/not exists/&lt;&gt; 都不行
    可以优化为in查询：
    select * from order where status in(2,3)
2.前导模糊查询不能使用索引
    select * from order where desc like &apos;%XX&apos;
   而非前导模糊查询则可以：
    select * from order where desc like &apos;XX%&apos;
3.数据区分度不大的字段不宜使用索引
    select * from user where sex=1
    原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。
    经验上，能过滤80%数据时就可以使用索引。
    对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。
4.在属性上进行计算不能命中索引
    select * from order where YEAR(date) &lt; = &apos;2017&apos;
    可以改成属性右边的函数
    select * from order where date &lt; = CURDATE()
    或者：
    select * from order where date &lt; = &apos;2017-01-01&apos;
5.允许为null的列，查询有潜在大坑(特别注意)
    单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集
    select * from user where name != &apos;shenjian&apos;
    如果name允许为null，索引不存储null值，结果集中不会包含这些记录，会导致查询的结果缺少结果集
6.复合索引最左前缀，并不是值SQL语句的where顺序要和复合索引一致
7.如果明确知道只有一条结果返回，limit 1能够提高效率
     select * from user where login_name=?
     可以优化为：
     select * from user where login_name=? limit 1
    你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动
8.把计算放到业务层而不是数据库层，除了节省数据的CPU，还有意想不到的查询缓存优化效果
    释放了数据库的CPU
    多次调用，传入的SQL相同，才可以利用查询缓存
9.强制类型转换会全表扫描
    select * from user where phone=13800001234;
        改成
    select * from user where phone=&quot;13800001234&quot;;
</code></pre><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre><code>较频繁的作为查询条件的字段应该创建索引
唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件；
更新非常频繁的字段不适合创建索引
单键索引还是组合索引
</code></pre><h5 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h5><pre><code>主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引
聚簇索引的叶子节点就是数据节点.
特点是存储数据的顺序和索引顺序一致
</code></pre><h5 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h5><pre><code>叶子节点仍然是索引节点，只不过有指向对应数据块的指针,索引表中的顺序通常与实际的页码顺序是不一致
</code></pre><h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h5><pre><code>多个字段建立的索引，组合索引的第一个字段必须出现在查询组句中，不然会导致索引失效
比如组合索引create index index_a_b_c on table（a,b,c）
a|(a,b|b,a)|a,b,c等等 但是如果是 b,c索引就不会生效了。
最左前缀就是最左的索引列优先，b,a都会被数据库引擎优化成ab这种顺序，
</code></pre><h5 id="左前缀索引"><a href="#左前缀索引" class="headerlink" title="左前缀索引"></a>左前缀索引</h5><pre><code>追加Index时，计算数据唯一性巧妙添加左前缀索引，提高索引命中率，保证索引字段唯一性
//以此算出城市拼音缩写长度为3时，命中率和唯一性比较高，则写下如下SQL：
例如 ALTER TABLE `city` ADD INDEX `index_on_pinyinInitial` USING BTREE (pinyin_initial(3));
</code></pre><h5 id="explain参数分析"><a href="#explain参数分析" class="headerlink" title="explain参数分析"></a>explain参数分析</h5><pre><code>select_type：执行类型 simple为简单查询类型
type: const 标示查询结果最多匹配一行，查询很快，从最好到最差的连接类型为
const（常量查询）、eq_reg（使用唯一索引查找(主键或唯一索引)）、ref（非唯一索引访问(只有普通索引)）
、range（一般用于&gt;= &lt;= ）、index和ALL（都全表扫描）
key： 实际使用的索引。如果为NULL，则没有使用索引
rows：MySQL认为必须检查的用来返回请求数据的行数
</code></pre><h3 id="20170715-springmvc相关"><a href="#20170715-springmvc相关" class="headerlink" title="20170715-springmvc相关"></a>20170715-springmvc相关</h3><h4 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h4><pre><code>1、如果其他类实现了BeanFactoryPostProcessor，那就先调用postProcessBeanFactory（）
BeanFactoryPostProcessor是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的
实现该接口，可以在spring的bean创建之前，修改bean的定义属性。
如果是当前类实现了BeanFactoryPostProcessor，那么会在afterPropertiesSet之后被调用
2、然后调用对象的构造方法，实例化
3、如果类实现了BeanNameAware 则调用setBeanName()
4、如果类实现了BeanPostProcessor 则调用postProcessBeforeInitialization
5、如果累实现了InitializingBean 则调用afterPropertiesSet（）
7、如果指定了init方法也会调用
6、如果类实现了BeanPostProcessor 则调用postProcessAfterInitialization（）
9、如果bean实现了ApplicationContextAware，则可以把上下文环境传过去。
9、如果累实现了DisposableBean 执行 destroy方法
</code></pre><h4 id="url请求流程"><a href="#url请求流程" class="headerlink" title="url请求流程"></a>url请求流程</h4><pre><code>1、用户发送url请求，然后请求被dispatchServlet拦截。
2、dispartchServlet解析url,根据url调用HandleMapping获取该handler配置的
相关拦截器，根据handler获取handlerAdapter调用controller里面的对应方法，
3，controller执行完后返回ModerAndView,然后视图解析器viewReslove解析后返回具体
的view
4,dispartcherServlet根据view来渲染视图，再将渲染结果返回给客户端。
</code></pre><h3 id="20170717-接口幂等性"><a href="#20170717-接口幂等性" class="headerlink" title="20170717-接口幂等性"></a>20170717-接口幂等性</h3><pre><code>接口的幂等性在于无论接口被调用多少次，返回的值都是一样的。
幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的。
</code></pre><h4 id="接口幂等场景"><a href="#接口幂等场景" class="headerlink" title="接口幂等场景"></a>接口幂等场景</h4><pre><code>重复下单，可以使用token去控制，
重复支付，根据生成的seq去调用支付，可以防止重复支付，如果是因为第三方平台没有及时返回支付成功状态，可以使用对账
重复调用推送接口，比如消息推送接口，如果别人多次调用可能导致用户收到重复的内容，为了防止运营的手误重复点击，对
推送内容增加判断，对推送内容进行md5加密 ，如果推送内容md5一样就直接返回推送成功，保证系统只处理一次推送请求。
</code></pre><h3 id="20170718-线程池大小如何设置"><a href="#20170718-线程池大小如何设置" class="headerlink" title="20170718-线程池大小如何设置"></a>20170718-线程池大小如何设置</h3><pre><code>如果是CPU密集型应用，则线程池大小设置为N+1
如果是IO密集型应用，则线程池大小设置为2N+1
</code></pre><h3 id="20170731-mysql删除"><a href="#20170731-mysql删除" class="headerlink" title="20170731-mysql删除"></a>20170731-mysql删除</h3><pre><code>delete语句删除的时候 表名称不能加别名例如：
DELETE from tb_media_settlement a where a.article_id in(
select t.id from tb_article t where t.custom_id=47 and t.media_id is null
)
只能用
DELETE from tb_media_settlement where article_id in(
  select t.id from tb_article t where t.custom_id=47 and t.media_id is null
)
</code></pre><h3 id="20170802-window删除大量文件和文件"><a href="#20170802-window删除大量文件和文件" class="headerlink" title="20170802-window删除大量文件和文件"></a>20170802-window删除大量文件和文件</h3><pre><code>删除文件和删除文件夹命令
del /f/s/q foldername &gt; nul
rmdir /s/q foldername
</code></pre><h3 id="20170829-findbugs插件提示的优化代码"><a href="#20170829-findbugs插件提示的优化代码" class="headerlink" title="20170829-findbugs插件提示的优化代码"></a>20170829-findbugs插件提示的优化代码</h3><pre><code>1、Map迭代的时候，最好用 map.entrySet的形式
Map.Entry&lt;Integer, CategoryVO&gt; entry : map.entrySet()
2、用到equals的时候需要留个心眼，如果其他组提供的XXDTO需要比较的这个字段是Integer类型
 ,而你定义临时变量类型是String类型，这时候需要把Integer类型的变量转换成String类型再比较
 if((shop.getShopId() + &quot;&quot;).equals(shopId))
</code></pre><h3 id="20170918-Comparable与Comparator"><a href="#20170918-Comparable与Comparator" class="headerlink" title="20170918-Comparable与Comparator"></a>20170918-Comparable与Comparator</h3><pre><code>平常用到一些map的排序，可能需要重写他的排序规则。
Comparable：内比较器，一些类只要实现了这个接口，就可以自己和自己比较。
Comparator：外比较器，比如某些类没有实现Comparable接口，只能使用类似这样的写法
Map&lt;Date, EduGoodHourStockDTO&gt; map = new TreeMap&lt;Date, EduGoodHourStockDTO&gt;(new Comparator&lt;Date&gt;() {
    @Override

    public int compare(Date o1, Date o2) {
        return 0;
    }
 });

 public static class TreeValue implements Comparable&lt;TreeValue&gt; {
         int score;
         public TreeValue(int score) {
             this.score = score;
         }

         public int compareTo(TreeValue o) {
             //从小到大
             if (this.score&gt;o.score  )
                 return 1;
                 //当前值小于被比较的值 返回-1 从小到大
             else if (this.score &lt;o.score )
                 return -1;
             else
                 return 0;
         }
 }
 或者
 Collections.sort(configLoaders, OrderComparator.INSTANCE);
 public class OrderComparator implements Comparator&lt;Object&gt; {
     public static final Comparator&lt;Object&gt; INSTANCE = new OrderComparator();

     public OrderComparator() {
     }

     public static Comparator&lt;Object&gt; getInstance() {
         return INSTANCE;
     }
     //lhs first object to be compared  ,rhs second
     public int compare(Object lhs, Object rhs) {
         Order lhsOrder = (Order)lhs.getClass().getAnnotation(Order.class);
         Order rhsOrder = (Order)rhs.getClass().getAnnotation(Order.class);
         if (lhsOrder == null &amp;&amp; rhsOrder == null) {
             return 0;
         } else if (rhsOrder == null) {
             return 1;
         } else {
             return lhsOrder == null ? -1 : Integer.signum(lhsOrder.value() - rhsOrder.value());
         }
     }
 }

 默认是从小到大
</code></pre><h3 id="20170924-static修饰符"><a href="#20170924-static修饰符" class="headerlink" title="20170924-static修饰符"></a>20170924-static修饰符</h3><pre><code>static修饰的对象或者变量都是全局共享的，一个类中，一个static变量只会有一个内存空间，虽然有多个类实例，
但这些类实例中的这个static变量会共享同一个内存空间。
static的变量是在类装载的时候就会被初始化，即，只要类被装载，不管是否使用了static变量，都会被初始化
</code></pre><h3 id="20170925-Exception与RuntimeException"><a href="#20170925-Exception与RuntimeException" class="headerlink" title="20170925-Exception与RuntimeException"></a>20170925-Exception与RuntimeException</h3><pre><code>自定义异常继承了Exception就必须要强制检查
自定义异常继承了RuntimeException 不需要强制检查
</code></pre><h3 id="20170928-公司同事guva分享记录"><a href="#20170928-公司同事guva分享记录" class="headerlink" title="20170928-公司同事guva分享记录"></a>20170928-公司同事guva分享记录</h3><pre><code>字符串截取： &quot;,a,,b,c&quot; 按照逗号截取
</code></pre><h3 id="20171012-包装类比较"><a href="#20171012-包装类比较" class="headerlink" title="20171012-包装类比较"></a>20171012-包装类比较</h3><pre><code>Integer包装类比较的时候最好用equals去比较，因为equals会将Integer转换成int类型去比较 
</code></pre><h3 id="20171018-String-replace注意"><a href="#20171018-String-replace注意" class="headerlink" title="20171018-String.replace注意"></a>20171018-String.replace注意</h3><pre><code>String 自带有好几种替换方式，
例如 replace(),replaceFirst(),replaceAll()
如果我们使用replace() 参数就是CharSequence
如果使用replaceFirst(),replaceAll() 被比较的参数就是regex正则后的字符串.
比如&quot;$&quot;这个字符属于特殊字符 那么可以使用 replace(&quot;$&quot;) 和replaceFirst(&quot;\\$&quot;)
</code></pre><h3 id="20171024-map-putIfAbsent-key-value"><a href="#20171024-map-putIfAbsent-key-value" class="headerlink" title="20171024-map.putIfAbsent(key,value)"></a>20171024-map.putIfAbsent(key,value)</h3><pre><code>map 其实有一个方法叫map.putIfAbsent(key,value)，
如果已经存在了，就不会再添加了，返回旧的value
如果不存在，就返回空的value类型（null或者&quot;&quot;）
map.put(key,value) 返回的是oldValue;
</code></pre><h3 id="20171106-URLEncoder-encode（）与decode"><a href="#20171106-URLEncoder-encode（）与decode" class="headerlink" title="20171106- URLEncoder.encode（）与decode()"></a>20171106- URLEncoder.encode（）与decode()</h3><pre><code>url encode与decode 有两大功能
1、解决中文在get提交的时候乱码问题，只要encode和decode的字符集一样，肯定不会出现乱码情况，而且某些特殊
字符也不允许出现在url里面
2、解决url里面带url的情况
比如： http://www.baidu.com?param1=aa&amp;redirectUrl=http://www.dianping.com?p1=bb&amp;&amp;p2=cc&amp;&amp;param2=dd
我们想要的是：redirectUrl=http://www.dianping.com?p1=bb&amp;&amp;p2=cc
但是如果不encode最终传输的url解析到的就是redirectUrl=http://www.dianping.com?p1=bb
p2=cc这个参数就会被丢失。
</code></pre><h3 id="20171122-utf-8与gbk"><a href="#20171122-utf-8与gbk" class="headerlink" title="20171122- utf-8与gbk"></a>20171122- utf-8与gbk</h3><pre><code>一个中文在uft-8下面占用三个字节，在gbk下面占用2个字节      
</code></pre>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/笔记/" rel="tag"># 笔记</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/21/工作中遇到的坑-长期记录/" rel="next" title="工作中遇到的坑-长期记录">
                <i class="fa fa-chevron-left"></i> 工作中遇到的坑-长期记录
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/04/JavaPNS-2-2内存溢出定位和解决/" rel="prev" title="JavaPNS_2.2内存泄露定位和解决">
                JavaPNS_2.2内存泄露定位和解决 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ocg3iebmc.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160922230125.jpg"
               alt="ggj2010" />
          <p class="site-author-name" itemprop="name">ggj2010</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ggj2010" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/ggjlvzjy" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#20170222"><span class="nav-number">1.</span> <span class="nav-text">20170222</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170223"><span class="nav-number">2.</span> <span class="nav-text">20170223</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170224"><span class="nav-number">3.</span> <span class="nav-text">20170224</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170227"><span class="nav-number">4.</span> <span class="nav-text">20170227</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170228"><span class="nav-number">5.</span> <span class="nav-text">20170228</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170301"><span class="nav-number">6.</span> <span class="nav-text">20170301</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170302"><span class="nav-number">7.</span> <span class="nav-text">20170302</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170306"><span class="nav-number">8.</span> <span class="nav-text">20170306</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170308"><span class="nav-number">9.</span> <span class="nav-text">20170308</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170309"><span class="nav-number">10.</span> <span class="nav-text">20170309</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170310"><span class="nav-number">11.</span> <span class="nav-text">20170310</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170313"><span class="nav-number">12.</span> <span class="nav-text">20170313</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170314"><span class="nav-number">13.</span> <span class="nav-text">20170314</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170317"><span class="nav-number">14.</span> <span class="nav-text">20170317</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170323"><span class="nav-number">15.</span> <span class="nav-text">20170323</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170327"><span class="nav-number">16.</span> <span class="nav-text">20170327</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170330"><span class="nav-number">17.</span> <span class="nav-text">20170330</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170412"><span class="nav-number">18.</span> <span class="nav-text">20170412</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170418"><span class="nav-number">19.</span> <span class="nav-text">20170418</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170425"><span class="nav-number">20.</span> <span class="nav-text">20170425</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170510-hs-err-pid-log"><span class="nav-number">21.</span> <span class="nav-text">20170510-hs_err_pid.log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170512-高可用消息推送平台"><span class="nav-number">22.</span> <span class="nav-text">20170512-高可用消息推送平台</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170605-mybatis动态参数"><span class="nav-number">23.</span> <span class="nav-text">20170605-mybatis动态参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170614-表添加索引"><span class="nav-number">24.</span> <span class="nav-text">20170614-表添加索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170615-equal和hashcode"><span class="nav-number">25.</span> <span class="nav-text">20170615-equal和hashcode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170615-replace空指针"><span class="nav-number">26.</span> <span class="nav-text">20170615-replace空指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170619-为什么HashMap里面的数组size必须是2的次幂？"><span class="nav-number">27.</span> <span class="nav-text">20170619-为什么HashMap里面的数组size必须是2的次幂？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170620-http协议复习"><span class="nav-number">28.</span> <span class="nav-text">20170620-http协议复习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170621-深入java虚拟机复习"><span class="nav-number">29.</span> <span class="nav-text">20170621-深入java虚拟机复习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java虚拟机运行时数据区域"><span class="nav-number">29.1.</span> <span class="nav-text">java虚拟机运行时数据区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java垃圾回收知识点"><span class="nav-number">29.2.</span> <span class="nav-text">java垃圾回收知识点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟机类加载机制"><span class="nav-number">29.3.</span> <span class="nav-text">虚拟机类加载机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#早期编译器优化"><span class="nav-number">29.4.</span> <span class="nav-text">早期编译器优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java内存模型"><span class="nav-number">29.5.</span> <span class="nav-text">java内存模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发编程三个概念"><span class="nav-number">29.6.</span> <span class="nav-text">并发编程三个概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#happens-before原则（先行发生原则"><span class="nav-number">29.7.</span> <span class="nav-text">happens-before原则（先行发生原则)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170622-transient关键字"><span class="nav-number">30.</span> <span class="nav-text">20170622-transient关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170622-数据库复习"><span class="nav-number">31.</span> <span class="nav-text">20170622-数据库复习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#事物隔离级别"><span class="nav-number">31.1.</span> <span class="nav-text">事物隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁情况"><span class="nav-number">31.2.</span> <span class="nav-text">死锁情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring事物传播特性"><span class="nav-number">31.3.</span> <span class="nav-text">spring事物传播特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170622-动态代理"><span class="nav-number">32.</span> <span class="nav-text">20170622-动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk动态代理"><span class="nav-number">32.1.</span> <span class="nav-text">jdk动态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cglib"><span class="nav-number">32.2.</span> <span class="nav-text">cglib</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JAVAASSIST字节码"><span class="nav-number">32.3.</span> <span class="nav-text">JAVAASSIST字节码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170703-for-each原理和java迭代注意"><span class="nav-number">33.</span> <span class="nav-text">20170703-for each原理和java迭代注意</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">33.1.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意"><span class="nav-number">33.2.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for-each对象"><span class="nav-number">33.3.</span> <span class="nav-text">for each对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170704-linux线程gc查询"><span class="nav-number">34.</span> <span class="nav-text">20170704-linux线程gc查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170705-java对象的强、软、弱、虚引用"><span class="nav-number">35.</span> <span class="nav-text">20170705-java对象的强、软、弱、虚引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal原理与内存泄露"><span class="nav-number">35.1.</span> <span class="nav-text">ThreadLocal原理与内存泄露</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170706-设计模式回顾"><span class="nav-number">36.</span> <span class="nav-text">20170706-设计模式回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单例模式"><span class="nav-number">36.1.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工厂模式"><span class="nav-number">36.2.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装饰模式"><span class="nav-number">36.3.</span> <span class="nav-text">装饰模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代理模式"><span class="nav-number">36.4.</span> <span class="nav-text">代理模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命令模式"><span class="nav-number">36.5.</span> <span class="nav-text">命令模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#策略模式"><span class="nav-number">36.6.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代模式"><span class="nav-number">36.7.</span> <span class="nav-text">迭代模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#观察者模式"><span class="nav-number">36.8.</span> <span class="nav-text">观察者模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#适配器模式"><span class="nav-number">36.9.</span> <span class="nav-text">适配器模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170707-通过Java字节码去看原理"><span class="nav-number">37.</span> <span class="nav-text">20170707-通过Java字节码去看原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#i-与-i的原理"><span class="nav-number">37.1.</span> <span class="nav-text">i++与++i的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for-each的处理"><span class="nav-number">37.2.</span> <span class="nav-text">for each的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装箱与拆箱"><span class="nav-number">37.3.</span> <span class="nav-text">装箱与拆箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型"><span class="nav-number">37.4.</span> <span class="nav-text">泛型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170711-linux常用命令复习"><span class="nav-number">38.</span> <span class="nav-text">20170711-linux常用命令复习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件权限"><span class="nav-number">38.1.</span> <span class="nav-text">文件权限</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170712-QPS"><span class="nav-number">39.</span> <span class="nav-text">20170712-QPS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170713-TCP-IP相关"><span class="nav-number">40.</span> <span class="nav-text">20170713-TCP/IP相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS"><span class="nav-number">40.1.</span> <span class="nav-text">HTTPS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http状态码"><span class="nav-number">40.2.</span> <span class="nav-text">http状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSI七层模型"><span class="nav-number">40.3.</span> <span class="nav-text">OSI七层模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-IP四层模型"><span class="nav-number">40.4.</span> <span class="nav-text">TCP/IP四层模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP数据段格式"><span class="nav-number">40.5.</span> <span class="nav-text">TCP数据段格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三次握手"><span class="nav-number">40.6.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四次挥手"><span class="nav-number">40.7.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#syn攻击"><span class="nav-number">40.8.</span> <span class="nav-text">syn攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#与http相关协议"><span class="nav-number">40.9.</span> <span class="nav-text">与http相关协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#time-wait与close-wait"><span class="nav-number">40.10.</span> <span class="nav-text">time_wait与close_wait</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#time-wait"><span class="nav-number">40.10.1.</span> <span class="nav-text">time_wait</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#close-wait"><span class="nav-number">40.10.2.</span> <span class="nav-text">close_wait</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何提高单机短连接QPS"><span class="nav-number">40.11.</span> <span class="nav-text">如何提高单机短连接QPS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#etc-sysctl-conf"><span class="nav-number">40.12.</span> <span class="nav-text">/etc/sysctl.conf</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170714-mysql相关"><span class="nav-number">41.</span> <span class="nav-text">20170714-mysql相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优化"><span class="nav-number">41.1.</span> <span class="nav-text">优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引失效"><span class="nav-number">41.2.</span> <span class="nav-text">索引失效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10条SQL技巧"><span class="nav-number">41.3.</span> <span class="nav-text">10条SQL技巧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引"><span class="nav-number">41.4.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#聚簇索引"><span class="nav-number">41.4.1.</span> <span class="nav-text">聚簇索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#非聚簇索引"><span class="nav-number">41.4.2.</span> <span class="nav-text">非聚簇索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#联合索引"><span class="nav-number">41.4.3.</span> <span class="nav-text">联合索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#左前缀索引"><span class="nav-number">41.4.4.</span> <span class="nav-text">左前缀索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#explain参数分析"><span class="nav-number">41.4.5.</span> <span class="nav-text">explain参数分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170715-springmvc相关"><span class="nav-number">42.</span> <span class="nav-text">20170715-springmvc相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bean的生命周期"><span class="nav-number">42.1.</span> <span class="nav-text">bean的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#url请求流程"><span class="nav-number">42.2.</span> <span class="nav-text">url请求流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170717-接口幂等性"><span class="nav-number">43.</span> <span class="nav-text">20170717-接口幂等性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口幂等场景"><span class="nav-number">43.1.</span> <span class="nav-text">接口幂等场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170718-线程池大小如何设置"><span class="nav-number">44.</span> <span class="nav-text">20170718-线程池大小如何设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170731-mysql删除"><span class="nav-number">45.</span> <span class="nav-text">20170731-mysql删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170802-window删除大量文件和文件"><span class="nav-number">46.</span> <span class="nav-text">20170802-window删除大量文件和文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170829-findbugs插件提示的优化代码"><span class="nav-number">47.</span> <span class="nav-text">20170829-findbugs插件提示的优化代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170918-Comparable与Comparator"><span class="nav-number">48.</span> <span class="nav-text">20170918-Comparable与Comparator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170924-static修饰符"><span class="nav-number">49.</span> <span class="nav-text">20170924-static修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170925-Exception与RuntimeException"><span class="nav-number">50.</span> <span class="nav-text">20170925-Exception与RuntimeException</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170928-公司同事guva分享记录"><span class="nav-number">51.</span> <span class="nav-text">20170928-公司同事guva分享记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20171012-包装类比较"><span class="nav-number">52.</span> <span class="nav-text">20171012-包装类比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20171018-String-replace注意"><span class="nav-number">53.</span> <span class="nav-text">20171018-String.replace注意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20171024-map-putIfAbsent-key-value"><span class="nav-number">54.</span> <span class="nav-text">20171024-map.putIfAbsent(key,value)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20171106-URLEncoder-encode（）与decode"><span class="nav-number">55.</span> <span class="nav-text">20171106- URLEncoder.encode（）与decode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20171122-utf-8与gbk"><span class="nav-number">56.</span> <span class="nav-text">20171122- utf-8与gbk</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ggj2010</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
