<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="ç¾å›¢ç‚¹è¯„," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="é‚£äº›ä½ ä»¥ä¸ºå¾ˆé«˜å¤§å°šçš„ç»„ä»¶å…¶å®ä¹Ÿéƒ½æ˜¯ä»æ— åˆ°æœ‰è¿­ä»£å‡ºæ¥äº†ï¼Œå°±ç®—æ²¡æœ‰é€ è½®å­çš„æ—¶é—´ï¼Œä¹Ÿè¦æœ‰é€ è½®å­çš„ğŸ’•ã€‚ çŸ­é“¾æ¥æœåŠ¡çŸ­é“¾æ¥æœåŠ¡ä¸»è¦æ˜¯åŠ å¯†å’Œç¼©çŸ­åŸæ¥é“¾æ¥ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥ç»Ÿè®¡çŸ­é“¾æ¥è®¿é—®çš„ä¸€äº›æƒ…å†µã€‚ ç”Ÿæˆæ€è·¯ï¼š 1ã€å°†åŸé“¾æ¥å­˜å…¥è¡¨ï¼Œè·å¾—longç±»å‹çš„idï¼Œ ä¼˜åŒ–ç‚¹:å¦‚æœmysqlä¸å¯ç”¨æ—¶å€™ï¼Œå¯ç›´æ¥åœ¨redisè·å–è‡ªå¢çš„id, ç„¶åè°ƒç”¨æ–¹æ³•è·å–åˆ°çŸ­é“¾å”¯ä¸€å­—ç¬¦ä¸²ï¼Œ é˜²æ­¢ä¸¤ç§æ–¹å¼ç”Ÿäº§çš„çŸ­é“¾å†²çªï¼Œåœ¨redisç”Ÿäº§çš„çŸ­é“¾å­—ç¬¦">
<meta name="keywords" content="ç¾å›¢ç‚¹è¯„">
<meta property="og:type" content="article">
<meta property="og:title" content="å…¬å¸å¸¸ç”¨ç»„ä»¶è®°å½•">
<meta property="og:url" content="http://ggj2010.github.io/2018/05/21/å…¬å¸å¸¸ç”¨ç»„ä»¶è®°å½•/index.html">
<meta property="og:site_name" content="é«˜å¹¿é‡‘åšå®¢">
<meta property="og:description" content="é‚£äº›ä½ ä»¥ä¸ºå¾ˆé«˜å¤§å°šçš„ç»„ä»¶å…¶å®ä¹Ÿéƒ½æ˜¯ä»æ— åˆ°æœ‰è¿­ä»£å‡ºæ¥äº†ï¼Œå°±ç®—æ²¡æœ‰é€ è½®å­çš„æ—¶é—´ï¼Œä¹Ÿè¦æœ‰é€ è½®å­çš„ğŸ’•ã€‚ çŸ­é“¾æ¥æœåŠ¡çŸ­é“¾æ¥æœåŠ¡ä¸»è¦æ˜¯åŠ å¯†å’Œç¼©çŸ­åŸæ¥é“¾æ¥ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥ç»Ÿè®¡çŸ­é“¾æ¥è®¿é—®çš„ä¸€äº›æƒ…å†µã€‚ ç”Ÿæˆæ€è·¯ï¼š 1ã€å°†åŸé“¾æ¥å­˜å…¥è¡¨ï¼Œè·å¾—longç±»å‹çš„idï¼Œ ä¼˜åŒ–ç‚¹:å¦‚æœmysqlä¸å¯ç”¨æ—¶å€™ï¼Œå¯ç›´æ¥åœ¨redisè·å–è‡ªå¢çš„id, ç„¶åè°ƒç”¨æ–¹æ³•è·å–åˆ°çŸ­é“¾å”¯ä¸€å­—ç¬¦ä¸²ï¼Œ é˜²æ­¢ä¸¤ç§æ–¹å¼ç”Ÿäº§çš„çŸ­é“¾å†²çªï¼Œåœ¨redisç”Ÿäº§çš„çŸ­é“¾å­—ç¬¦">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p0.meituan.net/education/f0cf8b3ae77b6b862caba4abb7c4a14a151878.png">
<meta property="og:updated_time" content="2021-01-27T10:34:17.472Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="å…¬å¸å¸¸ç”¨ç»„ä»¶è®°å½•">
<meta name="twitter:description" content="é‚£äº›ä½ ä»¥ä¸ºå¾ˆé«˜å¤§å°šçš„ç»„ä»¶å…¶å®ä¹Ÿéƒ½æ˜¯ä»æ— åˆ°æœ‰è¿­ä»£å‡ºæ¥äº†ï¼Œå°±ç®—æ²¡æœ‰é€ è½®å­çš„æ—¶é—´ï¼Œä¹Ÿè¦æœ‰é€ è½®å­çš„ğŸ’•ã€‚ çŸ­é“¾æ¥æœåŠ¡çŸ­é“¾æ¥æœåŠ¡ä¸»è¦æ˜¯åŠ å¯†å’Œç¼©çŸ­åŸæ¥é“¾æ¥ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥ç»Ÿè®¡çŸ­é“¾æ¥è®¿é—®çš„ä¸€äº›æƒ…å†µã€‚ ç”Ÿæˆæ€è·¯ï¼š 1ã€å°†åŸé“¾æ¥å­˜å…¥è¡¨ï¼Œè·å¾—longç±»å‹çš„idï¼Œ ä¼˜åŒ–ç‚¹:å¦‚æœmysqlä¸å¯ç”¨æ—¶å€™ï¼Œå¯ç›´æ¥åœ¨redisè·å–è‡ªå¢çš„id, ç„¶åè°ƒç”¨æ–¹æ³•è·å–åˆ°çŸ­é“¾å”¯ä¸€å­—ç¬¦ä¸²ï¼Œ é˜²æ­¢ä¸¤ç§æ–¹å¼ç”Ÿäº§çš„çŸ­é“¾å†²çªï¼Œåœ¨redisç”Ÿäº§çš„çŸ­é“¾å­—ç¬¦">
<meta name="twitter:image" content="http://p0.meituan.net/education/f0cf8b3ae77b6b862caba4abb7c4a14a151878.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'åšä¸»'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ggj2010.github.io/2018/05/21/å…¬å¸å¸¸ç”¨ç»„ä»¶è®°å½•/"/>





  <title> å…¬å¸å¸¸ç”¨ç»„ä»¶è®°å½• | é«˜å¹¿é‡‘åšå®¢ </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">é«˜å¹¿é‡‘åšå®¢</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            é¦–é¡µ
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            åˆ†ç±»
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            å…³äº
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            å½’æ¡£
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            æ ‡ç­¾
          </a>
        </li>
      
        
        <li class="menu-item menu-item-webmagic">
          <a href="http://scedai.com/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            çˆ¬è™«
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ggj2010.github.io/2018/05/21/å…¬å¸å¸¸ç”¨ç»„ä»¶è®°å½•/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ggj2010">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatar.csdnimg.cn/1/E/3/ggj20ss.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="é«˜å¹¿é‡‘åšå®¢">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                å…¬å¸å¸¸ç”¨ç»„ä»¶è®°å½•
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">å‘è¡¨äº</span>
              
              <time title="åˆ›å»ºäº" itemprop="dateCreated datePublished" datetime="2018-05-21T11:15:10+08:00">
                2018-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <pre><code>é‚£äº›ä½ ä»¥ä¸ºå¾ˆé«˜å¤§å°šçš„ç»„ä»¶å…¶å®ä¹Ÿéƒ½æ˜¯ä»æ— åˆ°æœ‰è¿­ä»£å‡ºæ¥äº†ï¼Œå°±ç®—æ²¡æœ‰é€ è½®å­çš„æ—¶é—´ï¼Œä¹Ÿè¦æœ‰é€ è½®å­çš„ğŸ’•ã€‚
</code></pre><h1 id="çŸ­é“¾æ¥æœåŠ¡"><a href="#çŸ­é“¾æ¥æœåŠ¡" class="headerlink" title="çŸ­é“¾æ¥æœåŠ¡"></a>çŸ­é“¾æ¥æœåŠ¡</h1><pre><code>çŸ­é“¾æ¥æœåŠ¡ä¸»è¦æ˜¯åŠ å¯†å’Œç¼©çŸ­åŸæ¥é“¾æ¥ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥ç»Ÿè®¡çŸ­é“¾æ¥è®¿é—®çš„ä¸€äº›æƒ…å†µã€‚
ç”Ÿæˆæ€è·¯ï¼š
1ã€å°†åŸé“¾æ¥å­˜å…¥è¡¨ï¼Œè·å¾—longç±»å‹çš„idï¼Œ
ä¼˜åŒ–ç‚¹:å¦‚æœmysqlä¸å¯ç”¨æ—¶å€™ï¼Œå¯ç›´æ¥åœ¨redisè·å–è‡ªå¢çš„id, ç„¶åè°ƒç”¨æ–¹æ³•è·å–åˆ°çŸ­é“¾å”¯ä¸€å­—ç¬¦ä¸²ï¼Œ
é˜²æ­¢ä¸¤ç§æ–¹å¼ç”Ÿäº§çš„çŸ­é“¾å†²çªï¼Œåœ¨redisç”Ÿäº§çš„çŸ­é“¾å­—ç¬¦ä¸²åŠ ä¸Šä¸€ä¸ªä¿ç•™å­—ç¬¦ä¸²ï¼ˆZï¼‰,è¿™ä¸ªå­—ç¬¦ä¸²
æ˜¯è°ƒç”¨Long.toStringæˆ–è€…parseRadixéƒ½ä¼šå¸¦æœ‰çš„ï¼Œç­‰åˆ°mysqlæ­£å¸¸æ—¶å€™ï¼Œå†å°†ç¼“å­˜çš„æ•°æ®å›å†™
åˆ°mysqlé‡Œé¢ä¿è¯è½åœ°æ•°æ®ä¸€è‡´ã€‚

2ã€æ‰ç”¨æ–¹æ³•Long.toString(shortLinkId, 36)è·å¾—çŸ­é“¾å”¯ä¸€æ€§å­—ç¬¦ä¸²
ä¼˜åŒ–ç‚¹ï¼Œå¦‚æœæ˜¯36è¿›åˆ¶ï¼Œ7ä½ç½®é•¿åº¦çš„è¯ 36^6=78äº¿å·¦å³æ•°æ®ï¼Œæœ€å¤šå¯ä»¥å­˜è¿™ä¹ˆå¤šæ¡æ•°æ®ï¼Œå¯ä»¥è¯•ç”¨ä¸€ä¸‹çš„61è¿›åˆ¶
private final static char[] digits = {&apos;0&apos;,&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;,
                     &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;,
                     &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;,
                     &apos;z&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;,
                     &apos;M&apos;, &apos;N&apos;, &apos;O&apos;, &apos;P&apos;, &apos;Q&apos;, &apos;R&apos;, &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;};
    //æ±‚ä½™æ•°æ±‚å•† 10è¿›åˆ¶è½¬61è¿›åˆ¶
    public static String parseRadix(long origin){
            char[] buf = new char[61];
            int charPos = 60;
            while (origin &gt;= 61) {
                buf[charPos--] = digits[(int)((origin % 61))];
                origin = origin / 61;
            }
            buf[charPos] = digits[(int)(origin)];
            return new String(buf, charPos, (61 - charPos));
    }
3ã€æ ¹æ®shortLinkIdæ›´æ–°åŸæ¥è¡¨ï¼Œå°†çŸ­é“¾å­—ç¬¦ä¸²å›å†™è¡¨
4ã€å°†çŸ­é“¾å­—ç¬¦ä¸²å’ŒåŸé“¾æ¥çš„å¯¹åº”å…³ç³»å†™å…¥ç¼“å­˜ç³»ç»Ÿï¼Œredisæˆ–è€…tail
æŸ¥è¯¢æ€è·¯ï¼š
1ã€æ ¹æ®çŸ­é“¾å­—ç¬¦ä¸²å…ˆæŸ¥è¯¢ç¼“å­˜ï¼Œæ²¡æœ‰å‘½ä¸­ç¼“å­˜å†æŸ¥è¯¢è¡¨ï¼Œç„¶åå†å¡å…¥ç¼“å­˜ã€‚
</code></pre><h1 id="ç»Ÿä¸€ç”µè¯åŠ å¯†æœåŠ¡"><a href="#ç»Ÿä¸€ç”µè¯åŠ å¯†æœåŠ¡" class="headerlink" title="ç»Ÿä¸€ç”µè¯åŠ å¯†æœåŠ¡"></a>ç»Ÿä¸€ç”µè¯åŠ å¯†æœåŠ¡</h1><h2 id="èƒŒæ™¯"><a href="#èƒŒæ™¯" class="headerlink" title="èƒŒæ™¯"></a>èƒŒæ™¯</h2><pre><code>å¯¹ç³»ç»Ÿå­˜å‚¨çš„ç­‰æ•æ„Ÿä¿¡æ¯è¿›è¡Œè„±æ•ï¼Œé˜²æ­¢ä»æŠ€æœ¯äººå‘˜å†…éƒ¨é€ æˆçš„æ•æ„Ÿä¿¡æ¯æ³„æ¼é—®é¢˜
</code></pre><h2 id="ç³»ç»Ÿç›®æ ‡"><a href="#ç³»ç»Ÿç›®æ ‡" class="headerlink" title="ç³»ç»Ÿç›®æ ‡"></a>ç³»ç»Ÿç›®æ ‡</h2><pre><code>ç›®æ ‡ï¼š
æ‰‹æœºå·æ”¯æ’‘èƒ½åŠ›ï¼š3äº¿ -&gt; 15äº¿ -&gt; 30äº¿
æŒ‰ä¸šåŠ¡åˆ’åˆ†ï¼Œå„ä¸šåŠ¡äº’ç›¸ä¸å½±å“ï¼ˆæ³³é“ï¼‰
SLAæ ‡å‡†ï¼š
å¯ç”¨æ€§ï¼š99.999%
TP95ï¼š1.3msã€TP99ï¼š2ms
ä¸šåŠ¡QPSï¼š6w
</code></pre><h2 id="æ ¸å¿ƒæµç¨‹"><a href="#æ ¸å¿ƒæµç¨‹" class="headerlink" title="æ ¸å¿ƒæµç¨‹"></a>æ ¸å¿ƒæµç¨‹</h2><h1 id="çŸ­ä¿¡æœåŠ¡"><a href="#çŸ­ä¿¡æœåŠ¡" class="headerlink" title="çŸ­ä¿¡æœåŠ¡"></a>çŸ­ä¿¡æœåŠ¡</h1><h2 id="ç›¸å…³æ¦‚å¿µ"><a href="#ç›¸å…³æ¦‚å¿µ" class="headerlink" title="ç›¸å…³æ¦‚å¿µ"></a>ç›¸å…³æ¦‚å¿µ</h2><pre><code>çŸ­ä¿¡ä¸€èˆ¬éƒ½ä¼šæœ‰æ¨¡æ¿çš„æ¦‚å¿µï¼Œæ¨¡æ¿å¯ä»¥æœ‰ç”³è¯·ã€ä¿®æ”¹ã€å®¡æ ¸ç›¸å…³æµç¨‹ï¼Œæ¨¡æ¿æ§åˆ¶äº†çŸ­ä¿¡æ•´ä½“æ ¼å¼ï¼Œæ–¹ä¾¿åæœŸç»Ÿè®¡å’Œç»´æŠ¤ã€‚
æ¨¡æ¿éƒ½ä¼šæœ‰æƒé‡çš„æ¦‚å¿µï¼Œå› ä¸ºçŸ­ä¿¡ä¸æ˜¯24å°æ—¶å‘é€çš„ï¼Œå¦‚æœå¤§åŠå¤œç»™ç”¨æˆ·å‘çŸ­ä¿¡å°±æ˜¯SBäº†ï¼Œæ‰€ä»¥éœ€è¦è®¾è®¡æƒé‡ã€‚
çŸ­ä¿¡å†…å®¹å­—æ•°é™åˆ¶ä¸º64å­—ï¼Œè¶…è¿‡64å­—ä¼šè‡ªåŠ¨åˆ†æˆå¤šæ¡å‘é€ã€‚
çŸ­ä¿¡åˆåˆ†ä¸ºåŠŸèƒ½çŸ­ä¿¡å’Œè¥é”€çŸ­ä¿¡ï¼š
è¥é”€çŸ­ä¿¡éœ€è¦æ”¯æŒ&quot;é€€è®¢å›å¤TD&quot;ï¼ŒåŒæ—¶è¥é”€çŸ­ä¿¡å‘é€é¢‘æ¬¡é™åˆ¶ï¼šå•ä¸ªæ‰‹æœºæ¯å¤©è‡³å¤šæ¥æ”¶ä¸€å¤©è¥é”€çŸ­ä¿¡
</code></pre><h2 id="æ’å…¥çŸ­ä¿¡"><a href="#æ’å…¥çŸ­ä¿¡" class="headerlink" title="æ’å…¥çŸ­ä¿¡"></a>æ’å…¥çŸ­ä¿¡</h2><pre><code>å½“ä¸šåŠ¡æ–¹æ–°å¢ä¸€æ¡çŸ­ä¿¡è®°å½•æ—¶å€™ï¼ŒæœåŠ¡ç«¯éœ€è¦ä¸€ç³»åˆ—æ£€éªŒã€‚
1ã€æ¨¡æ¿æ˜¯å¦å¯ç”¨
2ã€çŸ­ä¿¡é‡Œé¢çš„é“¾æ¥æ˜¯å¦æ˜¯çŸ­é“¾æ¥
3ã€çŸ­ä¿¡å†…å®¹ç»è¿‡è¯šä¿¡æœåŠ¡æ˜¯å¦æœ‰æ•æ„Ÿè¯è¯­
4ã€æ‰‹æœºå·ç æ˜¯å¦æ˜¯é»‘åå•
5ã€å¦‚æœæ˜¯è¥é”€çŸ­ä¿¡æ£€éªŒå‘é€æ¬¡æ•°
6ã€ç”Ÿæˆåˆ†å¸ƒå¼unionIdï¼ˆå¯ä»¥æ ¹æ®SnowFlakeç®—æ³•ï¼‰

ç»å†è¿‡ä»¥ä¸Š6æ­¥éª¤ï¼ŒçŸ­ä¿¡çš„å¯¹è±¡ç®—æ˜¯æ„é€ å®Œæˆäº†ï¼Œä½†æ˜¯çŸ­ä¿¡æ¨¡æ¿æœ‰ä¼˜å…ˆçº§ï¼Œä¼˜å…ˆçº§é«˜çš„è‚¯å®šæ˜¯è¦ç«‹å³å‘é€çš„ï¼Œæ¯”å¦‚ç™»å½•
è·å–éªŒè¯ç è¿™ç§ï¼Œé‚£ä¹ˆè¿™ç§çš„ä¸€èˆ¬æ˜¯å…ˆå°†çŸ­ä¿¡æ”¾åˆ°é˜Ÿåˆ—ï¼Œç„¶åå†å¤šçº¿ç¨‹æ¶ˆè´¹é˜Ÿåˆ—å»ï¼Œå†è°ƒç”¨çŸ­ä¿¡æä¾›æ–¹æ¥å£ï¼Œæ¥ç€å†å°†è®°å½•æ’å…¥
æ•°æ®åº“æ•°æ®ã€‚å¦‚æœåƒè®¢å•è´­ä¹°æˆåŠŸè¿™ç§ä¼˜å…ˆçº§æ¯”è¾ƒä½çš„ï¼Œå¯ä»¥å…ˆå°†æ•°æ®æ”¾åˆ°dbé‡Œé¢ï¼Œæˆ–è€…å…ˆæ”¾åˆ°kafkaé‡Œé¢ï¼Œç„¶åæ¶ˆè´¹kafkaå†æ”¾åˆ°dbé‡Œé¢
ï¼Œç„¶åå†å¯ç”¨å¤šä¸ªçº¿ç¨‹ï¼Œå»å‘é€è¿™äº›çŸ­ä¿¡ã€‚
</code></pre><p>   <img src="http://p0.meituan.net/education/f0cf8b3ae77b6b862caba4abb7c4a14a151878.png" alt=""></p>
<pre><code>å¯¹äºæ”¾å…¥dbæˆ–è€…æ”¾å…¥kafkaï¼Œå¯ä»¥æ ¹æ®æƒé‡ï¼Œæ¯”å¦‚è®¾è®¡ä¸€ä¸ªéšæœºæ•°ï¼Œè€ƒè™‘åˆ°å¯ç”¨æ€§ï¼Œæ¯”å¦‚æ”¾å…¥dbæ—¶å€™ï¼Œå¦‚æœè¿™æ—¶å€™dbä¸å¯ç”¨ï¼Œå°±ä¼˜å…ˆæ”¾å…¥kafkaã€‚
å‘æ¶ˆæ¯çš„æ—¶å€™ï¼Œéœ€è¦è€ƒè™‘é‡å¤å‘é€çš„é—®é¢˜ï¼Œæ¯”å¦‚ç›¸åŒçš„æ‰‹æœºå·+å†…å®¹ï¼Œå¦‚æœ30ç§’å†…é‡å¤å‘é€å°±ä¸¢å¼ƒå‘é€è¯·æ±‚
</code></pre><h2 id="æ ¸å¿ƒç‚¹"><a href="#æ ¸å¿ƒç‚¹" class="headerlink" title="æ ¸å¿ƒç‚¹"></a>æ ¸å¿ƒç‚¹</h2><pre><code>æ ¸å¿ƒåŠŸèƒ½å°±æ˜¯ï¼Œé˜Ÿåˆ—+çº¿ç¨‹
ç¼“å­˜é˜Ÿåˆ—éƒ½æ˜¯æœ‰å¤§å°çš„ï¼Œå¦‚æœé˜Ÿåˆ—æ»¡äº†éœ€è¦æ€ä¹ˆåŠï¼Œå¦‚æœç³»ç»Ÿé‡å¯é˜Ÿåˆ—é‡Œé¢è¿˜æœ‰å†…å®¹æ€ä¹ˆåŠã€‚
å¦‚æœå¤šçº¿ç¨‹æŸ¥è¯¢dbé‡Œé¢å¾…å‘é€çš„çŸ­ä¿¡ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰å¯èƒ½æŸ¥åˆ°é‡å¤çš„å†…å®¹ï¼Œå¯¹äºé‡å¤çš„éœ€è¦æ€ä¹ˆå¤„ç†ï¼Œè¿™äº›éƒ½æ˜¯éœ€è¦å¾…è€ƒè™‘çš„é—®é¢˜ã€‚
</code></pre><h1 id="craneå®šæ—¶ä»»åŠ¡"><a href="#craneå®šæ—¶ä»»åŠ¡" class="headerlink" title="craneå®šæ—¶ä»»åŠ¡"></a>craneå®šæ—¶ä»»åŠ¡</h1><pre><code>å®šæ—¶ä»»åŠ¡ä¸€èˆ¬åˆ†ä¸¤ç§ï¼Œä¸€ç§æ˜¯å»ä¸­å¿ƒåŒ–ï¼Œä¸€ç§æ˜¯ä¸­å¿ƒåŒ–ã€‚
å»ä¸­å¿ƒåŒ–çš„è¯ï¼Œæ¯ä¸ªå®¢æˆ·ç«¯æœ‰èƒ½åŠ›æ‰§è¡Œä»»åŠ¡ï¼Œå¤šä¸ªå®¢æˆ·ç«¯åªæœ‰masteræ‰æœ‰æ‰§è¡Œjobçš„æƒåŠ›ï¼Œå¯ä»¥é€šè¿‡ZKçš„é€‰ä¸¾
åŠŸèƒ½å®ç°LeaderåŠŸèƒ½
ä¸­å¿ƒåŒ–çš„è¯å°±æ˜¯ï¼ŒæœåŠ¡ç«¯ä¼šè®°å½•ä¸‹ä»»åŠ¡æƒ…å†µï¼Œç­‰åˆ°ä»»åŠ¡è¯¥æ‰§è¡Œçš„æ—¶å€™ï¼Œå†éšæœºé€‰æ‹©å®¢æˆ·ç«¯å»æ‰§è¡Œã€‚
å»ä¸­å¿ƒåŒ–å’Œä¸­å¿ƒåŒ–å„æœ‰ä¼˜ç¼ºç‚¹ï¼Œ
å»ä¸­å¿ƒåŒ–å¥½å¤„åœ¨äºåªæ˜¯ä¾èµ–ZKçš„é€‰ä¸¾ï¼Œä½†æ˜¯å®¢æˆ·ç«¯å¿…é¡»è¦ä¸¥æ ¼æ§åˆ¶å¹‚ç­‰ï¼ŒåŒæ—¶ä¹Ÿè¦è€ƒè™‘å¦‚æœä¸€ä¸ªä»»åŠ¡è¢«ä¸¤å°æœåŠ¡å™¨åŒæ—¶æ‰§è¡Œçš„æƒ…å†µã€‚
ä¸­å¿ƒåŒ–å¥½å¤„å°±æ˜¯ä¸ä¾èµ–é€‰ä¸¾ï¼Œä½†æ˜¯ä¾èµ–æœåŠ¡ç«¯å»ä¸‹å‘ä»»åŠ¡ï¼Œå¦‚æœä»»åŠ¡å¾ˆå¤šçš„è¯ä¼šå¯¼è‡´æœåŠ¡ç«¯éå¸¸è‡ƒè‚¿ï¼ŒåŒæ—¶éœ€è¦è€ƒè™‘æœåŠ¡ç«¯é«˜å¯ç”¨çš„é—®é¢˜
å¿…é¡»è¦æ”¯æŒåˆ†å¸ƒå¼ã€‚
</code></pre><h2 id="cornè¡¨è¾¾å¼è®°å½•"><a href="#cornè¡¨è¾¾å¼è®°å½•" class="headerlink" title="cornè¡¨è¾¾å¼è®°å½•"></a>cornè¡¨è¾¾å¼è®°å½•</h2><pre><code>å­—æ®µï¼š
ç§’ï¼ˆSecondsï¼‰ åˆ†ï¼ˆMinutesï¼‰  å°æ—¶ï¼ˆHoursï¼‰ æ—¥æœŸï¼ˆDayofMonthï¼‰ æœˆä»½ï¼ˆMonthï¼‰ æ˜ŸæœŸï¼ˆDayofWeekï¼‰ å¹´(å¯é€‰ï¼Œç•™ç©º)ï¼ˆYearï¼‰
å­—ç¬¦æ„ä¹‰
*ï¼šè¡¨ç¤ºåŒ¹é…è¯¥åŸŸçš„ä»»æ„å€¼ï¼Œå‡å¦‚åœ¨MinutesåŸŸä½¿ç”¨*, å³è¡¨ç¤ºæ¯åˆ†é’Ÿéƒ½ä¼šè§¦å‘äº‹ä»¶
?ï¼šåªèƒ½ç”¨åœ¨DayofMonthå’ŒDayofWeekä¸¤ä¸ªåŸŸã€‚å®ƒä¹ŸåŒ¹é…åŸŸçš„ä»»æ„å€¼ï¼Œä½†å®é™…ä¸ä¼šã€‚ç”¨çš„æ¯”è¾ƒå°‘
-ï¼šè¡¨ç¤ºèŒƒå›´ã€‚ä¾‹å¦‚åœ¨MinutesåŸŸä½¿ç”¨5-20ï¼Œè¡¨ç¤ºä»5åˆ†åˆ°20åˆ†é’Ÿæ¯åˆ†é’Ÿè§¦å‘ä¸€æ¬¡ã€‚ç”¨çš„ä¹Ÿæ¯”è¾ƒå°‘
/ï¼šè¡¨ç¤ºèµ·å§‹æ—¶é—´å¼€å§‹è§¦å‘ï¼Œç„¶åæ¯éš”å›ºå®šæ—¶é—´è§¦å‘ä¸€æ¬¡ã€‚
ä¾‹å¦‚åœ¨MinutesåŸŸä½¿ç”¨5/20,åˆ™æ„å‘³ç€ä»5åˆ†é’Ÿå¼€å§‹ï¼Œ20åˆ†é’Ÿè§¦å‘ä¸€æ¬¡ï¼Œè€Œ25ï¼Œ45ç­‰åˆ†åˆ«è§¦å‘ä¸€æ¬¡.
0 0/30 * * * ? ï¼Œåˆ™æ„å‘³ç€æ¯éš”30åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡ï¼Œä»ç¬¬0åˆ†é’Ÿå¼€å§‹ï¼Œç„¶åæ˜¯30åˆ†é’Ÿ ç„¶åæ˜¯60åˆ†é’Ÿ
å¸¸ç”¨è¡¨è¾¾å¼ä¾‹å­:
æ¯å¤©ä¸­åˆ12ç‚¹è§¦å‘ ï¼š0 0 12 * * ï¼Ÿ
æ¯å¤©ä¸Šåˆ10:15è§¦å‘  ï¼š0 15 10 * * ï¼Ÿ
å‘¨ä¸€åˆ°å‘¨äº”æ¯å¤©ä¸Šåˆ10:15è§¦å‘ ï¼š0 15 10 ï¼Ÿ * MON-FRI
æœä¹æ™šäº”å·¥ä½œæ—¶é—´å†…æ¯åŠå°æ—¶ ï¼š 0 0/30 9-17 * * ?
æœä¹æ™šäº”å·¥ä½œæ—¶é—´å†…æ¯åŠå°æ—¶ ï¼š 0 0/30 * * * ?
 æ¯ä¸€å°æ—¶æ‰§è¡Œä¸€æ¬¡ï¼š 0 0 * * * ?     0 0 0/1 * * ?
</code></pre><h2 id="docker-job"><a href="#docker-job" class="headerlink" title="docker-job"></a>docker-job</h2><pre><code>æœ‰æ—¶å€™æˆ‘ä»¬çš„ä»»åŠ¡æ‰§è¡Œé¢‘ç‡ä¸æ˜¯ç‰¹åˆ«é«˜ï¼Œæ¯”å¦‚æ¯ä¸ª6å°æ—¶æ‰§è¡Œä¸€æ¬¡ï¼Œå¯¹äºè¿™ç§ä»»åŠ¡ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨dockerè¿›è¡Œéƒ¨ç½²æ‰§è¡Œã€‚
å½“ä»»åŠ¡æ‰§è¡Œådockeræœºå™¨é”€æ¯ä¹Ÿä¸ä¼šå ç”¨æœºå™¨
</code></pre><h2 id="è¿›ç¨‹å†…job"><a href="#è¿›ç¨‹å†…job" class="headerlink" title="è¿›ç¨‹å†…job"></a>è¿›ç¨‹å†…job</h2><pre><code>å¯¹äºæ‰§è¡Œé¢‘ç‡æ¯”è¾ƒé«˜çš„ï¼Œæ¯”å¦‚æ¯éš”5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡å°±é€‚åˆåœ¨è¿›ç¨‹å†…è¿›è¡Œéƒ¨ç½²
</code></pre><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h2 id="ä¸€ã€RPCæ¡†æ¶çš„ä»·å€¼"><a href="#ä¸€ã€RPCæ¡†æ¶çš„ä»·å€¼" class="headerlink" title="ä¸€ã€RPCæ¡†æ¶çš„ä»·å€¼"></a>ä¸€ã€RPCæ¡†æ¶çš„ä»·å€¼</h2><pre><code>  RPCçš„å…¨ç§°æ˜¯RemoteProcedureCallï¼Œå³è¿œç¨‹è¿‡ç¨‹è°ƒç”¨ã€‚

è½åœ°å¾®æœåŠ¡çš„åŸºç¡€
è§£å†³äº†åˆ†å¸ƒå¼ç³»ç»Ÿä¹‹é—´ç›¸äº’é€šä¿¡çš„é—®é¢˜
å±è”½äº†æœåŠ¡ä¸æœåŠ¡ä¹‹é—´è°ƒç”¨çš„æŠ€æœ¯ç»†èŠ‚ï¼Œè®©æˆ‘ä»¬åƒè°ƒç”¨æœ¬åœ°ä»£ç ä¸€æ ·è®¿é—®è¿œç¨‹æœåŠ¡
</code></pre><h2 id="äºŒã€RPCå…³é”®è¯"><a href="#äºŒã€RPCå…³é”®è¯" class="headerlink" title="äºŒã€RPCå…³é”®è¯"></a>äºŒã€RPCå…³é”®è¯</h2><pre><code>2.1 æœåŠ¡æ³¨å†Œä¸å‘ç°
æœåŠ¡åŠ¨æ€ä¸Šçº¿ä¸ä¸‹çº¿

2.2 è½¯è´Ÿè½½å‡è¡¡ç­–ç•¥
æ›¿ä»£F5ï¼Œå¸¸è§æœ‰è½®è¯¢æ³•ã€åŠ æƒè½®è¯¢æ³•ã€éšæœºæ³•ã€æœ€å°è¿æ¥æ•°æ³•

2.3 æœåŠ¡è°ƒç”¨é“¾è·Ÿè¸ª
å…¨é“¾è·¯æ—¥å¿—è·Ÿè¸ªç›‘æ§

2.4 æœåŠ¡ç›‘æ§ä¸ç»Ÿè®¡
2.5 æœåŠ¡ç¼–æ’
2.6. æœåŠ¡æƒé™æ§åˆ¶/é»‘ç™½åå•
æ ¸å¿ƒæœåŠ¡éœ€è¦ç”³è¯·æ‰å¯ä»¥è®¿é—®

2.7 æœåŠ¡ä¾èµ–å…³ç³»
æœåŠ¡ä¸‹çº¿æˆ–è€…å¼ºåˆ¶å‡çº§ï¼Œå¦‚ä½•å‘ŠçŸ¥ä¸Šä¸‹æ¸¸

2.8 æœåŠ¡åˆ†ç»„ã€ç‰ˆæœ¬ã€é‡è¯• ã€é™çº§ã€é™æµã€å®¹é”™
åˆ†ç»„ï¼šæä¾›æ¥å£å¤šå®ç°åŠŸèƒ½
ç‰ˆæœ¬å·ï¼šå½“ä¸€ä¸ªæ¥å£çš„å®ç°ï¼Œå‡ºç°ä¸å…¼å®¹å‡çº§æ—¶æˆ–è€…å¤„ç†é€»è¾‘å˜åŒ–æ—¶å€™ï¼Œå¯ä»¥ç”¨ç‰ˆæœ¬å·è¿‡æ¸¡
é‡è¯•ï¼šé˜²æ­¢æœåŠ¡æŠ–åŠ¨
2.9 SPIæœºåˆ¶
é¢„ç•™å¯æ‰©å±•æ¥å£

2.10 æœåŠ¡æ³³é“
æ”¯æŒä¸€ä¸ªæœåŠ¡æ³¨å†Œåˆ°ä¸åŒçš„ç¯å¢ƒï¼Œè¿™æ ·å°±å¯ä»¥é¿å…å¤šç‰ˆæœ¬å¹¶è¡Œææµ‹é—®é¢˜ã€‚

2.11 æœåŠ¡region
æœåŠ¡å¤šåŒºåŸŸæœºæˆ¿çš„æƒ…å†µä¸‹ï¼Œç›¸åŒåŒºåŸŸçš„clientä¼˜å…ˆè°ƒç”¨ç›¸åŒåŒºåŸŸçš„server
</code></pre><h2 id="ä¸‰ã€é€’è¿›æ‰‹å†™RPC"><a href="#ä¸‰ã€é€’è¿›æ‰‹å†™RPC" class="headerlink" title="ä¸‰ã€é€’è¿›æ‰‹å†™RPC"></a>ä¸‰ã€é€’è¿›æ‰‹å†™RPC</h2><pre><code>æœ€ç®€å•çš„rpcæµç¨‹å›¾
</code></pre><h3 id="3-1-å…¥é—¨çº§åˆ«"><a href="#3-1-å…¥é—¨çº§åˆ«" class="headerlink" title="3.1 å…¥é—¨çº§åˆ«"></a>3.1 å…¥é—¨çº§åˆ«</h3><pre><code>å‚è€ƒdubboä½œè€…æ¢é£ä»£ç 
public interface HelloService {
    String hello(String name);
}

public class HelloServiceImpl implements HelloService {
    @Override
    public String hello(String name) {
        return &quot;Hello &quot; + name;
    }
}

public class RpcProvider {
    public static void main(String[] args) throws Exception {
        HelloService service = new HelloServiceImpl();
        RpcFramework.export(service, 1234);
    }
}

public class RpcConsumer {
    public static void main(String[] args) throws Exception {
        HelloService service = RpcFramework.refer(HelloService.class, &quot;127.0.0.1&quot;, 1234);
        for (int i = 0; i &lt; Integer.MAX_VALUE; i ++) {
            String hello = service.hello(&quot;World&quot; + i);
            System.out.println(hello);
            Thread.sleep(1000);
        }
    }
}



public class RpcFramework {
    /**
     * æš´éœ²æœåŠ¡
     *
     * @param service æœåŠ¡å®ç°
     * @param port    æœåŠ¡ç«¯å£
     * @throws Exception
     */
    public static void export(final Object service, int port) throws Exception {
        if (service == null)
            throw new IllegalArgumentException(&quot;service instance == null&quot;);
        if (port &lt;= 0 || port &gt; 65535)
            throw new IllegalArgumentException(&quot;Invalid port &quot; + port);
        System.out.println(&quot;Export service &quot; + service.getClass().getName() + &quot; on port &quot; + port);
        ServerSocket server = new ServerSocket(port);
        for (; ; ) {
            try {
                final Socket socket = server.accept();
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            try {
                                ObjectInputStream input = new ObjectInputStream(socket.getInputStream());
                                try {
                                    String methodName = input.readUTF();
                                    Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject();
                                    Object[] arguments = (Object[]) input.readObject();
                                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
                                    try {
                                        Method method = service.getClass().getMethod(methodName, parameterTypes);
                                        Object result = method.invoke(service, arguments);
                                        output.writeObject(result);
                                    } catch (Throwable t) {
                                        output.writeObject(t);
                                    } finally {
                                        output.close();
                                    }
                                } finally {
                                    input.close();
                                }
                            } finally {
                                socket.close();
                            }
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }).start();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * å¼•ç”¨æœåŠ¡
     *
     * @param &lt;T&gt;            æ¥å£æ³›å‹
     * @param interfaceClass æ¥å£ç±»å‹
     * @param host           æœåŠ¡å™¨ä¸»æœºå
     * @param port           æœåŠ¡å™¨ç«¯å£
     * @return è¿œç¨‹æœåŠ¡
     * @throws Exception
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T refer(final Class&lt;T&gt; interfaceClass, final String host, final int port) throws Exception {
        if (interfaceClass == null)
            throw new IllegalArgumentException(&quot;Interface class == null&quot;);
        if (!interfaceClass.isInterface())
            throw new IllegalArgumentException(&quot;The &quot; + interfaceClass.getName() + &quot; must be interface class!&quot;);
        if (host == null || host.length() == 0)
            throw new IllegalArgumentException(&quot;Host == null!&quot;);
        if (port &lt;= 0 || port &gt; 65535)
            throw new IllegalArgumentException(&quot;Invalid port &quot; + port);
        System.out.println(&quot;Get remote service &quot; + interfaceClass.getName() + &quot; from server &quot; + host + &quot;:&quot; + port);
        return (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class&lt;?&gt;[]{interfaceClass}, new InvocationHandler() {
            public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable {
                Socket socket = new Socket(host, port);
                try {
                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
                    try {
                        output.writeUTF(method.getName());
                        output.writeObject(method.getParameterTypes());
                        output.writeObject(arguments);
                        ObjectInputStream input = new ObjectInputStream(socket.getInputStream());
                        try {
                            Object result = input.readObject();
                            if (result instanceof Throwable) {
                                throw (Throwable) result;
                            }
                            return result;
                        } finally {
                            input.close();
                        }
                    } finally {
                        output.close();
                    }
                } finally {
                    socket.close();
                }
            }
        });
    }
}
å¦‚æœæœåŠ¡å¤„ç†å¾ˆæ…¢ï¼ŒåŒæ—¶Nä¸ªå®¢æˆ·ç«¯è°ƒç”¨ï¼Œä¼šæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿå¯ä»¥åšæ€ä¹ˆæ”¹è¿›ã€‚
</code></pre><h3 id="3-2-å¼‚æ­¥è°ƒç”¨"><a href="#3-2-å¼‚æ­¥è°ƒç”¨" class="headerlink" title="3.2 å¼‚æ­¥è°ƒç”¨"></a>3.2 å¼‚æ­¥è°ƒç”¨</h3><pre><code>rpcè¯·æ±‚æ¨¡å¼æœ‰åŒæ­¥æ¨¡å¼ã€æ— è¿”å›å€¼æ¨¡å¼ã€å¼‚æ­¥æ¨¡å¼ï¼Œå¼‚æ­¥æ¨¡å¼è®¾è®¡æ¯”è¾ƒå·§å¦™

å¦‚æœè¦å®ç°å¼‚æ­¥ï¼Œé‚£ä¹ˆclientç«¯åœ¨è°ƒç”¨çš„æ—¶å€™ï¼Œè¿”å›å€¼è‚¯å®šæ˜¯è¦æ˜¯futureç±»å‹ï¼Œä½†å¦‚æœæ¶åŒ…é‡Œé¢çš„DTOå¯¹è±¡è¿”å›ç±»å‹å®šä¹‰æˆFuture&lt;xx&gt;è¿™ç§æ ¼å¼ï¼Œ

åæœŸå¦‚æœæƒ³æ”¹æˆåŒæ­¥è°ƒç”¨ï¼Œå°±åˆè¦æ”¹å˜DTOç±»å‹ ï¼Œrpcè¯·æ±‚æ¨¡å¼ä¸DTOç›¸äº’è€¦åˆè‚¯å®šè¿èƒŒæˆ‘ä»¬çš„è®¾è®¡ã€‚

3.2.1 è®¾è®¡æ€è·¯ï¼š
clientæ¯æ¬¡è¯·æ±‚ç”Ÿæˆå”¯ä¸€requestIdï¼Œserverç«¯è¿”å›çš„æ—¶å€™å¸¦ä¸ŠrequestIdä¸è¿”å›å€¼

3.2.2 æ ¸å¿ƒä»£ç :
clientè®¾è®¡ï¼š

public class ConsumerClient {
    public static &lt;T&gt; T getProxyClass(Class&lt;T&gt; interfaceClass, RpcRequest rpcRequest) {
        return (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class&lt;?&gt;[]{interfaceClass}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                Socket socket = null;
                ObjectOutputStream oos = null;
                BufferedReader bufferedInputStream = null;
                try {
                    socket = new Socket(&quot;localhost&quot;, 8081);
                    oos = new ObjectOutputStream(socket.getOutputStream());
                    String requestId = UUID.randomUUID().toString();
                    rpcRequest.setRequestId(requestId);
                    rpcRequest.setMethodName(method.getName());
                    rpcRequest.setGetParameterTypes(method.getParameterTypes());
                    rpcRequest.setArgs(args);
                    oos.writeObject(rpcRequest);
                    oos.flush();
                    if (rpcRequest.isAnsyc()) {
                        //requestid æ”¾åˆ°threadLocal
                        RpcContext.setInvokeMethodStyle(requestId);
                        Socket finalSocket = socket;
                        new Thread() {
                            @Override
                            public void run() {
                                try {
                                    ObjectInputStream ois = new ObjectInputStream(finalSocket.getInputStream());
                                    RpcResponse rpcResponse = (RpcResponse) ois.readObject();
                                    if (RpcContext.checkAnsyc(rpcResponse.getRequestId())) {
                                        RpcContext.putAnsyResult(rpcResponse.getRequestId(), rpcResponse);
                                    }
                                } catch (IOException e) {
                                    e.printStackTrace();
                                } catch (ClassNotFoundException e) {
                                    e.printStackTrace();
                                }
                            }
                        }.start();
                    } else {
                        bufferedInputStream = new BufferedReader(new InputStreamReader(socket.getInputStream(), &quot;utf-8&quot;));
                        return bufferedInputStream.readLine();
                    }
                    return null;
                } catch (Exception e) {
                    log.error(&quot;&quot;, e);
                } finally {
                }
                return null;
            }
        });
    }

    public static void main(String[] args) throws Exception, InterruptedException {
        RpcRequest rpcRequest = new RpcRequest();
        rpcRequest.setAnsyc(true);
        TestService testService = ConsumerClient.getProxyClass(TestService.class, rpcRequest);
        long beginTime = System.currentTimeMillis();
        testService.testMethod(&quot;gaogao1&quot;);
        Future future1 = RpcContext.getFuture();

        testService.testMethod(&quot;gaogao2&quot;);
        Future future2 = RpcContext.getFuture();

        log.info(&quot;------------get result-------&quot;);
        RpcResponse response1 = (RpcResponse) future1.get();
        System.out.println(response1.getResult());

        RpcResponse response2 = (RpcResponse) future2.get();
        long endTime = System.currentTimeMillis();

        log.info(&quot;cost:{}&quot;, endTime - beginTime);
        System.out.println(response2.getResult());
    }
}



contentxè®¾è®¡ï¼š

public class RpcContext {
    //å­˜æ”¾requestId
    public static ThreadLocal&lt;String&gt; requestIdthreadLocal = new ThreadLocal&lt;&gt;();
    //è°ƒç”¨æ–¹å¼
    public static Map&lt;String, Boolean&gt; invokeMethodStyle = new ConcurrentHashMap&lt;&gt;();
    //ç¼“å­˜future
    public static Map&lt;String, RpcResultFuture&gt; futureMap = new ConcurrentHashMap&lt;&gt;();

    /**
     * è¿”å›å€¼æ”¾åˆ°mapé‡Œé¢
     * @param requestId
     * @param rpcResponse
     */
    public static void putAnsyResult(String requestId, RpcResponse rpcResponse) {
        RpcResultFuture future = futureMap.get(requestId);
        future.setResult(requestId, rpcResponse);
    }

    /**
     * è·å–ä»£ç†future
     *
     * @return
     */
    public static Future getFuture() throws Exception {
        if(requestIdthreadLocal.get()==null){
            throw new Exception(&quot;no ansyc method&quot;);
        }
        RpcResultFuture future = new RpcResultFuture();
        //å­˜æ”¾åˆ°ç¼“å­˜ï¼Œè¿™æ ·å½“è¿”å›å€¼å›æ¥æ—¶å€™å°±å¯ä»¥ç”¨åˆ°
        futureMap.put(requestIdthreadLocal.get(), future);
        //é˜²æ­¢éšä¾¿get
        requestIdthreadLocal.remove();
        return future;
    }

    public static void setInvokeMethodStyle(String requestId) {
        invokeMethodStyle.put(requestId, true);
        requestIdthreadLocal.set(requestId);
    }

    public static boolean checkAnsyc(String requestId) {
        return invokeMethodStyle.get(requestId) == null ? false : true;
    }
}



futureè®¾è®¡

public class RpcResultFuture implements Future {
    private String requestId;
    private CountDownLatch countDownLatch = new CountDownLatch(1);
    private Object object = null;

    @Override
    public boolean cancel(boolean mayInterruptIfRunning) {
        return false;
    }

    @Override
    public boolean isCancelled() {
        return false;
    }

    @Override
    public boolean isDone() {
        return false;
    }

    @Override
    public Object get() throws InterruptedException, ExecutionException {
        countDownLatch.await();
        //clearç¼“å­˜
        RpcContext.futureMap.remove(requestId);
        return object;
    }

    @Override
    public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        countDownLatch.await(timeout, unit);
        return object;
    }

    public void setResult(String requestId, RpcResponse rpcResponse) {
        this.requestId = requestId;
        object = rpcResponse;
        countDownLatch.countDown();
    }
}

3.3 åŸºäºnettyå°è£…
bioç‰ˆæœ¬qpséå¸¸ä½ï¼ŒåŒæ—¶è¿˜ä¼šæœ‰ç²˜åŒ…æ‹†åŒ…é—®é¢˜

3.3.1 å¢åŠ åŠŸèƒ½
è‡ªå®šä¹‰ä¼ è¾“åè®®
           å•æ¬¡è¯·æ±‚ä½“ç”±ä»¥ä¸‹ä¸¤éƒ¨åˆ†ç»„æˆï¼š

      1ã€æ•°æ®byte[]æ€»é•¿åº¦+4ä¸ªå ä½ç¬¦é•¿åº¦
      2ã€æ•°æ®dataçš„byte[]
è‡ªå®šä¹‰åºåˆ—åŒ–
  æé«˜æ€§èƒ½
å¢åŠ æœåŠ¡è¯·æ±‚è¶…æ—¶æ—¶é—´
serveræœåŠ¡æ³¨è§£æ³¨å†Œ


3.3.2 æ ¸å¿ƒä»£ç 
client:

@Slf4j
public class ClientEncoder extends MessageToByteEncoder {
    @Override
    protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception {
        try {
//          byte[] responseByte = KryoUtil.serialiaztion(msg);
            byte[] responseByte = Tool.serialize(msg);
            int totalLength = 4 + responseByte.length;
            out.writeInt(totalLength);
            out.writeBytes(responseByte);
        } catch (Exception e) {
            log.error(&quot;&quot;, e);
        }
    }
}

public class ClientDecoder extends ByteToMessageDecoder {
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
        int readableBytes = in.readableBytes();
        //æœ€å°å¯è¯»é•¿åº¦è¦å¤§äº4
        if (readableBytes &lt; 4) {
            return;
        }
        //æ ‡è®°å½“å‰æŒ‡é’ˆä½ç½®
        in.markReaderIndex();
        int dataLength = in.readInt();
        if (dataLength &lt; 0) {
            ctx.close();
        }
        //å¦‚æœæ•°æ®å¯è¯»é•¿åº¦å°äºå‘é€æ¥è¯»æ•°æ®åŒ…æ€»é•¿åº¦ï¼Œå½“ç„¶ä¸èƒ½ç»§ç»­è¯»
        if (readableBytes &lt; dataLength) {
            //æ¢å¤è¯»æŒ‡é’ˆåˆ°åŸæ¥çš„ä½ç½®
            in.resetReaderIndex();
            return;
        }
        byte[] bytes = new byte[dataLength - 4];
        in.readBytes(bytes);
        //ååºåˆ—è¯·æ±‚
        out.add(Tool.deserialize(bytes, RpcResponse.class));
    }
}

public class RpcClientHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        RpcResponse rpcResponse = (RpcResponse) msg;
        ClientProvider.putRpcResponse(rpcResponse);
    }
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }
}

public class RpcInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        RpcInvokeFutureResult rpcInvokeFutureResult = null;
        RpcResponse response = null;
        try {
            RpcRequest rpcRequest = new RpcRequest();
            rpcRequest.setRequestId(UUID.randomUUID().toString());
            rpcRequest.setClassName(method.getDeclaringClass().getName());
            rpcRequest.setMethodName(method.getName());
            rpcRequest.setParameterTypes(method.getParameterTypes());
            rpcRequest.setParameters(args);
            //è·å–futureè¿”å›å€¼
            rpcInvokeFutureResult = ClientProvider.sendAndGetRpcInvokeFutureResult(rpcRequest, rpcRequest.getRequestId());
            response = rpcInvokeFutureResult.get(rpcRequest.getTimeOut(), TimeUnit.SECONDS);
        } catch (Exception e) {
            log.error(&quot;&quot;, e);
        }
        if (response != null) {
            return response.getResponse();
        }
        return null;
    }
}
public class ClientProvider {
    private static Map&lt;String, RpcInvokeFutureResult&gt; rpcResultMap = new ConcurrentHashMap&lt;&gt;();
    private static ChannelFuture channelFuture = null;
    static {
        init();
    }

    private static void init() {
        startNettyClient();
    }

    private static void startNettyClient() {
        Bootstrap clentBootstrap = new Bootstrap();
        NioEventLoopGroup group = new NioEventLoopGroup();
        clentBootstrap.group(group).channel(NioSocketChannel.class)
                .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
                    @Override
                    protected void initChannel(SocketChannel ch) throws Exception {
                        /**
                         /**è‡ªå®šä¹‰åè®®è§£å†³ç²˜åŒ… begin**/
                        ch.pipeline().addLast(new ClientEncoder());
                        ch.pipeline().addLast(new ClientDecoder());
                        /**è‡ªå®šä¹‰åè®®è§£å†³ç²˜åŒ… end**/
                        ch.pipeline().addLast(new RpcClientHandler());
                    }
                }).option(ChannelOption.SO_KEEPALIVE, true);
        try {
            channelFuture = clentBootstrap.connect(&quot;127.0.0.1&quot;, 8000).sync();
        } catch (InterruptedException e) {
            log.error(&quot;init netty client error&quot;, e);
        }
    }

    public static ChannelFuture getChannelFuture() {
        return channelFuture;
    }

    /**
     * å‘é€æ¶ˆæ¯å’Œè¿”å›futureç»“æœ
     *
     * @param
     * @param requestId
     * @return
     */
    public static RpcInvokeFutureResult sendAndGetRpcInvokeFutureResult(RpcRequest rpcRequest, String requestId) {
        RpcInvokeFutureResult rpcInvokeFutureResult = new RpcInvokeFutureResult(requestId,rpcResultMap);
        getChannelFuture().channel().writeAndFlush(rpcRequest);
        ClientProvider.rpcResultMap.put(requestId, rpcInvokeFutureResult);
        return rpcInvokeFutureResult;
    }


    public static void putRpcResponse(RpcResponse response) {
        RpcInvokeFutureResult rpcInvokeFutureResult = rpcResultMap.get(response.getRequestId());
        if (rpcInvokeFutureResult != null) {
            rpcInvokeFutureResult.put(response);
        }
    }
}



serverï¼š

public class RpcServerHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        RpcRequest rpcRequest = (RpcRequest) msg;
        RpcResponse response = new RpcResponse();
        response.setRequestId(rpcRequest.getRequestId());
        String requestClassName = rpcRequest.getClassName();
        Object object = ServerProvider.cacheSericeMap.get(requestClassName);
        try {
            Object result = object.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParameterTypes()).invoke(object, rpcRequest.getParameters());
            response.setResponse(result);
        } catch (Throwable e) {
            response.setExcetion(e.getMessage());
            log.error(&quot;&quot;, e);
        }
        ctx.writeAndFlush(response);
    }
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }
}

public class ServerProvider {
    public static Map&lt;String, Object&gt; cacheSericeMap = new HashMap&lt;&gt;();
    private static AtomicBoolean initStatus = new AtomicBoolean(false);

    public static void init() {
        if (initStatus.compareAndSet(false, true)) {
            scannAndCacheService();
            startNettyServer();
        } else {
            throw new IllegalStateException(&quot;can not repeat init&quot;);
        }
    }

    private static void startNettyServer() {
        ServerBootstrap serverBootstrap = new ServerBootstrap();
        NioEventLoopGroup boosGroup = new NioEventLoopGroup();
        NioEventLoopGroup workGroup = new NioEventLoopGroup();
        serverBootstrap.group(boosGroup, workGroup).channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                    @Override
                    protected void initChannel(SocketChannel ch) throws Exception {
                        /**
                         /**è‡ªå®šä¹‰åè®®è§£å†³ç²˜åŒ… begin**/
                        ch.pipeline().addLast(new ServerEncoder());
                        ch.pipeline().addLast(new ServerDecoder());
                        /**è‡ªå®šä¹‰åè®®è§£å†³ç²˜åŒ… end**/
                        ch.pipeline().addLast(new RpcServerHandler());
                    }
                }).bind(8000);
    }

    public static void main(String[] args) {
        init();
    }

    /**
     * æ‰«ææŒ‡å®šç›®å½•æ–‡ä»¶
     */
    private static void scannAndCacheService() {
        try {
            log.info(&quot;scann rpc class begin&quot;);
            ResourcePatternResolver rp = new PathMatchingResourcePatternResolver();
            Resource[] resources = rp.getResources(&quot;classpath:com/ggj/java/rpc/demo/netty/first/server/service/imp/*.class&quot;);
            if (resources == null || resources.length == 0) {
                throw new IllegalArgumentException(&quot;scann package error&quot;);
            }
            for (Resource resource : resources) {
                String className = resource.getFile().getPath().split(&quot;classes\\/&quot;)[1].replaceAll(&quot;\\/&quot;, &quot;.&quot;).replaceAll(&quot;.class&quot;, &quot;&quot;);
                Class&lt;?&gt; clazz = Thread.currentThread().getContextClassLoader().loadClass(className);
                if (clazz.getAnnotation(RpcService.class) != null) {
                    Object object = clazz.newInstance();
                    cacheSericeMap.putIfAbsent(object.getClass().getInterfaces()[0].getName(), object);
                }
            }
            log.info(&quot;scann rpc class end&quot;);
        } catch (Exception e) {
            log.error(&quot;&quot;, e);
        }
    }
}
</code></pre><h3 id="3-4-åŸºäºzkå®ç°æ³¨å†Œä¸­å¿ƒ"><a href="#3-4-åŸºäºzkå®ç°æ³¨å†Œä¸­å¿ƒ" class="headerlink" title="3.4 åŸºäºzkå®ç°æ³¨å†Œä¸­å¿ƒ"></a>3.4 åŸºäºzkå®ç°æ³¨å†Œä¸­å¿ƒ</h3><pre><code>  æœåŠ¡çš„æ³¨å†Œä¸å‘ç°æ˜¯rpcæ¡†æ¶å¿…å¤‡çš„ä¸€ä¸ªåŠŸèƒ½

3.4.1 éš¾ç‚¹æ€è€ƒ
zkä¸Šçš„èŠ‚ç‚¹æ ‘ç»“æ„å¦‚ä½•è®¾è®¡
           æœåŠ¡ç«¯çš„ä¿¡æ¯éƒ½å†™åˆ°zké‡Œé¢ï¼Œé‚£ä¹ˆzkçš„ç»“æ„å¦‚ä½•è®¾è®¡ï¼Ÿ

--ggjRPCï¼ˆname spaceï¼‰

----server

-------com.ggj.java.rpc.demo.netty.first.server.service.AppleService   ï¼ˆ192.168.8.103:4081,192.168.8.103:4082ï¼‰

-------com.ggj.java.rpc.demo.netty.first.server.service.OrangeService  ï¼ˆ192.168.8.103:4081,192.168.8.103:4082ï¼‰

----app

-------oderService (appid)

----weight

serveræ˜¯ç”¨æ¥è®°å½•æœåŠ¡å¯¹åº”çš„æœºå™¨ip,å¤šä¸ªipä»¥é€—å·åˆ†å‰²ï¼Œä¾‹å¦‚ï¼ˆ192.168.8.103:4081,192.168.8.103:4082ï¼‰ï¼Œ
app æ˜¯ç”¨æ¥è®°å½•æä¾›æœåŠ¡çš„åç§°(appid)
weight æ˜¯ç”¨æ¥è®°å½•æä¾›æœåŠ¡æœºå™¨çš„æƒé‡(è´Ÿè½½å‡è¡¡ç”¨åˆ°)
          å¦‚æœæ¢æˆä¸‹é¢çš„æ–¹å¼ä¼šæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ

--ggjRPCï¼ˆname spaceï¼‰
----server
-------orderService(192.168.8.103:4081,192.168.8.103:4082)
-------userServiceï¼ˆ192.168.8.103:4083,192.168.8.103:4084ï¼‰
----app
-------usezkService
----weight


æœåŠ¡æ³¨å†Œä¸å‘ç°
           åœºæ™¯ä¸€ï¼š

                       å‡è®¾æŸä¸ªæœåŠ¡ç›®å‰åªéƒ¨ç½²åœ¨æŸä¸€å°æœºå™¨serverAï¼ˆ192.168.1.1ï¼‰ä¸Š , clientè¯·æ±‚æ—¶å€™å¯ä»¥é€šè¿‡zkç›´æ¥è·å–åˆ°serverAçš„ipï¼Œç„¶åæ‰§è¡Œåç»­æ“ä½œ

            ï¼Œå¦‚æœè¿™æ—¶å€™æœåŠ¡åˆéƒ¨ç½²äº†ä¸€å°æœºå™¨serverBï¼ˆ192.168.1.2),clientå¦‚ä½•æ„ŸçŸ¥åˆ°æ–°ä¸Šçº¿çš„èŠ‚ç‚¹serverBã€‚

           åœºæ™¯äºŒï¼š

                       å‡è®¾æŸä¸ªæœåŠ¡ï¼Œç›®å‰åªéƒ¨ç½²åœ¨serverAï¼ˆ192.168.1.1ï¼‰å’Œserverbï¼ˆ192.168.1.2ï¼‰ä¸Š , clientè¯·æ±‚æ—¶å€™å¯ä»¥é€šè¿‡zkç›´æ¥è·å–åˆ°serverAå’ŒserverAçš„ipï¼Œç„¶åæ‰§è¡Œåç»­æ“ä½œ

           ï¼Œå¦‚æœè¿™æ—¶å€™ä¸‹çº¿äº†serverBï¼ˆ192.168.1.2),clientå¦‚ä½•æ„ŸçŸ¥åˆ°server bä¸‹çº¿ï¼ŒåŒæ—¶åˆ‡èµ°è¯·æ±‚æµé‡åˆ°æœåŠ¡Aä¸Š

clientç«¯å¦‚ä½•é«˜æ€§èƒ½çš„å‘ç°æœåŠ¡ 
            å¦‚æœæ¯æ¬¡è¯·æ±‚éƒ½è¦ä»zké‡Œé¢æ‹‰å»æœ€æ–°çš„èŠ‚ç‚¹ï¼Œæ¥å£qpsè‚¯å®šä¼šä¸‹é™ã€‚

              className -&gt; ipList
               ip-&gt; å¤šä¸ªé“¾æ¥ (åˆ é™¤æœºå™¨æ—¶å€™ å®¢æˆ·ç«¯å¯ä»¥è‡ªåŠ¨å‘ç°å¹¶ä¸”åˆ é™¤é“¾æ¥)
               ip-&gt;classNameSet(å¢åŠ æœºå™¨æ—¶å€™ å®¢æˆ·ç«¯å¯ä»¥è‡ªåŠ¨å‘ç°å¹¶ä¸”æ·»åŠ é“¾æ¥)

3.4.2 æ ¸å¿ƒä»£ç 
zkæ³¨å†Œä¸­å¿ƒï¼š

public class RegisterManager {
    private static Lock lock = new ReentrantLock();
    private static RegisterManager registerManager = new RegisterManager();
    public Register getRegister() {
        return register;
    }
    private Register register;
    private RegisterManager() {
    }

    /**
     * æœåŠ¡ç«¯è°ƒç”¨
     *
     * @return
     */
    public static RegisterManager getInstance() {
        registerManager.init(null);
        return registerManager;
    }

    /**
     * å®¢æˆ·ç«¯è°ƒç”¨
     *
     * @return
     */
    public static RegisterManager getClientInstance() {
        registerManager.init(new ZookeeperDataWatcher());
        return registerManager;
    }

    /**
     * åˆå§‹åŒ–,éœ€è¦åŠ é”é˜²æ­¢åˆå§‹åŒ–å¤šæ¬¡
     *
     * @param zookeeperDataWatcher
     */
    private void init(ZookeeperDataWatcher zookeeperDataWatcher) {
        if (register == null) {
            lock.lock();
            try {
                if (register == null) {
                    register = new ZKRegister();
                    register.initListener(zookeeperDataWatcher);
                }
            } catch (Exception e) {
                log.error(&quot;init error&quot;, e);
            } finally {
                lock.unlock();
            }
        }
    }
}

public class ZKRegister implements Register {

    private AtomicBoolean initRegister = new AtomicBoolean();
    private CuratorClient zkClient;

    public ZKRegister() {
        zkClient = new CuratorClient();
    }

    @Override
    public String getName() {
        return null;
    }

    @Override
    public String getServiceAddress(String serviceName) throws Exception {
        return zkClient.getServiceAddress(serviceName);
    }

    @Override
    public void registerService(String serviceName, String serviceAddress) throws Exception {
        ZKPathConfig zkPathConfig = new ZKPathConfig(serviceName, serviceAddress);
        if (initRegister.compareAndSet(false, true)) {
            initRegisterInfo(zkPathConfig);
        }
        zkClient.registerService(zkPathConfig, serviceAddress);
    }

    /**
     * æ³¨å†Œ
     * æœºå™¨ä¿¡æ¯
     * æ³¨å†Œæƒé‡
     *
     * @param zkPathConfig
     * @throws Exception
     */
    private void initRegisterInfo(ZKPathConfig zkPathConfig) throws Exception {
        zkClient.registerServerApp(zkPathConfig);
        zkClient.registerWeight(zkPathConfig);
    }

    @Override
    public void unregisterService(String serviceName, String serviceAddress) throws Exception {
        ZKPathConfig zkPathConfig = new ZKPathConfig(serviceName, serviceName);
        zkClient.unregisterService(zkPathConfig, serviceAddress);
    }

    @Override
    public boolean unregisterServerApp(String serviceAddress) {
        return false;
    }

    @Override
    public void initListener(ZookeeperDataWatcher zookeeperDataWatcher) {
        if (zookeeperDataWatcher != null) {
            zkClient.initListener(zookeeperDataWatcher);
        }
    }
}

public class CuratorClient {

    private static CuratorFramework client = null;

    public CuratorClient() {
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        client = CuratorFrameworkFactory.newClient(Constants.DEFAULT_CONNECT_URL, retryPolicy);
        client = CuratorFrameworkFactory.builder().namespace(Constants.NAME_SPACE).retryPolicy(retryPolicy).connectString(Constants.DEFAULT_CONNECT_URL).build();
        client.start();
    }

    private void setStringValue() {
    }

    /**
     * å¹¶å‘æ³¨å†Œä¼šæœ‰é—®é¢˜
     *
     * @param zkPathConfig
     * @param serviceAddress
     * @throws Exception
     */
    public void registerService(ZKPathConfig zkPathConfig, String serviceAddress) throws Exception {
        try {
            if (CuratorUtil.checkExists(client, zkPathConfig.getServicePath())) {
                String resulst = CuratorUtil.getStringData(client, zkPathConfig.getServicePath());
                if (StringUtils.isEmpty(resulst)) {
                    CuratorUtil.update(client, zkPathConfig.getServicePath(), serviceAddress);
                } else {
                    String[] adressArray = resulst.split(&quot;\\,&quot;);
                    List&lt;String&gt; adressList = new ArrayList();
                    for (String registeredAdress : adressArray) {
                        //å·²æ³¨å†Œå°±ä¸éœ€è¦é‡å¤æ³¨å†Œ
                        if (!registeredAdress.equals(serviceAddress)) {
                            adressList.add(registeredAdress.trim());
                        }
                    }
                    adressList.add(serviceAddress);
                    CuratorUtil.update(client, zkPathConfig.getServicePath(), org.apache.commons.lang.StringUtils.join(adressList, &quot;,&quot;));
                }
            } else {
                CuratorUtil.create(client, zkPathConfig.getServicePath(), serviceAddress);
            }
        } catch (Exception e) {
            throw e;
        }
    }

    /**
     * æ³¨å†Œåº”ç”¨ä¿¡æ¯
     *
     * @param zkPathConfig
     * @throws Exception
     */
    public void registerServerApp(ZKPathConfig zkPathConfig) throws Exception {
        CuratorUtil.create(client, zkPathConfig.getAppPath(), zkPathConfig.getServiceAddress(), true);

    }

    /**
     * æ³¨å†Œæƒé‡
     *
     * @param zkPathConfig
     * @throws Exception
     */
    public void registerWeight(ZKPathConfig zkPathConfig) throws Exception {
        CuratorUtil.create(client, zkPathConfig.getWeightPath(), String.valueOf(Constants.DEFAULT_ONLINE_WEIGHT), true);
    }

    /**
     * ä¸‹çº¿æœåŠ¡æœºå™¨
     *
     * @param zkPathConfig
     * @param serviceAddress
     * @throws Exception
     */
    public void unregisterService(ZKPathConfig zkPathConfig, String serviceAddress) throws Exception {
        if (CuratorUtil.checkExists(client, zkPathConfig.getServicePath())) {
            String resulst = CuratorUtil.getStringData(client, zkPathConfig.getServicePath());
            if (!StringUtils.isEmpty(resulst)) {
                String[] adressArray = resulst.split(&quot;\\,&quot;);
                List&lt;String&gt; adressList = new ArrayList();
                for (String adress : adressArray) {
                    adressList.add(adress.trim());
                }
                //removeå·²ç»æ³¨å†Œè¿‡çš„
                if (adressList.contains(serviceAddress)) {
                    adressList.remove(serviceAddress);
                }
                CuratorUtil.update(client, zkPathConfig.getServicePath(), org.apache.commons.lang.StringUtils.join(adressList, &quot;,&quot;));
            }
        }
    }

    /**
     * è·å–æœåŠ¡ç«¯æä¾›åœ°å€
     * @param serviceName
     * @return
     * @throws Exception
     */
    public String getServiceAddress(String serviceName) throws Exception {
        ZKPathConfig zkPathConfig=new ZKPathConfig(serviceName,null);
        if (CuratorUtil.checkExists(client, zkPathConfig.getServicePath())) {
            return CuratorUtil.getStringDataAndWatch(client, zkPathConfig.getServicePath());
        }
        throw new Exception(serviceName+&quot;:has no server&quot;);
    }

    public void initListener(ZookeeperDataWatcher zookeeperDataWatcher) {
        client.getCuratorListenable().addListener(zookeeperDataWatcher);
    }
}


/**
 * ç›‘å¬zkèŠ‚ç‚¹ï¼Œä¸‹çº¿æ—¶å€™å˜åŠ¨
 *
 * @author gaoguangjin
 */
@Slf4j
public class ZookeeperDataWatcher implements CuratorListener {
    /**
     *  className -&gt; ipList
     *  ip-&gt; å¤šä¸ªé“¾æ¥ (åˆ é™¤æœºå™¨æ—¶å€™ å®¢æˆ·ç«¯å¯ä»¥è‡ªåŠ¨å‘ç°å¹¶ä¸”åˆ é™¤é“¾æ¥)
     *  ip-&gt;classNameSet(å¢åŠ æœºå™¨æ—¶å€™ å®¢æˆ·ç«¯å¯ä»¥è‡ªåŠ¨å‘ç°å¹¶ä¸”æ·»åŠ é“¾æ¥)
     * @param client
     * @param event
     * @throws Exception
     */
    @Override
    public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {
        if (event.getType() == CuratorEventType.WATCHED &amp;&amp; event.getPath() != null) {
            String path = event.getPath();
            String className = path.split(&quot;\\/&quot;)[2];
            String iplist = CuratorUtil.getStringDataAndWatch(client, path);
            if (StringUtils.isEmpty(iplist)) {
                return;
            }
            String[] iparrays = iplist.split(&quot;\\,&quot;);
            List&lt;String&gt; nowIpList = new ArrayList&lt;&gt;();
            for (String iparray : iparrays) {
                nowIpList.add(iparray);
            }

            List&lt;String&gt; oldIpList = ClientProvider.getClientConnectMap().get(className).getIpList();
            //ä»¥å‰è¿™ä¸ªclassè¿˜æ²¡åˆ›å»ºè¿‡è¯·æ±‚
            if (CollectionUtils.isEmpty(oldIpList)) {
                return;
            }

            //åˆ¤æ–­æ‰©å®¹è¿˜æ˜¯ç¼©å®¹
            if (nowIpList.size() &gt; oldIpList.size()) {
                log.info(&quot;æ‰©å®¹,nowIplist={},oldIplist={}&quot;, nowIpList, oldIpList);
                nowIpList.removeAll(oldIpList);
                for (String nowIp : nowIpList) {
                    ClientProvider.initClient(nowIp);
                    ClientProvider.getClientConnectMap().get(className).getIpList().add(nowIp);
                }
            } else {
                log.info(&quot;é”å®¹,nowIplist={},oldIplist={}&quot;, nowIpList, oldIpList);
                List&lt;String&gt; tempList = new ArrayList();
                tempList.addAll(oldIpList);
                tempList.removeAll(nowIpList);
                for (String oldIp : tempList) {
                    ClientProvider.getClientConnectMap().get(className).getIpList().remove(oldIp);
                    List&lt;ChannelFuture&gt; futureList = ClientProvider.getChannelFutureConnectMap().get(oldIp);
                    for (ChannelFuture channelFuture : futureList) {
                        channelFuture.channel().closeFuture();
                    }
                    ClientProvider.getChannelFutureConnectMap().remove(oldIp);
                }
            }
        }
    }
}





client

public class RpcInvocationHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        RpcInvokeFutureResult rpcInvokeFutureResult = null;
        RpcResponse response = null;
        RpcRequest rpcRequest = new RpcRequest();
        try {
            rpcRequest.setRequestId(UUID.randomUUID().toString());
            rpcRequest.setClassName(method.getDeclaringClass().getName());
            rpcRequest.setMethodName(method.getName());
            rpcRequest.setParameterTypes(method.getParameterTypes());
            rpcRequest.setParameters(args);
            //è·å–futureè¿”å›å€¼
            rpcInvokeFutureResult = ClientProvider.sendAndGetRpcInvokeFutureResult(rpcRequest, rpcRequest.getRequestId());
            response = rpcInvokeFutureResult.get(rpcRequest.getTimeOut(), TimeUnit.MILLISECONDS);
        } catch (Exception e) {
            log.error(&quot;&quot;, e);
            throw e;
        }
        //è¶…æ—¶
        if(response==null){
            throw new Exception(&quot;rpc &quot;+method.getDeclaringClass().getName()+&quot; timeout&quot;);
        }
        return response.getResponse();
    }
}

/**
 * @author gaoguangjin
 */
@Slf4j
public class ClientProvider {
    @Getter
    private static Map&lt;String, RpcInvokeFutureResult&gt; rpcResultMap = new ConcurrentHashMap&lt;&gt;();
    @Getter
    //className -&gt; ipList
    private static Map&lt;String, ChannelFutureHolder&gt; clientConnectMap = new ConcurrentHashMap();
    @Getter
    // ip-&gt; å¤šä¸ªé“¾æ¥
    private static Map&lt;String, List&lt;ChannelFuture&gt;&gt; channelFutureConnectMap = new ConcurrentHashMap();
    private static Lock lock = new ReentrantLock();

    public static ChannelFuture getNettyClient(String ipStrs, String className) throws Exception {
        lock.lock();
        try {
            if (clientConnectMap.containsKey(className)) {
                return clientConnectMap.get(className).selectClient();
            }
            String[] ipArray = ipStrs.split(&quot;\\,&quot;);
            List&lt;String&gt; ipList = new ArrayList&lt;&gt;();
            for (String iparray : ipArray) {
                initClient(iparray);
                ipList.add(iparray);
            }
            clientConnectMap.put(className, new ChannelFutureHolder(ipList));
        } catch (Exception e) {
            log.error(&quot;init netty client error&quot;, e);
            throw e;
        } finally {
            lock.unlock();
        }
        return clientConnectMap.get(className).selectClient();
    }

    public static List&lt;ChannelFuture&gt; initClient(String ip) throws InterruptedException {
        lock.lock();
        List&lt;ChannelFuture&gt; futureList = new ArrayList&lt;&gt;();
        try {
            String[] ipArray = ip.split(&quot;\\:&quot;);
            if (channelFutureConnectMap.containsKey(ip)) {
                return channelFutureConnectMap.get(ip);
            }
            for (int i = 0; i &lt; Constants.CLIENT_INIT_CONNECTION_SIZE; i++) {
                Bootstrap clentBootstrap = new Bootstrap();
                NioEventLoopGroup group = new NioEventLoopGroup();
                clentBootstrap.group(group).channel(NioSocketChannel.class)
                        .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
                            @Override
                            protected void initChannel(SocketChannel ch) throws Exception {
                                ch.pipeline().addLast(new ClientEncoder());
                                ch.pipeline().addLast(new ClientDecoder());
                                ch.pipeline().addLast(new RpcClientHandler());
                            }
                        }).option(ChannelOption.SO_KEEPALIVE, true);
                ChannelFuture channelFuture = clentBootstrap.connect(ipArray[0], Integer.parseInt(ipArray[1])).sync();
                futureList.add(channelFuture);
            }
            channelFutureConnectMap.put(ip, futureList);
        } catch (Exception e) {
            log.error(&quot;init netty client error&quot;, e);
            throw e;
        } finally {
            lock.unlock();
        }
        return futureList;
    }


    public static Map&lt;String, ChannelFutureHolder&gt; getClientConnectMap() {
        return clientConnectMap;
    }

    /**
     * 1ã€ç¼“å­˜map æ˜¯å¦å­˜åœ¨è¿æ¥
     * å¦‚æœå­˜åœ¨ åˆ¤æ–­æ˜¯å¦active
     * å¦‚æœä¸active å°±åˆ‡æ¢åˆ°å…¶ä»–åˆ°
     *
     * @param rpcRequest
     * @return
     * @throws Exception
     */
    public static ChannelFuture getChannelFuture(RpcRequest rpcRequest) throws Exception {
        ChannelFuture channelFuture = null;
        String className = rpcRequest.getClassName();

        if (clientConnectMap.containsKey(className)) {
            channelFuture = clientConnectMap.get(className).selectClient();
            if (channelFuture != null) {
                return channelFuture;
            }
        }
        String iplist = getConnectIp(className);
        if (StringUtils.isEmpty(iplist)) {
            throw new Exception(className + &quot; has no availiable server&quot;);
        }
        channelFuture = getNettyClient(iplist, className);
        return channelFuture;
    }

    /**
     * è·å–æœåŠ¡ç«¯ip
     *
     * @param className
     * @return
     * @throws Exception
     */
    private static String getConnectIp(String className) throws Exception {
        return RegisterManager.getClientInstance().getRegister().getServiceAddress(className);
    }

    /**
     * å‘é€æ¶ˆæ¯å’Œè¿”å›futureç»“æœ
     *
     * @param
     * @param requestId
     * @return
     */
    public static RpcInvokeFutureResult sendAndGetRpcInvokeFutureResult(RpcRequest rpcRequest, String requestId) throws Exception {
        RpcInvokeFutureResult rpcInvokeFutureResult = new RpcInvokeFutureResult(requestId, rpcResultMap);
        Channel channel = getChannelFuture(rpcRequest).channel();
        ChannelFuture channelFuture = channel.writeAndFlush(rpcRequest);
        //ç›‘å¬resposneè¿”å›ç»“æœ,å¦‚æœæœåŠ¡ç«¯ä¸‹çº¿ä¼šæ”¶åˆ°é€šçŸ¥
        channelFuture.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture rfuture) throws Exception {
                if (!rfuture.isSuccess()) {
                    log.info(&quot;rpc rsponse unsuccessful&quot;);
                    rpcInvokeFutureResult.setCause(rfuture.cause());
                }
            }
        });
        ClientProvider.rpcResultMap.put(requestId, rpcInvokeFutureResult);
        return rpcInvokeFutureResult;
    }


    public static void putRpcResponse(RpcResponse response) {
        RpcInvokeFutureResult rpcInvokeFutureResult = rpcResultMap.get(response.getRequestId());
        if (rpcInvokeFutureResult != null) {
            rpcInvokeFutureResult.put(response);
        }
    }

    @Data
    public static class ChannelFutureHolder {

        private AtomicInteger atomicInteger = new AtomicInteger(1);
        private String ip;
        @Getter
        List&lt;String&gt; ipList;

        public ChannelFutureHolder(List&lt;String&gt; ipList) {
            this.ipList = ipList;
        }

        /**
         * éšæœºé€‰æœåŠ¡ç«¯ip
         * éšæœºé€‰æœåŠ¡ç«¯çš„è¿æ¥
         *
         * @return
         */
        public ChannelFuture selectClient() {
            String randomIp = ipList.get(new Random().nextInt(ipList.size()));
            //System.out.println(&quot;invoke ip=&quot;+randomIp);
            List&lt;ChannelFuture&gt; channelFutureList = channelFutureConnectMap.get(randomIp);
            if (CollectionUtils.isEmpty(channelFutureList)) {
                return null;
            }
            return channelFutureList.get(atomicInteger.getAndIncrement() % Constants.CLIENT_INIT_CONNECTION_SIZE);
        }
    }
}



serverç«¯ï¼š

æ·»åŠ äº† shutdownhook

/**
 * æµ‹è¯•æ—¶å€™éœ€è¦è®¾ç½® -Dport=4081
 *
 * @author gaoguangjin
 */
@Slf4j
public class ServerProvider {
    public static Map&lt;String, Object&gt; cacheServiceMap = new HashMap&lt;&gt;();
    private static RegisterManager registerManager = RegisterManager.getInstance();
    private static AtomicBoolean initStatus = new AtomicBoolean(false);

    public static void init() {
        System.setProperty(Constants.APP_NAME_KEY, &quot;usezkService&quot;);
        if (initStatus.compareAndSet(false, true)) {
            try {
                scannAndCacheService();
                startNettyServer();
                registerServerService();
                addShutDownHook();
            } catch (Exception e) {
                log.error(&quot;init server error&quot;, e);
                throw new RuntimeException();
            }
        } else {
            throw new IllegalStateException(&quot;can not repeat init&quot;);
        }
    }

    private static void addShutDownHook() {
        Runtime.getRuntime().addShutdownHook(new Thread() {
            @Override
            public void run() {
                try {
                    shutDownServer();
                } catch (Exception e) {
                    log.error(&quot;åœæœºhookå¤±è´¥&quot;, e);
                }
            }
        });
    }

    /**
     * ä¸‹çº¿æœåŠ¡
     *
     * @throws Exception
     */
    private static void shutDownServer() throws Exception {
        log.info(&quot;excute shutdownserver&quot;);
        for (String serviceName : cacheServiceMap.keySet()) {
            registerManager.getRegister().unregisterService(serviceName, Constants.SERVICE_ADRESS);
        }
    }

    private static void registerServerService() throws Exception {
        for (String className : cacheServiceMap.keySet()) {
            registerManager.getRegister().registerService(className, Constants.SERVICE_ADRESS);
        }
    }

    private static void startNettyServer() {
        ServerBootstrap serverBootstrap = new ServerBootstrap();
        NioEventLoopGroup boosGroup = new NioEventLoopGroup();
        NioEventLoopGroup workGroup = new NioEventLoopGroup();
        serverBootstrap.group(boosGroup, workGroup).channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                    @Override
                    protected void initChannel(SocketChannel ch) throws Exception {
                        /**
                         /**è‡ªå®šä¹‰åè®®è§£å†³ç²˜åŒ… begin**/
                        ch.pipeline().addLast(new ServerEncoder());
                        ch.pipeline().addLast(new ServerDecoder());
                        /**è‡ªå®šä¹‰åè®®è§£å†³ç²˜åŒ… end**/
                        ch.pipeline().addLast(new RpcServerHandler());
                    }
                }).bind(Constants.HOST_ADRESS, Constants.DEFAULT_SERVER_PORT);
    }

    public static void main(String[] args) {
        init();
    }

    /**
     * æ‰«ææŒ‡å®šç›®å½•æ–‡ä»¶
     */
    private static void scannAndCacheService() {
        try {
            log.info(&quot;scann rpc class begin&quot;);
            ResourcePatternResolver rp = new PathMatchingResourcePatternResolver();
            Resource[] resources = rp.getResources(&quot;classpath:com/ggj/java/rpc/demo/netty/usezk/server/service/imp/*.class&quot;);
            if (resources == null || resources.length == 0) {
                throw new IllegalArgumentException(&quot;scann package error&quot;);
            }
            for (Resource resource : resources) {
                String className = resource.getFile().getPath().split(&quot;classes\\/&quot;)[1].replaceAll(&quot;\\/&quot;, &quot;.&quot;).replaceAll(&quot;.class&quot;, &quot;&quot;);
                Class&lt;?&gt; clazz = Thread.currentThread().getContextClassLoader().loadClass(className);
                if (clazz.getAnnotation(RpcService.class) != null) {
                    Object object = clazz.newInstance();
                    cacheServiceMap.putIfAbsent(object.getClass().getInterfaces()[0].getName(), object);
                }
            }
            log.info(&quot;scann rpc class end&quot;);
        } catch (Exception e) {
            log.error(&quot;&quot;, e);
        }
    }
}


3.5 åŸºäºspringå®ç°
 ç•¥

å››ã€ç‚¹è¯„pigeonæ¡†æ¶ä»‹ç»
é¡¹ç›®åœ°å€ï¼šhttps://github.com/dianping/pigeon

ä¸»è¦ç‰¹è‰²ï¼š

1ã€é™¤äº†æ”¯æŒspring schemaç­‰é…ç½®æ–¹å¼ï¼Œä¹Ÿæ”¯æŒä»£ç annotationæ–¹å¼å‘å¸ƒæœåŠ¡ã€å¼•ç”¨è¿œç¨‹æœåŠ¡ï¼Œå¹¶æä¾›åŸç”Ÿapiæ¥å£çš„ç”¨æ³•ã€‚ï¼ˆâ¤ï¸ï¼‰

2ã€æ”¯æŒhttpåè®®ï¼Œæ–¹ä¾¿éjavaåº”ç”¨è°ƒç”¨pigeonçš„æœåŠ¡ã€‚ï¼ˆâ¤ï¸â¤ï¸ï¼‰

3ã€åºåˆ—åŒ–æ–¹å¼é™¤äº†hessianï¼Œè¿˜æ”¯æŒthriftç­‰ã€‚ï¼ˆâ¤ï¸â¤ï¸ï¼‰

4ã€æä¾›äº†æœåŠ¡å™¨å•æœºæ§åˆ¶å°pigeon-consoleï¼ŒåŒ…å«å•æœºæœåŠ¡æµ‹è¯•å·¥å…·ã€‚ï¼ˆâ¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸ï¼‰

5ã€åˆ›æ–°çš„å®¢æˆ·ç«¯è·¯ç”±ç­–ç•¥ï¼Œæä¾›æœåŠ¡é¢„çƒ­åŠŸèƒ½ï¼Œè§£å†³çº¿ä¸Šæµé‡å¤§çš„serviceé‡å¯æ—¶å¤§é‡è¶…æ—¶çš„é—®é¢˜ã€‚ï¼ˆâ¤ï¸â¤ï¸â¤ï¸â¤ï¸ï¼‰

6ã€è®°å½•æ¯ä¸ªè¯·æ±‚çš„å¯¹è±¡å¤§å°ã€è¿”å›å¯¹è±¡å¤§å°ç­‰ç›‘æ§ä¿¡æ¯ã€‚ï¼ˆâ¤ï¸â¤ï¸ï¼‰

7ã€æœåŠ¡ç«¯å¯å¯¹æ–¹æ³•è®¾ç½®å•ç‹¬çš„çº¿ç¨‹æ± è¿›è¡ŒæœåŠ¡éš”ç¦»ï¼Œå¯é…ç½®å®¢æˆ·ç«¯åº”ç”¨çš„æœ€å¤§å¹¶å‘æ•°è¿›è¡Œé™æµã€‚ï¼ˆâ¤ï¸â¤ï¸â¤ï¸â¤ï¸ï¼‰




4.1 æ ¸å¿ƒåŠŸèƒ½ä»‹ç»
4.1.1 å®¢æˆ·ç«¯è·¯ç”±ç­–ç•¥
  é›†ç¾¤ç­–ç•¥ï¼š

//å¤±è´¥ç«‹å³æŠ›å‡ºå¼‚å¸¸
public static final String CLUSTER_FAILFAST = &quot;failfast&quot;;
//å¤±è´¥è‡ªåŠ¨åˆ‡æ¢ï¼Œé‡è¯•å…¶ä»–æœåŠ¡å™¨
public static final String CLUSTER_FAILOVER = &quot;failover&quot;;
//å¤±è´¥å¿½ç•¥å¼‚å¸¸,è¿”å›null
public static final String CLUSTER_FAILSAFE = &quot;failsafe&quot;;
//å¹¶è¡Œè°ƒç”¨å¤šä¸ªæœåŠ¡,è¿”å›è°ƒç”¨æœ€å¿«çš„èŠ‚ç‚¹æ•°æ®
public static final String CLUSTER_FORKING = &quot;forking&quot;;

æºç åˆ†æï¼š
FailfastCluster
/**
 * å¿«é€Ÿå¤±è´¥
 */
public class FailfastCluster implements Cluster {

    private ClientManager clientManager = ClientManager.getInstance();

    private static final Logger logger = LoggerLoader.getLogger(FailfastCluster.class);

    @Override
    public InvocationResponse invoke(ServiceInvocationHandler handler, InvokerContext invocationContext)
            throws Throwable {
        InvokerConfig&lt;?&gt; invokerConfig = invocationContext.getInvokerConfig();
        InvocationRequest request = InvokerUtils.createRemoteCallRequest(invocationContext, invokerConfig);
        //æ˜¯å¦è¶…æ—¶é‡è¯•
        boolean timeoutRetry = invokerConfig.isTimeoutRetry();
        if (!timeoutRetry) {
            //æŒ‰è´Ÿè½½å‡è¡¡ç­–ç•¥è·å–æœåŠ¡ç«¯è¿æ¥å®ä¾‹
            Client remoteClient = clientManager.getClient(invokerConfig, request, null);
            invocationContext.setClient(remoteClient);
            try {
                return handler.handle(invocationContext);
            } catch (NetworkException e) {
                //ç½‘ç»œå¼‚å¸¸é‡è¯•
                remoteClient = clientManager.getClient(invokerConfig, request, null);
                invocationContext.setClient(remoteClient);
                return handler.handle(invocationContext);
            }
        } else {
            //é‡è¯•æ¬¡æ•°
            int retry = invokerConfig.getRetries(invocationContext.getMethodName());
            RequestTimeoutException lastError = null;
            int maxInvokeTimes = retry + 1;
            int invokeTimes = 0;
            for (int index = 0; index &lt; maxInvokeTimes; index++) {
                Client clientSelected = null;
                try {
                    clientSelected = clientManager.getClient(invokerConfig, request, null);
                } catch (ServiceUnavailableException e) {
                    if (invokeTimes &gt; 0) {
                        logger.error(&quot;Invoke method[&quot; + invocationContext.getMethodName() + &quot;] on service[&quot;
                                + invokerConfig.getUrl() + &quot;] failed with &quot; + invokeTimes + &quot; times&quot;);
                        throw lastError;
                    } else {
                        throw e;
                    }
                }
                try {
                    invokeTimes++;
                    invocationContext.setClient(clientSelected);
                    InvocationResponse response = null;
                    try {
                        response = handler.handle(invocationContext);
                    } catch (NetworkException e) {
                        clientSelected = clientManager.getClient(invokerConfig, request, null);
                        invocationContext.setClient(clientSelected);
                        response = handler.handle(invocationContext);
                        logger.info(&quot;Retry while network exception:&quot; + e.getMessage());
                    }

                    if (lastError != null) {
                        logger.warn(&quot;Retry method[&quot; + invocationContext.getMethodName() + &quot;] on service[&quot;
                                + invokerConfig.getUrl() + &quot;] succeed after &quot; + invokeTimes
                                + &quot; times, last failed error: &quot; + lastError.getMessage(), lastError);
                    }
                    return response;
                } catch (RequestTimeoutException e) {
                    lastError = e;
                }
            }
            if (lastError != null) {
                throw lastError;
            } else {
                throw new RemoteInvocationException(
                        &quot;Invoke method[&quot; + invocationContext.getMethodName() + &quot;] on service[&quot; + invokerConfig.getUrl()
                                + &quot;] failed with &quot; + invokeTimes + &quot; times, last error: &quot;
                                + (lastError != null ? lastError.getMessage() : &quot;&quot;),
                        lastError != null &amp;&amp; lastError.getCause() != null ? lastError.getCause() : lastError);
            }
        }
    }

    @Override
    public String getName() {
        return Constants.CLUSTER_FAILFAST;
    }

}

FailoverCluster:

/**
 * å¤±è´¥è‡ªåŠ¨åˆ‡æ¢ï¼Œé‡è¯•å…¶ä»–æœåŠ¡å™¨
 */
public class FailoverCluster implements Cluster {

    private ClientManager clientManager = ClientManager.getInstance();

    private static final Logger logger = LoggerLoader.getLogger(FailoverCluster.class);

    @Override
    public InvocationResponse invoke(final ServiceInvocationHandler handler, final InvokerContext invocationContext)
            throws Throwable {
        InvokerConfig&lt;?&gt; invokerConfig = invocationContext.getInvokerConfig();
        List&lt;Client&gt; selectedClients = new ArrayList&lt;Client&gt;();
        Throwable lastError = null;
        int retry = invokerConfig.getRetries(invocationContext.getMethodName());
        //æœ€å¤§é‡è¯•æ¬¡æ•°
        int maxInvokeTimes = retry + 1;
        //æ˜¯å¦å…è®¸è¶…æ—¶é‡è¯•
        boolean timeoutRetry = invokerConfig.isTimeoutRetry();
        int invokeTimes = 0;
        for (int index = 0; index &lt; maxInvokeTimes; index++) {
            InvocationRequest request = InvokerUtils.createRemoteCallRequest(invocationContext, invokerConfig);
            Client clientSelected = null;
            try {
                clientSelected = clientManager.getClient(invokerConfig, request, selectedClients);
            } catch (ServiceUnavailableException e) {
                if (invokeTimes &gt; 0) {
                    logger.error(&quot;Invoke method[&quot; + invocationContext.getMethodName() + &quot;] on service[&quot;
                            + invokerConfig.getUrl() + &quot;] failed with &quot; + invokeTimes + &quot; times&quot;);
                    throw lastError;
                } else {
                    throw e;
                }
            }
            //è®°å½•ä½¿ç”¨è¿‡çš„é›†ç¾¤client
            selectedClients.add(clientSelected);
            try {
                //è®°å½•è°ƒç”¨æ¬¡æ•°
                invokeTimes++;
                invocationContext.setClient(clientSelected);
                InvocationResponse response = handler.handle(invocationContext);
                if (lastError != null) {
                    logger.warn(
                            &quot;Retry method[&quot; + invocationContext.getMethodName() + &quot;] on service[&quot;
                                    + invokerConfig.getUrl() + &quot;] succeed after &quot; + invokeTimes
                                    + &quot; times, last failed error: &quot; + lastError.getMessage(), lastError);
                }
                return response;
            } catch (Throwable e) {
                //è¶…æ—¶å¼‚å¸¸
                lastError = e;
                if (e instanceof RequestTimeoutException) {
                    //å¦‚æœä¸å…è®¸é‡è¯• ç›´æ¥æŠ›å‡ºå¼‚å¸¸
                    if (!timeoutRetry) {
                        throw e;
                    }
                }
            }
        }
        if (lastError != null) {
            logger.error(&quot;Invoke method[&quot; + invocationContext.getMethodName() + &quot;] on service[&quot;
                    + invokerConfig.getUrl() + &quot;] failed with &quot; + invokeTimes + &quot; times&quot;);
            throw lastError;
        } else {
            throw new RemoteInvocationException(&quot;Invoke method[&quot; + invocationContext.getMethodName() + &quot;] on service[&quot;
                    + invokerConfig.getUrl() + &quot;] failed with &quot; + invokeTimes + &quot; times, last error: &quot;
                    + (lastError != null ? lastError.getMessage() : &quot;&quot;), lastError != null
                    &amp;&amp; lastError.getCause() != null ? lastError.getCause() : lastError);
        }
    }

    @Override
    public String getName() {
        return Constants.CLUSTER_FAILOVER;
    }

}


FailsafeCluster
/**
 * å®‰å…¨å¤±è´¥ç­–ç•¥-å¤±è´¥å¿½ç•¥å¼‚å¸¸
 */
public class FailsafeCluster implements Cluster {

    private ClientManager clientManager = ClientManager.getInstance();

    private static final Logger logger = LoggerLoader.getLogger(FailsafeCluster.class);

    private static final InvocationResponse NO_RETURN_RESPONSE = InvokerUtils.createNoReturnResponse();

    @Override
    public InvocationResponse invoke(final ServiceInvocationHandler handler, final InvokerContext invocationContext)
            throws Throwable {
        InvokerConfig&lt;?&gt; invokerConfig = invocationContext.getInvokerConfig();
        InvocationRequest request = InvokerUtils.createRemoteCallRequest(invocationContext, invokerConfig);
        try {
            Client remoteClient = clientManager.getClient(invokerConfig, request, null);
            invocationContext.setClient(remoteClient);
            return handler.handle(invocationContext);
        } catch (Throwable t) {
            logger.error(&quot;&quot;, t);
            //è¿”å›ç©ºå¯¹è±¡
            return NO_RETURN_RESPONSE;
        }
    }

    @Override
    public String getName() {
        return Constants.CLUSTER_FAILSAFE;
    }

}

ForkingClusterï¼š

/**
 * å¹¶è¡Œè°ƒç”¨å¤šä¸ªæœåŠ¡ï¼Œä¸€ä¸ªæˆåŠŸç«‹å³è¿”å›
 */
public class ForkingCluster implements Cluster {

    private ClientManager clientManager = ClientManager.getInstance();
    private static final Logger logger = LoggerLoader.getLogger(ForkingCluster.class);
    private final ExecutorService executor = Executors
            .newCachedThreadPool(new NamedThreadFactory(&quot;Pigeon-Client-Fork-Processor&quot;, true));
    //èŠ‚ç‚¹æ•°
    private static final String KEY_FORKING_SIZE = &quot;pigeon.invoker.forking.size&quot;;
    private Random r = new Random();

    public ForkingCluster() {
        ConfigManagerLoader.getConfigManager().getIntValue(KEY_FORKING_SIZE, 0);
    }

    private List&lt;Client&gt; randomList(List&lt;Client&gt; clients) {
        List&lt;Client&gt; randomClients = clients;
        int size = ConfigManagerLoader.getConfigManager().getIntValue(KEY_FORKING_SIZE, 0);
        //3
        int len = clients.size();
        if (size &gt; 0 &amp;&amp; size &lt; len) {
            randomClients = new ArrayList&lt;Client&gt;(size);
            //ç”Ÿæˆä¸€ä¸ª0åˆ°len-1çš„æ•´å‹éšæœºæ•°
            int startIndex = (int) (r.nextDouble() * len);
            //ä»éšæœºæ•°å¼€å§‹ï¼Œèµ åºé€‰å–æ•°ç»„ä¸­çš„è¿æ¥
            for (int i = startIndex; i &lt; startIndex + size; i++) {
                //å¦‚æœè¶…è¿‡äº†æ•°ç»„çš„é•¿åº¦ï¼Œåˆ™ä»å¤´å–èµ·ï¼Œç›®çš„æ˜¯ä¸ºäº†éšæœº
                int idx = i &lt; len ? i : (i - len);
                randomClients.add(clients.get(idx));
            }
        }
        //å¦‚æœforksizeå¤§äºå®¢æˆ·ç«¯size è°ƒç”¨æ‰€æœ‰çš„
        return randomClients;
    }

    @Override
    public InvocationResponse invoke(final ServiceInvocationHandler handler, final InvokerContext invocationContext)
            throws Throwable {
        final InvokerConfig&lt;?&gt; invokerConfig = invocationContext.getInvokerConfig();
        InvocationRequest request = InvokerUtils.createRemoteCallRequest(invocationContext, invokerConfig);
        final List&lt;Client&gt; clients = clientManager.getAvailableClients(invokerConfig, request);
        final AtomicInteger count = new AtomicInteger();
        //é˜»å¡é˜Ÿåˆ—ç¼“å­˜ç»“æœ
        final BlockingQueue&lt;Object&gt; ref = new LinkedBlockingQueue&lt;Object&gt;();
        //è·å–éšæœºçš„client
        final List&lt;Client&gt; selectedClients = randomList(clients);
        for (final Client client : selectedClients) {
            executor.execute(new Runnable() {
                public void run() {
                    InvokerContext ctxt = new DefaultInvokerContext(invokerConfig, invocationContext.getMethodName(),
                            invocationContext.getParameterTypes(), invocationContext.getArguments());
                    ctxt.setClient(client);
                    ctxt.setRequest(null);
                    ctxt.setRequest(InvokerUtils.createRemoteCallRequest(ctxt, invokerConfig));
                    try {
                        InvocationResponse resp = handler.handle(ctxt);
                        //å‘å µå¡é˜Ÿåˆ—å¡å…¥ç»“æœ
                        ref.offer(resp);
                    } catch (Throwable e) {
                        int value = count.incrementAndGet();
                        if (value &gt;= selectedClients.size()) {
                            ref.offer(e);
                        }
                    }
                }
            });
        }
        Object ret = null;
        //é…ç½®è¶…æ—¶æ—¶é—´ï¼Œè·å–è¶…æ—¶æ—¶é—´å†…å µå¡è¯·æ±‚
        if (request.getTimeout() &gt; 0) {
            ret = ref.poll(request.getTimeout(), TimeUnit.MILLISECONDS);
        } else {
            //å µå¡ç­‰å¾…ç›´åˆ°æœ‰è¯·æ±‚å®Œæˆ
            ret = ref.take();
        }
        if (ret instanceof Throwable) {
            throw (Throwable) ret;
        } else if ((ret instanceof FutureResponse)
                &amp;&amp; CallMethod.isFuture(invokerConfig.getCallType())) {
            //å¦‚æœæ˜¯futureå“åº”åˆ™è®¾ç½®ç›¸å…³future
            FutureFactory.setFuture(((FutureResponse) ret).getServiceFuture());
        } else if (ret == null) {
            throw InvocationUtils.newTimeoutException(&quot;timeout while waiting forking response:&quot; + request);
        }
        return (InvocationResponse) ret;
    }

    @Override
    public String getName() {
        return Constants.CLUSTER_FORKING;
    }

}


4.1.2 æœåŠ¡çº¿ç¨‹æ± éš”ç¦»
çº¿ç¨‹æ± é…ç½®æ”¯æŒæœåŠ¡ï¼ˆå•ä¸ªç±»ï¼‰çº§åˆ«ä¸æ–¹æ³•çº§åˆ«é…ç½®

å¦‚æœæœåŠ¡æœ‰çº¿ç¨‹æ± é…ç½®ï¼Œä¼šåœ¨æœåŠ¡æ³¨å†Œçš„æ—¶å€™å°±å°†ç›¸å…³çš„çº¿ç¨‹æ± åˆ›å»ºå¥½ï¼Œçº¿ç¨‹æ± è§„åˆ™å¦‚æœä¸é…ç½®éƒ½æ˜¯é»˜è®¤å…±äº«çº¿ç¨‹æ± ã€‚

çº¿ç¨‹æ± æœ‰åŠ¨æ€å’ŒéåŠ¨æ€çš„åŒºåˆ†,åŠ¨æ€çš„æ”¯æŒé…ç½®ä¸­å¿ƒä¿®æ”¹ï¼Œç„¶åç›‘å¬å˜åŠ¨refreshçº¿ç¨‹æ± é…ç½®

public class NettyServerHandler extends SimpleChannelUpstreamHandler {
    private static final Logger log = LoggerLoader.getLogger(NettyServerHandler.class);
    private NettyServer server;
    public NettyServerHandler(NettyServer server) {
        this.server = server;
    }
    @Override
    public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e) throws Exception {
        if (log.isDebugEnabled()) {
            if (e instanceof ChannelStateEvent &amp;&amp; ((ChannelStateEvent) e).getState() != ChannelState.INTEREST_OPS) {
                log.debug(e.toString());
            }
        }
        super.handleUpstream(ctx, e);
    }

    /**
     * æœåŠ¡å™¨ç«¯æ¥å—åˆ°æ¶ˆæ¯å¼€å§‹å¤„ç†
     *
     * @see org.jboss.netty.channel.SimpleChannelUpstreamHandler#messageReceived(org.jboss.netty.channel.ChannelHandlerContext,
     * org.jboss.netty.channel.MessageEvent)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void messageReceived(ChannelHandlerContext ctx, MessageEvent message) {
        CodecEvent codecEvent = (CodecEvent) (message.getMessage());

        if (!codecEvent.isValid() || codecEvent.getInvocation() == null) {
            return;
        }
        InvocationRequest request = (InvocationRequest) codecEvent.getInvocation();
        ProviderContext invocationContext = new DefaultProviderContext(request, new NettyServerChannel(ctx.getChannel()));
        try {
            //å¼‚æ­¥è°ƒç”¨
            this.server.processRequest(request, invocationContext);
        } catch (Throwable e) {
            String msg = &quot;process request failed:&quot; + request;
            // å¿ƒè·³æ¶ˆæ¯åªè¿”å›æ­£å¸¸çš„, å¼‚å¸¸ä¸è¿”å›
            if (request.getCallType() == Constants.CALLTYPE_REPLY
                    &amp;&amp; request.getMessageType() != Constants.MESSAGE_TYPE_HEART) {
                ctx.getChannel().write(ProviderUtils.createFailResponse(request, e));
            }
            log.error(msg, e);
        }
    }

    @Override
    public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) {
    }

    @Override
    public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) {
        this.server.getChannelGroup().add(e.getChannel());
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) {
        log.info(e.getCause().getMessage(), e.getCause());
        ctx.getChannel().close();
    }

}

    /**
     * server-å¹¶è¡Œå¤„ç†å™¨
     *
     * @param request
     * @param providerContext
     * @return
     */
    public Future&lt;InvocationResponse&gt; doProcessRequest(final InvocationRequest request,
                                                       final ProviderContext providerContext) {
        requestContextMap.put(request, providerContext);
        startMonitorData(request, providerContext);
        Callable&lt;InvocationResponse&gt; requestExecutor = new Callable&lt;InvocationResponse&gt;() {
            @Override
            public InvocationResponse call() throws Exception {
                providerContext.getTimeline().add(new TimePoint(TimePhase.T));
                try {
                    //æ ¹æ®é“¾è·¯è¯·æ±‚
                    ServiceInvocationHandler invocationHandler = ProviderProcessHandlerFactory
                            .selectInvocationHandler(providerContext.getRequest().getMessageType());
                    if (invocationHandler != null) {
                        providerContext.setThread(Thread.currentThread());
                        return invocationHandler.handle(providerContext);
                    }
                } catch (Throwable t) {
                    logger.error(&quot;Process request failed with invocation handler, you should never be here.&quot;, t);
                } finally {
                    requestContextMap.remove(request);
                }
                return null;
            }
        };
        //é€‰æ‹©çº¿ç¨‹æ± 
        final ThreadPool pool = selectThreadPool(request);

        try {
            checkRequest(pool, request);
            providerContext.getTimeline().add(new TimePoint(TimePhase.T));
            //çº¿ç¨‹æ± å» æ‰§è¡Œ
            return pool.submit(requestExecutor);
        } catch (RejectedExecutionException e) {
            requestContextMap.remove(request);
            endMonitorData(request, providerContext);
            throw new RejectedException(getProcessorStatistics(pool), e);
        }

    }



private ThreadPool selectThreadPool(final InvocationRequest request) {
        ThreadPool pool = null;
        String serviceKey = request.getServiceName();
        String methodKey = serviceKey + &quot;#&quot; + request.getMethodName();

        // spring poolConfig
        pool = getConfigThreadPool(request);

        // æ–¹æ³•çº§åˆ«é…ç½®
        if (pool == null &amp;&amp; !CollectionUtils.isEmpty(methodThreadPools)) {
            pool = methodThreadPools.get(methodKey);
        }
        // æœåŠ¡çº§åˆ«é…ç½®
        if (pool == null &amp;&amp; !CollectionUtils.isEmpty(serviceThreadPools)) {
            pool = serviceThreadPools.get(serviceKey);
        }

        // å¼€å¯åŠ¨æ€çº¿ç¨‹æ± å°†è·å–åŠ¨æ€çº¿ç¨‹æ± 
        if (pool == null &amp;&amp; poolConfigSwitchable &amp;&amp; !CollectionUtils.isEmpty(apiPoolNameMapping)) {
            PoolConfig poolConfig = null;
            String poolName = apiPoolNameMapping.get(methodKey);
            if (StringUtils.isNotBlank(poolName)) { // æ–¹æ³•çº§åˆ«
                poolConfig = poolConfigs.get(poolName);
                if (poolConfig != null) {
                    pool = DynamicThreadPoolFactory.getThreadPool(poolConfig);
                }
            } else { //æœåŠ¡çº§åˆ«
                poolName = apiPoolNameMapping.get(serviceKey);
                if (StringUtils.isNotBlank(poolName)) {
                    poolConfig = poolConfigs.get(poolName);
                    if (poolConfig != null) {
                        pool = DynamicThreadPoolFactory.getThreadPool(poolConfig);
                    }
                }
            }
        }

        // é»˜è®¤æ–¹å¼
        if (pool == null) {
            // é’ˆå¯¹æ…¢è¯·æ±‚ï¼Œä¸ºå…¶é€‰æ‹©ç›¸åº”çš„çº¿ç¨‹æ± 
            if (enableSlowPool &amp;&amp; requestTimeoutListener.isSlowRequest(request)) {
                pool = slowRequestProcessThreadPool;
            } else {
                //å…±äº«çº¿ç¨‹æ± 
                pool = sharedRequestProcessThreadPool;
            }
        }
        return pool;
    }
</code></pre><p>äº”ã€åç»­æƒ³ä»‹ç»çš„<br>1ã€ç‚¹è¯„pigeonä¸é˜¿é‡Œdubbo RPCæ¡†æ¶ä»‹ç»ä¸æ ¸å¿ƒæºç åˆ†äº«</p>
<p>2ã€RCPæ¡†æ¶ä¸ºäº†æé«˜qpsçš„ä¸€äº›ä¼˜åŒ–</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ç¾å›¢ç‚¹è¯„/" rel="tag"># ç¾å›¢ç‚¹è¯„</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/15/happens-beforeè®°å½•/" rel="next" title="happens-beforeè®°å½•">
                <i class="fa fa-chevron-left"></i> happens-beforeè®°å½•
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/21/webå®‰å…¨è®°å½•/" rel="prev" title="webå®‰å…¨è®°å½•">
                webå®‰å…¨è®°å½• <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            æ–‡ç« ç›®å½•
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            ç«™ç‚¹æ¦‚è§ˆ
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatar.csdnimg.cn/1/E/3/ggj20ss.jpg"
               alt="ggj2010" />
          <p class="site-author-name" itemprop="name">ggj2010</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">42</span>
                <span class="site-state-item-name">æ—¥å¿—</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">åˆ†ç±»</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">æ ‡ç­¾</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ggj2010" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/ggjlvzjy" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#çŸ­é“¾æ¥æœåŠ¡"><span class="nav-number">1.</span> <span class="nav-text">çŸ­é“¾æ¥æœåŠ¡</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ç»Ÿä¸€ç”µè¯åŠ å¯†æœåŠ¡"><span class="nav-number">2.</span> <span class="nav-text">ç»Ÿä¸€ç”µè¯åŠ å¯†æœåŠ¡</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#èƒŒæ™¯"><span class="nav-number">2.1.</span> <span class="nav-text">èƒŒæ™¯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ç³»ç»Ÿç›®æ ‡"><span class="nav-number">2.2.</span> <span class="nav-text">ç³»ç»Ÿç›®æ ‡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#æ ¸å¿ƒæµç¨‹"><span class="nav-number">2.3.</span> <span class="nav-text">æ ¸å¿ƒæµç¨‹</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#çŸ­ä¿¡æœåŠ¡"><span class="nav-number">3.</span> <span class="nav-text">çŸ­ä¿¡æœåŠ¡</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ç›¸å…³æ¦‚å¿µ"><span class="nav-number">3.1.</span> <span class="nav-text">ç›¸å…³æ¦‚å¿µ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#æ’å…¥çŸ­ä¿¡"><span class="nav-number">3.2.</span> <span class="nav-text">æ’å…¥çŸ­ä¿¡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#æ ¸å¿ƒç‚¹"><span class="nav-number">3.3.</span> <span class="nav-text">æ ¸å¿ƒç‚¹</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#craneå®šæ—¶ä»»åŠ¡"><span class="nav-number">4.</span> <span class="nav-text">craneå®šæ—¶ä»»åŠ¡</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cornè¡¨è¾¾å¼è®°å½•"><span class="nav-number">4.1.</span> <span class="nav-text">cornè¡¨è¾¾å¼è®°å½•</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#docker-job"><span class="nav-number">4.2.</span> <span class="nav-text">docker-job</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#è¿›ç¨‹å†…job"><span class="nav-number">4.3.</span> <span class="nav-text">è¿›ç¨‹å†…job</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RPC"><span class="nav-number">5.</span> <span class="nav-text">RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ä¸€ã€RPCæ¡†æ¶çš„ä»·å€¼"><span class="nav-number">5.1.</span> <span class="nav-text">ä¸€ã€RPCæ¡†æ¶çš„ä»·å€¼</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#äºŒã€RPCå…³é”®è¯"><span class="nav-number">5.2.</span> <span class="nav-text">äºŒã€RPCå…³é”®è¯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ä¸‰ã€é€’è¿›æ‰‹å†™RPC"><span class="nav-number">5.3.</span> <span class="nav-text">ä¸‰ã€é€’è¿›æ‰‹å†™RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-å…¥é—¨çº§åˆ«"><span class="nav-number">5.3.1.</span> <span class="nav-text">3.1 å…¥é—¨çº§åˆ«</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-å¼‚æ­¥è°ƒç”¨"><span class="nav-number">5.3.2.</span> <span class="nav-text">3.2 å¼‚æ­¥è°ƒç”¨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-åŸºäºzkå®ç°æ³¨å†Œä¸­å¿ƒ"><span class="nav-number">5.3.3.</span> <span class="nav-text">3.4 åŸºäºzkå®ç°æ³¨å†Œä¸­å¿ƒ</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ggj2010</span>
</div>


<div class="powered-by">
  ç”± <a class="theme-link" href="https://hexo.io">Hexo</a> å¼ºåŠ›é©±åŠ¨
</div>

<div class="theme-info">
  ä¸»é¢˜ -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
