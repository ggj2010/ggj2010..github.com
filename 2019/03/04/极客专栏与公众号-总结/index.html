<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="10x程序员工作法https://time.geekbang.org/column/article/73980 程序员解决的问题，大多不是程序问题本质复杂度与偶然复杂度，大部分情况下导致忙碌都是偶然复杂度 简单来说，本质复杂度就是解决一个问题时，无论怎么做都必须要做， 而偶然复杂度是因为选用的做事方法不当，而导致要多做的事。 如果避免可以坚守以下四个原则 1、以终为始 2、任务分解 3、沟通反馈">
<meta property="og:type" content="article">
<meta property="og:title" content="极客专栏与公众号-总结">
<meta property="og:url" content="http://ggj2010.github.io/2019/03/04/极客专栏与公众号-总结/index.html">
<meta property="og:site_name" content="高广金博客">
<meta property="og:description" content="10x程序员工作法https://time.geekbang.org/column/article/73980 程序员解决的问题，大多不是程序问题本质复杂度与偶然复杂度，大部分情况下导致忙碌都是偶然复杂度 简单来说，本质复杂度就是解决一个问题时，无论怎么做都必须要做， 而偶然复杂度是因为选用的做事方法不当，而导致要多做的事。 如果避免可以坚守以下四个原则 1、以终为始 2、任务分解 3、沟通反馈">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/65/29/65cef2c44480910871a0b66cac1d5529.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/f3/e1/f34823ce42a49e4eadaf642a75d14de1.png">
<meta property="og:updated_time" content="2021-01-22T09:21:55.665Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="极客专栏与公众号-总结">
<meta name="twitter:description" content="10x程序员工作法https://time.geekbang.org/column/article/73980 程序员解决的问题，大多不是程序问题本质复杂度与偶然复杂度，大部分情况下导致忙碌都是偶然复杂度 简单来说，本质复杂度就是解决一个问题时，无论怎么做都必须要做， 而偶然复杂度是因为选用的做事方法不当，而导致要多做的事。 如果避免可以坚守以下四个原则 1、以终为始 2、任务分解 3、沟通反馈">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/65/29/65cef2c44480910871a0b66cac1d5529.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ggj2010.github.io/2019/03/04/极客专栏与公众号-总结/"/>





  <title> 极客专栏与公众号-总结 | 高广金博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">高广金博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-webmagic">
          <a href="http://scedai.com/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            爬虫
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ggj2010.github.io/2019/03/04/极客专栏与公众号-总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ggj2010">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatar.csdnimg.cn/1/E/3/ggj20ss.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高广金博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                极客专栏与公众号-总结
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-04T23:25:59+08:00">
                2019-03-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="10x程序员工作法"><a href="#10x程序员工作法" class="headerlink" title="10x程序员工作法"></a>10x程序员工作法</h1><p><a href="https://time.geekbang.org/column/article/73980" target="_blank" rel="external">https://time.geekbang.org/column/article/73980</a></p>
<h2 id="程序员解决的问题，大多不是程序问题"><a href="#程序员解决的问题，大多不是程序问题" class="headerlink" title="程序员解决的问题，大多不是程序问题"></a>程序员解决的问题，大多不是程序问题</h2><pre><code>本质复杂度与偶然复杂度，大部分情况下导致忙碌都是偶然复杂度
简单来说，本质复杂度就是解决一个问题时，无论怎么做都必须要做，
而偶然复杂度是因为选用的做事方法不当，而导致要多做的事。
如果避免可以坚守以下四个原则
1、以终为始
2、任务分解
3、沟通反馈
4、自动化
</code></pre><h2 id="程序员是如何思考"><a href="#程序员是如何思考" class="headerlink" title="程序员是如何思考"></a>程序员是如何思考</h2><pre><code>优秀程序员的开发效率是普通程序员的 10 倍
思考框架
我现在是个什么水平：高级开发
我想达到什么水平：技术leader
我将怎样到达那个目标：管理书籍，理论与实践
四个思考原则
1、为什么要做这个特性，它会给用户带来怎样的价值？
2、什么样的用户会用到这个特性，他们在什么场景下使用，他们又会怎样使用它？
3、达成这个目的是否有其它手段？是不是一定要开发一个系统？
4、这个特性上线之后，怎么衡量它的有效性？
</code></pre><h2 id="以终为始"><a href="#以终为始" class="headerlink" title="以终为始"></a>以终为始</h2><pre><code>一种反直觉的思维方式
    就是在做事之前，先想想结果是什么样子的
想象的共同体
    任何事物都要经过两次创造：一次是在头脑中的创造，也就是智力上的或者第一次创造（Mental/First Creation），
    然后才是付诸实践，也就是实际的构建或第二次创造（Physical/Second Creation）。
    对做软件的人来说，我们应该把“终”定位成做一个对用户有价值的软件，能够为别人带来价值，自己的价值才能体现出来。
“以终为始”的方式，不仅仅可以帮我们规划工作，还可以帮我们发现工作中的问题。

 遇到事情，倒着想。
</code></pre><h2 id="你完成了工作，为什么他们还不满意？"><a href="#你完成了工作，为什么他们还不满意？" class="headerlink" title="你完成了工作，为什么他们还不满意？"></a>你完成了工作，为什么他们还不满意？</h2><pre><code>理解的鸿沟
DoD（Definition of Done，完成的定义）
DoD 是一个清单，清单是由一个个的检查项组成的，用来检查我们的工作完成情况。
DoD 的检查项应该是实际可检查的。
DoD 是团队成员间彼此汇报的一种机制。

在做任何事之前，先定义完成的标准
</code></pre><h2 id="接到需求任务，你要先做哪件事"><a href="#接到需求任务，你要先做哪件事" class="headerlink" title="接到需求任务，你要先做哪件事"></a>接到需求任务，你要先做哪件事</h2><pre><code>需求描述的问题
验收标准给出了这个需求最基本的测试用例，它保证了开发人员完成需求最基本的质量。
扮演不同角色的时候，我们的思考模式是不同的。
在做任何需求或任务之前，先定好验收标准。
</code></pre><h2 id="持续集成：集成本身就是写代码的一个环节"><a href="#持续集成：集成本身就是写代码的一个环节" class="headerlink" title="持续集成：集成本身就是写代码的一个环节"></a>持续集成：集成本身就是写代码的一个环节</h2><pre><code>写代码是程序员的职责，但我们更有义务交付一个可运行的软件
虽然我们在同一个时代写代码做开发，但在技术实践层面，不同的团队却仿佛生活在不同的年代。
</code></pre><h2 id="精益创业：产品经理不靠谱，你该怎么办？"><a href="#精益创业：产品经理不靠谱，你该怎么办？" class="headerlink" title="精益创业：产品经理不靠谱，你该怎么办？"></a>精益创业：产品经理不靠谱，你该怎么办？</h2><pre><code>精益创业的方法论里，怎么试呢？试就要有试的方法。精益创业的方法论里，提出“开发（build）- 测量（measure）- 认知（learn）”
这样一个反馈循环。就是说，当你有了一个新的想法（idea）时，就把想法开发成产品（code）投入市场，然后，
收集数据（data）获取反馈，看看前面的想法是不是靠谱。
最小可行产品，也就是许多人口中的 MVP（Minimum Viable Product）

比如，你要做这个产品特性，
你要验证的东西是什么呢？
他要验证的目标是否有数据可以度量呢？
要解决的这个问题是不是当前最重要的事情，是否还有其他更重要的问题呢？

默认所有需求都不做，直到弄清楚为什么要做这件事
</code></pre><h2 id="解决了很多技术问题，为什么你依然在“坑”里？"><a href="#解决了很多技术问题，为什么你依然在“坑”里？" class="headerlink" title="解决了很多技术问题，为什么你依然在“坑”里？"></a>解决了很多技术问题，为什么你依然在“坑”里？</h2><pre><code>“独善其身”不是好事
虽然写的代码都一样，但你看到的是树木，人家看到的是森林，他更能从全局思考。
我并不是靠技术能力解决了问题，而是凭借对需求的理解把这个问题绕过去了。
而能想到问这样的问题，前提就是要跳出程序员角色思维，扩大自己工作的上下文。

扩大自己工作的上下文，别把自己局限在一个“程序员”的角色上
</code></pre><h2 id="为什么说做事之前要先进行推演"><a href="#为什么说做事之前要先进行推演" class="headerlink" title="为什么说做事之前要先进行推演"></a>为什么说做事之前要先进行推演</h2><pre><code>对比我们的工作，多数情况下，即便目标清晰，路径却是模糊的。
在我们做软件的过程中，这两种路径所带来的差异，已经在前面的小故事里体现出来了。
一种是前期其乐融融，后期手忙脚乱；
一种是前面思前想后，后面四平八稳。我个人是推崇后一种做法的。
在动手做一件事之前，先推演一番
</code></pre><h2 id="你的工作可以用数字衡量吗？"><a href="#你的工作可以用数字衡量吗？" class="headerlink" title="你的工作可以用数字衡量吗？"></a>你的工作可以用数字衡量吗？</h2><pre><code>从数字中发现问题，让系统更稳定。
从数字上看，好的系统应该是“死水一潭”。
cat监控、埋点 在点评时候每天上班第一件事就是看监控面板
问一下自己，我的工作是不是可以用数字衡量
</code></pre><h2 id="迭代0-启动开发之前，你应该准备什么"><a href="#迭代0-启动开发之前，你应该准备什么" class="headerlink" title="迭代0: 启动开发之前，你应该准备什么"></a>迭代0: 启动开发之前，你应该准备什么</h2><pre><code>迭代0：具体内容只是基本的清单
迭代1：细化过的迭代需求
根据优先级从中挑出迭代 1 要开发的需求，优先级是根据我们要完成的最小可行产品（minimum viable product，MVP）来确定的，
这个最小可行产品又是由我们在这个迭代里要验证的内容决定的。一环扣一环，我们就得到了迭代1要做的需求列表
用户界面和用户交互（视觉和交互）
1. 基本技术准备
基础技术选型和技术架构
持续集成（构建脚本，多分支代码合并，代码规范，单元测试覆盖率检查）
2. 发布准备
详细上线计划，回滚方案，

设计你的迭代 0 清单，给自己的项目做体检
</code></pre><h2 id="答疑解惑-如何管理你的上级"><a href="#答疑解惑-如何管理你的上级" class="headerlink" title="答疑解惑 | 如何管理你的上级"></a>答疑解惑 | 如何管理你的上级</h2><pre><code>对上级不合理的要求说“不”，这是一个思想上的转变。很多人受到传统官本位思想的影响，对上级的服从达到了不健康的程度。
勇于改变，是有效管理上级的前提条件。如果不从思想上转变，我接下来的建议都是没有价值的。
</code></pre><h3 id="问题-1：领导要求的，无力反驳怎么办？"><a href="#问题-1：领导要求的，无力反驳怎么办？" class="headerlink" title="问题 1：领导要求的，无力反驳怎么办？"></a>问题 1：领导要求的，无力反驳怎么办？</h3><pre><code>第一，管理上级的预期
这个过程，相当于我把自己看到的问题暴露给上级，让他选择。
第二，帮助上级丰富知识
第三，说出你的想法
</code></pre><h3 id="问题-2：产品经理总拿老板说事，怎么办？"><a href="#问题-2：产品经理总拿老板说事，怎么办？" class="headerlink" title="问题 2：产品经理总拿老板说事，怎么办？"></a>问题 2：产品经理总拿老板说事，怎么办？</h3><pre><code>不合理的部分应该是他和老板去沟通的，而不是让开发团队来实现
</code></pre><h3 id="问题-3：别人能做的，我们也要做"><a href="#问题-3：别人能做的，我们也要做" class="headerlink" title="问题 3：别人能做的，我们也要做"></a>问题 3：别人能做的，我们也要做</h3><pre><code>抄”不是问题，问题是无脑地抄

竞争对手有这个特性，他为什么要做？他做这个特性与它其他特性是怎么配合的？
我们做这个特性，在我们的产品里怎样发挥价值？
即便我们最终的结果是，做的与竞争对手一模一样，经过思考之后的“抄袭”也是一件价值更大的事。

要做什么是需求，怎么做是技术。与产品经理要确认的是，这个需求是不是合理，该不该做。
技术上能否实现，这是开发团队要考虑的事情，并不是产品经理说事的理由。
</code></pre><h2 id="向埃隆·马斯克学习任务分解"><a href="#向埃隆·马斯克学习任务分解" class="headerlink" title="向埃隆·马斯克学习任务分解"></a>向埃隆·马斯克学习任务分解</h2><pre><code>不同的可执行定义差别在于，你是否能清楚地知道这个问题该如何解决。
动手做一个工作之前，请先对它进行任务分解。
</code></pre><h2 id="测试也是程序员的事吗"><a href="#测试也是程序员的事吗" class="headerlink" title="测试也是程序员的事吗"></a>测试也是程序员的事吗</h2><pre><code>这种测试框架最大的价值，是把自动化测试作为一种最佳实践引入到开发过程中，使得测试动作可以通过标准化的手段固定下来。
不是用单元测试框架写的测试就是单元测试。
多写单元测试
</code></pre><h2 id="先写测试，就是测试驱动开发吗？"><a href="#先写测试，就是测试驱动开发吗？" class="headerlink" title="先写测试，就是测试驱动开发吗？"></a>先写测试，就是测试驱动开发吗？</h2><pre><code>TDD 测试驱动开发（Test Driven Development）
测试先行开发和测试驱动开发的差异就在重构上。
因为重构和测试的互相配合，它会驱动着你把代码写得越来越好。这是对“驱动”一词最粗浅的理解。
我的代码怎么写才是能测试的，也就是说，我们要编写具有可测试性

一个好的解决方案是尽量不写 static 方法
我们应该编写可测的代码
</code></pre><h2 id="大师级程序员的工作秘笈"><a href="#大师级程序员的工作秘笈" class="headerlink" title="大师级程序员的工作秘笈"></a>大师级程序员的工作秘笈</h2><pre><code>前面提到持续集成时，我们已经介绍过这个理念，如果集成是好的，我们就尽早集成，推向极限每一次修改都集成，这就是持续集成。
如果开发者测试是好的，我们就尽早测试，推向极限就是先写测试，再根据测试调整代码，这就是测试驱动开发。
如果代码评审是好的，我们就多做评审，推向极限就是随时随地地代码评审，这就是结对编程。
如果客户交流是好的，我们就和客户多交流，推向极限就是客户与开发团队时时刻刻在一起，这就是现场客户。

每当遇到一件要做的事，Kent Beck 总会先把它分解成几个小任务，记在一个清单上
，然后，才是动手写测试、写代码、重构这样一个小循环。
等一个循环完成了，他会划掉已经做完的任务，开始下一个。
</code></pre><p>   很多人看了一些 TDD 的练习觉得很简单，但自己动起手来却不知道如何下手。中间就是缺了任务分解的环节。<br>   一个经过分解后的任务，需要关注的内容是有限的，我们就可以针对着这个任务，把方方面面的细节想得更加清晰。</p>
<p>   主分支开发模式可以用到 Feature Toggle，也就是说在不改变代码逻辑的情况下，增加一些开关，来隐藏或者实现功能。</p>
<p>   将任务拆小，越小越好。!!!!</p>
<h2 id="一起练习：手把手带你分解任务"><a href="#一起练习：手把手带你分解任务" class="headerlink" title="一起练习：手把手带你分解任务"></a>一起练习：手把手带你分解任务</h2><pre><code>每做完一个任务，代码都是可以提交的
按照完整实现一个需求的顺序去安排分解出来的任务
</code></pre><h2 id="程序员也可以“砍”需求吗"><a href="#程序员也可以“砍”需求吗" class="headerlink" title="程序员也可以“砍”需求吗"></a>程序员也可以“砍”需求吗</h2><pre><code>INVEST 原则
Independent，独立的。
Negotiable，可协商的。
Valuable，有价值的。
</code></pre><h2 id="需求管理：太多人给你安排任务，怎么办"><a href="#需求管理：太多人给你安排任务，怎么办" class="headerlink" title="需求管理：太多人给你安排任务，怎么办"></a>需求管理：太多人给你安排任务，怎么办</h2><pre><code>艾森豪威尔矩阵
按照时间管理的理念，重要且紧急的事情要立即做。重要但不紧急的事情应该是我们重点投入精力的地方。
紧急但不重要的事情，可以委托别人做。不重要不紧急的事情，尽量少做。

如果不把精力放在重要的事情上，到最后可能都变成紧急的事情。
</code></pre><h2 id="为什么世界和你的理解不一样"><a href="#为什么世界和你的理解不一样" class="headerlink" title="为什么世界和你的理解不一样"></a>为什么世界和你的理解不一样</h2><pre><code>我们努力地学习各种知识，为的就是更好地理解这个世界的运作方式,而沟通反馈，就是我们与真实世界互动的最好方式。
这几乎是很多程序员讲东西的通病：讲东西直奔细节
</code></pre><h2 id="轻量级沟通：你总是在开会吗？"><a href="#轻量级沟通：你总是在开会吗？" class="headerlink" title="轻量级沟通：你总是在开会吗？"></a>轻量级沟通：你总是在开会吗？</h2><pre><code>1、所以，改善会议的第一个行动项是，减少参与讨论的人数。
2、如果你要讨论，找人面对面沟通
3、多面对面沟通，少开会
</code></pre><h2 id="可视化：一种更为直观的沟通方式"><a href="#可视化：一种更为直观的沟通方式" class="headerlink" title="可视化：一种更为直观的沟通方式"></a>可视化：一种更为直观的沟通方式</h2><pre><code>技术雷达  http://insights.thoughtworkers.org/
看板 敏捷开发
</code></pre><h2 id="快速反馈：为什么你们公司总是做不好持续集成"><a href="#快速反馈：为什么你们公司总是做不好持续集成" class="headerlink" title="快速反馈：为什么你们公司总是做不好持续集成"></a>快速反馈：为什么你们公司总是做不好持续集成</h2><pre><code>做好持续集成的关键在于，快速反馈。
</code></pre><h2 id="开发中的问题一再出现，应该怎么办"><a href="#开发中的问题一再出现，应该怎么办" class="headerlink" title="开发中的问题一再出现，应该怎么办"></a>开发中的问题一再出现，应该怎么办</h2><pre><code>复盘
回顾会议
5 个为什么
定期复盘，找准问题根因，不断改善
</code></pre><h2 id="尽早暴露问题：-为什么被指责的总是你"><a href="#尽早暴露问题：-为什么被指责的总是你" class="headerlink" title="尽早暴露问题： 为什么被指责的总是你"></a>尽早暴露问题： 为什么被指责的总是你</h2><pre><code>Fail Fast
事情往前做，有问题尽早暴露。
</code></pre><h2 id="你的代码是怎么变混乱的"><a href="#你的代码是怎么变混乱的" class="headerlink" title="你的代码是怎么变混乱的"></a>你的代码是怎么变混乱的</h2><pre><code>单一职责原则（Single responsibility principle，SRP）
开放封闭原则（Open–closed principle，OCP）
Liskov 替换原则（Liskov substitution principle，LSP）
接口隔离原则（Interface segregation principle，ISP）
依赖倒置原则（Dependency inversion principle，DIP）
如果说设计模式是“术”，设计原则才是“道”

单一职责原则可以用在不同的层面，写一个类，你可以问问这些方法是不是为一类 actor 服务；
写方法时，你可以问问这些代码是不是在一个层面上；甚至一个服务，也需要从业务上考虑一下，
它在提供是否一类的服务。总之，你看到的粒度越细，也就越能发现问题。
</code></pre><h2 id="面对遗留系统，你应该这样做"><a href="#面对遗留系统，你应该这样做" class="headerlink" title="面对遗留系统，你应该这样做"></a>面对遗留系统，你应该这样做</h2><pre><code>分清现象与根因
遗留系统和烂代码到底是不是问题呢？其实并不是，它们只是现象，不是原因
确定方案
先尝试重构你的代码，尽可能在已有代码上做小步调整，不要走到大规模改造的路上，因为重构的成本是最低的。
改造遗留系统，一个关键点就是，不要回到老路上
</code></pre><h2 id="我们应该如何保持竞争力"><a href="#我们应该如何保持竞争力" class="headerlink" title="我们应该如何保持竞争力"></a>我们应该如何保持竞争力</h2><pre><code>成为 T 型人！！！！
什么叫 T 型人？简言之，一专多能，知识的广度和专业能力的深度，这里的“专”不是熟练，而是深入
在学习区工作和成长

工作中不要满足当前需求，要经常从自己上级主管甚至老板角度来审视自己的工作，思考业务的终极目标，持续琢磨扩展边界，挑战工作难度
平时多看书多思考，除了钻研某个领域，还要多有涉猎，拓展领域，成为终身学习者。
适当运动维持健康，你有更多体力和更强抗压能力的时候，就可以超过不少人。
保持竞争力除了上述之外，要保持乐观，相信大多数事都有解决方法，在多数人都容易放弃的时候，你的坚持，就是竞争力。
</code></pre><h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><p>《敏捷软件开发：原则、实践与模式》<br>《架构整洁之道》<br>《测试驱动开发》<br>《The Practice of Programming》<br>《领域驱动设计精粹》<br>《分析模式》</p>
<p><a href="https://www.douban.com/doulist/112766085/" target="_blank" rel="external">https://www.douban.com/doulist/112766085/</a></p>
<h1 id="代码精进之路"><a href="#代码精进之路" class="headerlink" title="代码精进之路"></a>代码精进之路</h1><h2 id="从条件运算符说起，反思什么是好代码"><a href="#从条件运算符说起，反思什么是好代码" class="headerlink" title="从条件运算符说起，反思什么是好代码"></a>从条件运算符说起，反思什么是好代码</h2><pre><code>坚持使用最直观的编码方式，而不是追求代码简短
容易理解；
没有明显的安全问题；
能够满足最关键的需求；
有充分的注释；
使用规范的命名
</code></pre><h2 id="把错误关在笼子里"><a href="#把错误关在笼子里" class="headerlink" title="把错误关在笼子里"></a>把错误关在笼子里</h2><pre><code>1、提高程序员的修养
2、编译器
3、回归测试
4、代码评审
5、代码分析工具
</code></pre><h2 id="写好声明的“八项纪律”"><a href="#写好声明的“八项纪律”" class="headerlink" title="写好声明的“八项纪律”"></a>写好声明的“八项纪律”</h2><pre><code>一行一个声明
局部变量需要时再声明
类属性要集中声明
</code></pre><h2 id="怎么用好Java注解？"><a href="#怎么用好Java注解？" class="headerlink" title="怎么用好Java注解？"></a>怎么用好Java注解？</h2><pre><code>Override、继承重写
Deprecated、废弃 @Deprecated(since=&quot;1.2&quot;, forRemoval=true）
SuppressWarnings
</code></pre><h2 id="异常处理都有哪些陷阱"><a href="#异常处理都有哪些陷阱" class="headerlink" title="异常处理都有哪些陷阱"></a>异常处理都有哪些陷阱</h2><pre><code>处理好捕获异常
Exception 类是一个包罗万象的超级异常类，如果我们使用 Exception 作为声明和抛出的异常，
就不方便用户精准定位，从而解读和判断“出了什么错”。 类似的超级异常类还有 RuntimeException、IOException 等。
 除非是超级的接口，否则我们应该尽量减少超级异常类的使用，而是选择那些意义明确、覆盖面小的异常类，
 比如 FileNotFoundException。
</code></pre><h2 id="编写规范代码的检查清单"><a href="#编写规范代码的检查清单" class="headerlink" title="编写规范代码的检查清单"></a>编写规范代码的检查清单</h2><h1 id="技术管理实战36讲"><a href="#技术管理实战36讲" class="headerlink" title="技术管理实战36讲"></a>技术管理实战36讲</h1><pre><code>外驱让我们可以做好本职工作，而内驱才能让我们成就卓越。
</code></pre><h2 id="哪些人比较容易走上管理岗位？"><a href="#哪些人比较容易走上管理岗位？" class="headerlink" title="哪些人比较容易走上管理岗位？"></a>哪些人比较容易走上管理岗位？</h2><pre><code>天时：
    做管理的“天时”，其实就是机会、时机、大环境、时代背景。
地利：
    管理的“地利”，就是你的优势、能力，以及你所负责的工作内容。
第一类是负责最全局的模块，核心是“广”
第二类是负责最核心的技术模块，核心是“深”
人和：
    做管理的“人和”，就是你能否得到他人的支持
</code></pre><h1 id="左耳听风"><a href="#左耳听风" class="headerlink" title="左耳听风"></a>左耳听风</h1><h2 id="技术变现"><a href="#技术变现" class="headerlink" title="技术变现"></a>技术变现</h2><pre><code>1.通过在公司工作提高自己的技能，让自己可以更为独立和自由地生活。
2.对于没什么技术含量的工作内容，提高交付效率。把时间用来研究高技术含量的知识。
3.要写文章就写别人没有写过的，或是别人写过，但我能写得更好的。
4.看清市场需求（各个公司正在做什么，难题是什么）和技术趋势（首先要了解技术的历史，把本质吃透：看经典书籍，向前沿学习）
5.在学习技术的过程一定要多问自己两个问题：“一，这个技术解决什么问题？为什么别的同类技术做不到？
二，为什么是这样解决的？有没有更好的方式？”另外，还有一个简单的判断方法，
如果一个新的技术顺应技术发展趋势，那么在这个新的技术出现时，后面一定会有大型的商业公司支持（专门做此类技术的公司），
这类公司支持得越多，就说明你越需要关注。
6.在一家高速发展的公司中，技术人员的价值可以达到最大化。比较好的成长路径是，
先进入大公司学习大公司的技术和成功的经验，然后再找到高速成长的公司，这样你就可以实现自己更多的价值。
7.动手能力很重要，持续在前线工作。
8.关注技术付费点：一个是，能帮别人“挣钱”的地方；另一个是，能帮别人“省钱”的地方。
9.提高自己的能力和经历。
找到有价值的信息源（知识的源头：西方世界）
10.输出观点和价值观，只有输出了更先进的价值观，才会获得真正的影响力（厚积薄发的过程）
11.优质的朋友圈。
</code></pre><h2 id="技术领导力"><a href="#技术领导力" class="headerlink" title="技术领导力"></a>技术领导力</h2><pre><code>1、能够发现问题
2、能够提供解决问题的思路和方案、并且比较这些方案优缺点
3、能够做出正确的技术决定（用什么技术、什么解决方案、怎么样完成一个项目）
4、能够用更优雅更简单更容易的方式来解决问题
5、能够提高代码活着软件的扩展性、重用性和可维护性
以后做任何的事情千万不要做临时方案，临时方案就是给自己挖坑
重用性就是考虑抽离多个组件
可维护就是考虑到怎么样去设计系统架构和代码的模块化，系统之间的边界线
6、能够用正确的方式管理团队
让正确的人做正确的事情，提高团队的生产力和人效率，找到最有价值的需求并且用最小的成本实现。
7、创新能力

如何成为拥有技术领导力或者拥有技术领导力的人都有哪些共同点
1、扎实的基础技术
第一，你要吃透基础技术。基础技术是各种上层技术共同的基础
2、非同一般的学习能力
第二，提高学习能力。所谓学习能力，就是能够很快地学习新技术，又能在关键技术上深入的能力
google\stack overflow quora
3、坚持做正确的事情
提高效率、自动化的事情、掌握前沿技术的事、知识密集型的事、技术驱动的事
4、不断提高对自己的要求标准
强调实践、学以致用。
</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><pre><code>不推荐在循环体里处理错误
不要把大量的代码都放在一个 try 语句块内
错误日志的输出最好使用错误码，而不是错误信息
</code></pre><h2 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h2><pre><code>主动管理，封闭式开发
学会说不
我不能说不，但是我要有条件地说是。而且，我要把你给我的压力再反过来还给你，
看似我给了需求方选择，实际上，我掌握了主动
投资自己的时间
系统的学习一门技术
花时间在解放自己的事情上，比如过度设计
规划自己的时间
1、定义好优先级
2、最短作业优先
3、想清楚再做
4、关注长期利益规划
</code></pre><h1 id="阿甘老师管理方法论整理"><a href="#阿甘老师管理方法论整理" class="headerlink" title="阿甘老师管理方法论整理"></a>阿甘老师管理方法论整理</h1><p>  <a href="https://note.youdao.com/ynoteshare1/index.html?id=807acbd1ebf56f06d429152a1d18768e&amp;type=note" target="_blank" rel="external">https://note.youdao.com/ynoteshare1/index.html?id=807acbd1ebf56f06d429152a1d18768e&amp;type=note</a></p>
<h2 id="管理最有效能的事情还是让团队成长和提升"><a href="#管理最有效能的事情还是让团队成长和提升" class="headerlink" title="管理最有效能的事情还是让团队成长和提升"></a>管理最有效能的事情还是让团队成长和提升</h2><h2 id="人是企业最重要资产也是最重要的产品，就是要靠企业来培养"><a href="#人是企业最重要资产也是最重要的产品，就是要靠企业来培养" class="headerlink" title="人是企业最重要资产也是最重要的产品，就是要靠企业来培养"></a>人是企业最重要资产也是最重要的产品，就是要靠企业来培养</h2><h2 id="过程比结果更重要。对。掌握正确的过程才能复制出好的结果，凡夫畏果，菩萨畏因"><a href="#过程比结果更重要。对。掌握正确的过程才能复制出好的结果，凡夫畏果，菩萨畏因" class="headerlink" title="过程比结果更重要。对。掌握正确的过程才能复制出好的结果，凡夫畏果，菩萨畏因"></a>过程比结果更重要。对。掌握正确的过程才能复制出好的结果，凡夫畏果，菩萨畏因</h2><h2 id="管理6个基本动作"><a href="#管理6个基本动作" class="headerlink" title="管理6个基本动作"></a>管理6个基本动作</h2><pre><code>沟通、辅导、激励、授权、review 、执行
</code></pre><h2 id="领导力四要素"><a href="#领导力四要素" class="headerlink" title="领导力四要素"></a>领导力四要素</h2><pre><code>客户第一、以身作则、愿景驱动、挑战现状
</code></pre><h1 id="技术人的灵魂3问，阿里工程师如何解答？"><a href="#技术人的灵魂3问，阿里工程师如何解答？" class="headerlink" title="技术人的灵魂3问，阿里工程师如何解答？"></a>技术人的灵魂3问，阿里工程师如何解答？</h1><h2 id="如何在业务中发现有技术价值的问题？"><a href="#如何在业务中发现有技术价值的问题？" class="headerlink" title="如何在业务中发现有技术价值的问题？"></a>如何在业务中发现有技术价值的问题？</h2><pre><code>业务开发对业务对理解可能局限自己做的事情，很多信息都是过滤了五六手，得到的可能就是做这个任务和为什么做这个任务，
相比之下肯定不如制定战略的人懂得战略背后的意义，信息也是不对等，所以要收集信息，整理归纳，最后分析问题
</code></pre><h3 id="收集信息"><a href="#收集信息" class="headerlink" title="收集信息"></a>收集信息</h3><pre><code>各个bu大佬的okr与周报
</code></pre><h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><pre><code>可以使用MECE法则进行思考拆解，通过无遗漏无重复地分类来把握整体，列出脑图和逻辑树，
最后将逻辑树的信息匹配需求场景，可以尝试通过C端和B端不同入口去还原需求场景。
这中间可以结合一定的方法论（演绎推理和归纳推理），去把问题和挑战细化出来，帮助我们理解BU的战略，
同时我们也能从自身出发把战略拆解到对应的项目
</code></pre><h2 id="发现问题到执行该如何衔接"><a href="#发现问题到执行该如何衔接" class="headerlink" title="发现问题到执行该如何衔接"></a>发现问题到执行该如何衔接</h2><pre><code>发现问题后不能马上就开始做，要提炼问题带来的核心价值，否则投入巨大工作之后，技术产品与业务结果衔接不上
思考不要用蛮力，工作不只靠体力
见龙在田，利见大人,资源有限情况找对的人，拆关键词找到做事情的关键人
</code></pre><h2 id="最后的技术结果跟业务结果如何衔接"><a href="#最后的技术结果跟业务结果如何衔接" class="headerlink" title="最后的技术结果跟业务结果如何衔接"></a>最后的技术结果跟业务结果如何衔接</h2><pre><code>在业务做开发，重复造轮子会被人挑战，但事情都有人干了我们的价值在哪？
所以我们在业务端需要的是有技术视野能看到集团其他团队或者外部团队在做的事，能主动交流让这件事变成共赢，
如果没有其他人在搞，我们去搞要有人站出来看这个投入产出比是否合理？
也就是我们在开篇说的议题度和解答质都高的有价值的问题。
这个问题在集团其他团队是否存在共性，我们解决了能否为他们带来价值？
当然结合我们在前面讲到的在业务中发现有技术价值的问题，其实这里就有一个比较明确的答案
重中之重就是做之前把Why思考的清楚清晰，做最正确的事。只有做到这点，解决这个问题带来的业务价值就自然而然非常清晰的定位出来。
所以说最好的工程师必须要懂产品
也是说最好不要让业务推着你走，而是最终要做到你带着业务走
</code></pre><h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><pre><code>《金字塔原理》、《麦肯锡教我的思考武器》、《思考，快与慢》、《影响力》、《自控力》、《敏捷性开发》。
</code></pre><h1 id="程序员的成长路线Remix-HelloJava公众号"><a href="#程序员的成长路线Remix-HelloJava公众号" class="headerlink" title="程序员的成长路线Remix(HelloJava公众号)"></a>程序员的成长路线Remix(HelloJava公众号)</h1><pre><code>https://mp.weixin.qq.com/s/JIJCG_NvrZyL0IYNkDkAuA
</code></pre><h2 id="编程能力的成长"><a href="#编程能力的成长" class="headerlink" title="编程能力的成长"></a>编程能力的成长</h2><ul>
<li><p>编程能力初级：会用</p>
<pre><code>初级这个阶段对于大部分程序员来说都不会是问题，勤学苦练，是这个阶段的核心
</code></pre></li>
<li><p>编程能力中级：会查和避免问题</p>
<pre><code>在查问题的能力上，首先要掌握的是一些基本的调试技巧，好用的调试工具，
就像在Java里JDK自带的jstat、jmap、jinfo，不在JDK里的mat、gperf、btrace等
成为一个能写出高质量代码、有效排查问题的优秀程序员
</code></pre></li>
<li><p>编程能力高级：懂高级API和原理</p>
<pre><code>例如学Java NIO，可以自己基于NIO包一个框架，然后对比Netty，看看哪些写的是不如Netty的，这样会非常有助于真正的理解
Java的编译机制、内存管理、线程机制
1万小时理论
</code></pre></li>
<li><p>系统设计能力的成长</p>
<pre><code>整个系统的目标、模块的划分和职责、关键的对象设计
先在一两个技术领域做到专业，然后尽量扩大自己的知识广度
</code></pre></li>
</ul>
<h2 id="我在Uber运营大型分布式系统三年经验谈-InfoQ公众号"><a href="#我在Uber运营大型分布式系统三年经验谈-InfoQ公众号" class="headerlink" title="我在Uber运营大型分布式系统三年经验谈(InfoQ公众号)"></a>我在Uber运营大型分布式系统三年经验谈(InfoQ公众号)</h2><p>  <a href="https://mp.weixin.qq.com/s/TIGI4cI3jt_djbm6Iu8W7g" target="_blank" rel="external">https://mp.weixin.qq.com/s/TIGI4cI3jt_djbm6Iu8W7g</a></p>
<pre><code>大型分布式系统经验
一、监控
1、基础设施监控
2、服务健康监控，流量，错误，延迟
3、业务指标监控
二、值班，异常检测和告警
三、停服务器与事件管理流程
1、回滚
四、事后总结
caseStudy
五、有计划的的服务宕机演习，容量规划
六、slo与sla
Service level objective  系统可用性数字化指标
包括。容量目标，延迟，准确度，可用性
自动化测量报告，
</code></pre><h1 id="项目管理实战20讲"><a href="#项目管理实战20讲" class="headerlink" title="项目管理实战20讲"></a>项目管理实战20讲</h1><pre><code>一、角色转换误区
1.1 凡事恨不得事必躬亲
    让人知道要做（Awareness）
    有动力做（画大饼，讲清楚为什么要做，为什么要现在做，获取团队动力）
    和有能力做（积极争取外部资源）
1.2 追在别人屁股后面做监工
    要明确目标，建立机制，并让这个机制运转起来，最终在项目组形成一种良性的秩序
1.3 拿着锤子，看哪里都是钉子
    时间、成本、质量、范围这几个因素，到底哪个更重要？哪些是允许有一定调整空间的？
二、十大领域
2.1 干系人管理：如果管理干系人
2.2 范围管理:做什么
2.3 进度管理：花多长时间
2.4 成本管理：花多大代价
2.5 质量管理：达到什么要求
2.6 资源管理：有多少内部资源
2.7 采购管理：有多少需要买
2.8 沟通管理： 如何管理沟通
2.9 风险管理：如何应对风险
2.10 整合管理： 如何实现整体最优
三、五大过程
  质量管理领域PDCA：做任何事情都要经过Plan、执行Do、检查Check、行动Act，PMI遵循PDCA的法则。
3.1 项目启动过程组
    项目启动时候拉所有人开会，设定愿景目标和重要里程碑，确定责任分工和沟通机制
3.2 规划过程组
    把愿景目标转化为可落地的行动方案和工作路线
3.3 执行过程组
    根据规划执行
3.4 监控过程组
    提前预知风险，及时调整
3.5 收尾过程组
    复盘
项管职责定位：
保目标、助决策、提效能、促协作
四 启动-识别项目中的四类干系人
    如果按照在项目上的权力和利益相关度对干系人进行划分，可以把项目干系人分成以下四类：
高利益高权力，高利益低权力，低利益高权力，低利益低权力。
4.1 高利益高权力：项目发起人
    项目发起人称为Sponsor，即项目资助人，需要重点管理。因为很多项目执行过程中突然夭折
就是因为还没清晰定位项目会为组织带来什么，以及组织对项目成功的定义。
    沟通模版例如：他发起这个项目的背景和初衷是什么？如何才能知道我们做到了？哪些资源是项目获得成功的关键？
他最看重项目的哪些要素？是进度、质量、成本还是范围？在极端情况下，我们该如何对这些要素进行排序呢？
4.2 低利益高权力：职能经理
       职能经理是资源池的所有者，他们所管辖的团队通常覆盖多个项目或项目群，这也使得他们与单个项目的利益相关度通常比较低，
介入程度往往也很有限。
    对项目的态度可以分为以下三部分
    反对者
        管理这类人的重点在于建立信任，化解敌意
    支持者
        支持者是项目获取成功非常依赖的力量，管理这些人就是，让他们深度参与到项目
，提高他们的主人翁意识。
    中立者
        在条件合适时，进一步将其转化为支持力量。但如果你精力有限，可以先不管。
4.3 “高利益低权力”代表：项目组成员
    与项目结果直接相关、但对决策影响不大的一类人
    管理这类人的核心就是做到项目事项随时告知，及时通报项目的进度和困难
4.4 “低利益低权力”代表：外围支持人员
    俗称外包，技术外包或者设计外包。对于这些人提前约定好，每天或者每周进展汇报的格式和内容。
五、规划-排除计划中的延期地雷
    计划是贯穿始终的重要课题，是各个角色协同工作的基准，做计划，是个集体对焦的过程
5.1 雷区1:不够具体
    例如xx项目计划于3月20日提测，4月1日上线。
    解决方式：WBS工作分解，创建WBS的过程，也就是把项目工作按阶段可交付成果分解成较小的、更易于管理的组成部分的过程。
简单来说，WBS就是“把大象放进冰箱”的过程。
5.2 雷区2:不够全面
    只有任务列表，没有识别关键资源和关键依赖，也没有考虑研发之外其他环节，是不够全面的
5.3 雷区3:不够准确
    定义完成标准，防止大家磨嘴皮子。越早定义完成标准，计划按照期望完成的概率就越大
    例如 需求或者设计确认、功能完成或者提测（冒烟测试通过率高于90%）、里程碑完成（如不存在P0及P1优先级的Bug
5.4 雷区4:没有共识
    没有达成共识的计划，是不具备任何效力的。
    在确认计划之后，向所有项目组成员，包括项目的所有干系人，发送计划邮件，正式周知，这可以尽早地发现共识的偏差。
5.5 雷区5:不够及时
    每一次进行调整，都要确保项目中的每个人知道当前的计划是什么，调整计划需要怎样的决策过程，都需要谁参与决策。
而及时调整变更，就是做计划的第五个标准动作。
六、执行-打造品质、要从头开始”闭环“
    其实就是做到以终为始，构建系统能力，在产品研发的整个过程中，建立起真正闭环反馈的产品验证机制
6.1 方案评审
    需求评审、交互评审、视觉评审
6.2 BugBash（Bug大扫除）
    项目末期集中找bug
6.3 冒烟用例评审
      从测试人员记录冒烟测试通过率开始
七、监控-进展“巧”汇报，学会用数据说话
7.1 紧急报告模版
    事件描述；影响后果；跟进分析；响应措施：包含负责人及时间表；所需支持。
7.2 常规汇报
八、项目复盘
8.1 复盘基调
    复盘不等于追责，而是集体进入反思。
    这次复盘不是来挑问题的，而是为了找到问题的根源并改进的
8.2 复盘会流程
    1、现场回顾项目情况，例如目标达成情况、进度计划变更情况、需求变更情况、质量报告
    2、参会人员写下项目过程中做的好的以及做的不好的3点，然后汇总贴白板
    3、在白板前review大家的意见
    4、对大家总结出的好与不好点投票
    5、整理投票结果，对于好的环节，总结经验；对于不好环节，当初做出改进方案。
8.3 打造团队持续改进能力
    激发团队的主人翁意识，让团队成为复盘的主角，而不是你。
九、需求变更
 9.1 达成最小共识，变更是有代价的
 9.2 源头治理，一次把事情做对
 9.3 快试错，不可抗力巧应对
</code></pre><h1 id="DDD实战课"><a href="#DDD实战课" class="headerlink" title="DDD实战课"></a>DDD实战课</h1><h2 id="1、领域驱动设计：微服务设计为什么要选择DDD"><a href="#1、领域驱动设计：微服务设计为什么要选择DDD" class="headerlink" title="1、领域驱动设计：微服务设计为什么要选择DDD"></a>1、领域驱动设计：微服务设计为什么要选择DDD</h2><pre><code>微服务拆分困境产生的根本原因就是不知道业务或者微服务的边界到底在什么地方
DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，
保证业务模型与代码模型的一致性， DDD设计方法作为微服务的主流设计方法
DDD不是架构，而是一种架构设计方法论，它通过边界划分将复杂业务领域简单化，
帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进

DDD是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，
而从业务视角去分离应用系统建设复杂度的手段。两者都强调从业务出发，
其核心要义是强调根据业务发展，合理划分领域边界，持续调整现有架构，
优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构
</code></pre><h3 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h3><pre><code>战略设计主要从业务视角出发，建立业务领域模型，划分领域边界，
建立通用语言的限界上下文，限界上下文可以作为微服务设计的参考边界
领域模型可以用来指导微服务的设计和拆分
事件风暴是建立领域模型的主要方法，是个发散到收敛到过程
采用用例分析、场景分析、用户旅程分析，梳理领域对象之间到关系，这是个发散等过程，
会产生很多实体，命令，事件等领域对象，我们再将这些对象进行不同纬度进行聚类，形成
聚合、限界上下文等边界，建立领域模型就是一个收敛等过程
</code></pre><h3 id="战术设计"><a href="#战术设计" class="headerlink" title="战术设计"></a>战术设计</h3><pre><code>战术设计则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，
包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现
</code></pre><h3 id="三步划定领域模型和微服务的边界"><a href="#三步划定领域模型和微服务的边界" class="headerlink" title="三步划定领域模型和微服务的边界"></a>三步划定领域模型和微服务的边界</h3><pre><code>1、在事件风暴中梳理业务过程中的用户操作、事件、以及外部依赖关系，根据这些要素梳理出
领域实体等领域对象
2、根据领域实体之间等业务关联性，将业务紧密相关的实体进行组合形成聚合，同时确定
聚合中的聚合根、值对象和实体，聚合之间的边界是第一层边界，一般用虚线表示，它们是
在同一个服务实例中运行，属于逻辑边界
3、根据业务或者语意边界，将一个或者多个聚合划定在一个限界上下文中，形成领域模型，
限界上下文之间的边界可以定义成未来微服务的边界，不同限界上下文的领域逻辑被隔离
在不同的实例，属于物理边界。
</code></pre><h2 id="2、领域、子域、核心域、通用域、支撑域"><a href="#2、领域、子域、核心域、通用域、支撑域" class="headerlink" title="2、领域、子域、核心域、通用域、支撑域"></a>2、领域、子域、核心域、通用域、支撑域</h2><h3 id="如何理解领域与子域"><a href="#如何理解领域与子域" class="headerlink" title="如何理解领域与子域"></a>如何理解领域与子域</h3><pre><code>领域就是用来确定范围的，范围就是边界
ddd会按照一定的规则将业务领域进行细分，当领域细分到一定程度后，
会将问题限定在特定的边界内，在这个边界内建立领域模型，
进而用代码实现该领域模型，解决相应的业务问题
领域可以划分为多个子领域，每个子领域对应一个更小的问题或者更小的业务范围
</code></pre><h3 id="如何理解核心域、通用域和支撑域"><a href="#如何理解核心域、通用域和支撑域" class="headerlink" title="如何理解核心域、通用域和支撑域"></a>如何理解核心域、通用域和支撑域</h3><pre><code>决定产品和公司核心竞争力的子域是核心域，它是业务成功的主要因素和公司的核心竞争力。
通用域则是你需要用到的通用系统，比如认证、权限等等
支撑域则具有企业特性，但不具有通用性，例如数据代码类的数据字典等系统
</code></pre><h2 id="3、限界上下文：定义领域边界的利器"><a href="#3、限界上下文：定义领域边界的利器" class="headerlink" title="3、限界上下文：定义领域边界的利器"></a>3、限界上下文：定义领域边界的利器</h2><h3 id="通用语言"><a href="#通用语言" class="headerlink" title="通用语言"></a>通用语言</h3><pre><code>从事件风暴建立通用语言到领域对象设计和代码落地的完整过程。
事件风暴--&gt;领域故事分析--&gt;提取领域对象--&gt;领域对象与代码模型映射--&gt;代码落地
</code></pre><h3 id="什么是限界上下文？"><a href="#什么是限界上下文？" class="headerlink" title="什么是限界上下文？"></a>什么是限界上下文？</h3><pre><code>语言都有它的语义环境，同样，通用语言也有它的上下文环境。
为了避免同样的概念或语义在不同的上下文环境中产生歧义，DDD在战略设计上提出了“限界上下文”这个概念，
用来确定语义所在的领域边界

限界和上下文。限界就是领域的边界，而上下文则是语义环境。
用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等
（通用语言）有一个确切的含义，没有二义性
</code></pre><h3 id="限界上下文和微服务的关系"><a href="#限界上下文和微服务的关系" class="headerlink" title="限界上下文和微服务的关系"></a>限界上下文和微服务的关系</h3><pre><code>理论上限界上下文就是微服务的边界。我们将限界上下文内的领域模型映射到微服务，就完成了从问题域到软件的解决方案。
子域还可根据需要进一步拆分为子子域，拆到一定程度后，有些子子域的领域边界就可能变成限界上下文的边界了
子域可能会包含多个限界上下文，有些子域本身的边界就是限界上下文边界，

正如电商领域的商品一样，商品在不同的阶段有不同的术语，在销售阶段是商品，
而在运输阶段则变成了货物。同样的一个东西，由于业务领域的不同，
赋予了这些术语不同的涵义和职责边界，这个边界就可能会成为未来微服务设计的边界。
</code></pre><h2 id="4、实体和值对象"><a href="#4、实体和值对象" class="headerlink" title="4、实体和值对象"></a>4、实体和值对象</h2><pre><code>实体是指有延续性或者是唯一标示
值对象 值对象的属性值是不允许变化的，即值对象的实体在创建之后就不会变了，
如果要改变其属性值，就需要先把此对象删除，然后重新创建一个新对象
</code></pre><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><pre><code>拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。对这些对象而言，
重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。
</code></pre><h4 id="1-实体的业务形态"><a href="#1-实体的业务形态" class="headerlink" title="1.实体的业务形态"></a>1.实体的业务形态</h4><pre><code>在战略设计时，实体是领域模型的一个重要对象。领域模型中的实体是多个属性、操作或行为的载体。
在事件风暴中，我们可以根据命令、操作或者事件，找出产生这些行为的业务实体对象，
进而按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合

实体和值对象是组成领域模型的基础单元
</code></pre><h4 id="2-实体的代码形态"><a href="#2-实体的代码形态" class="headerlink" title="2.实体的代码形态"></a>2.实体的代码形态</h4><pre><code>在DDD里，这些实体类通常采用充血模型，与这个实体相关的所有业务逻辑都在实体类的方法中实现，
跨多个实体的领域逻辑则在领域服务中实现。
</code></pre><h4 id="3-实体的运行形态"><a href="#3-实体的运行形态" class="headerlink" title="3.实体的运行形态"></a>3.实体的运行形态</h4><pre><code>实体以DO（领域对象）的形式存在，每个实体对象都有唯一的ID
</code></pre><h4 id="4-实体的数据库形态"><a href="#4-实体的数据库形态" class="headerlink" title="4.实体的数据库形态"></a>4.实体的数据库形态</h4><pre><code>与传统数据模型设计优先不同，DDD是先构建领域模型，针对实际业务场景构建实体对象和行为，
再将实体对象映射到数据持久化对象
一个实体可能对应0个、1个或者多个数据库持久化对象
</code></pre><h3 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h3><pre><code>在DDD中用来描述领域的特定方面，并且是一个没有标识符的对象，叫作值对象

人员实体原本包括：姓名、年龄、性别以及人员所在的省、市、县和街道等属性。
这样显示地址相关的属性就很零碎了对不对？现在，我们可以将“省、市、县和街道等属性”
拿出来构成一个“地址属性集合”，这个集合就是值对象了
</code></pre><h4 id="1-值对象的业务形态"><a href="#1-值对象的业务形态" class="headerlink" title="1.值对象的业务形态"></a>1.值对象的业务形态</h4><pre><code>实体具有业务属性、业务行为和业务逻辑。而值对象只是若干个属性的集合，
只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑
</code></pre><h4 id="2-值对象的代码形态"><a href="#2-值对象的代码形态" class="headerlink" title="2.值对象的代码形态"></a>2.值对象的代码形态</h4><pre><code>值对象在代码中有这样两种形态。
如果值对象是单一属性，则直接定义为实体类的属性；

如果值对象是属性集合，则把它设计为Class类，Class将具有整体概念的多个属性归集到属性集合，
这样的值对象没有ID，会被实体整体引用
</code></pre><h4 id="3-值对象的运行形态"><a href="#3-值对象的运行形态" class="headerlink" title="3.值对象的运行形态"></a>3.值对象的运行形态</h4><pre><code>值对象嵌入到实体的话，有这样两种不同的数据格式，也可以说是两种方式，分别是属性嵌入的方式和序列化大对象的方式
从代码层次来说属性嵌入式其实就是成员变量属性，序列化方式可以理解成引入一个成员变量对象。
</code></pre><h4 id="4-值对象的数据库形态"><a href="#4-值对象的数据库形态" class="headerlink" title="4.值对象的数据库形态"></a>4.值对象的数据库形态</h4><pre><code>在领域建模时，我们可以将部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；
在数据建模时，我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计。

例如：人员和地址那个场景
地址作为值对象，人员作为实体，这样就可以保留地址的业务涵义和概念完整性。
而在数据建模时，我们可以将地址的属性值嵌入人员实体数据库表中，只创建人员数据库表。
这样既可以兼顾业务含义和表达，又不增加数据库的复杂度。
</code></pre><h4 id="5-值对象的优势和局限"><a href="#5-值对象的优势和局限" class="headerlink" title="5.值对象的优势和局限"></a>5.值对象的优势和局限</h4><pre><code>值对象采用序列化大对象的方法简化了数据库设计，减少了实体表的数量，可以简单、清晰地表达业务概念
。这种设计方式虽然降低了数据库设计的复杂度，但却无法满足基于值对象的快速查询，
会导致搜索值对象属性值变得异常困难
</code></pre><h4 id="6-实体和值对象的关系"><a href="#6-实体和值对象的关系" class="headerlink" title="6.实体和值对象的关系"></a>6.实体和值对象的关系</h4><pre><code>值对象和实体在某些场景下可以互换
有些场景中，地址会被某一实体引用，它只承担描述实体的作用，并且它的值只能整体替换，
这时候你就可以将地址设计为值对象，比如收货地址。而在某些业务场景中，地址会被经常修改，
地址是作为一个独立对象存在的，这时候它应该设计为实体，比如行政区划中的地址信息维护
</code></pre><h3 id="05-聚合和聚合根：怎样设计聚合？"><a href="#05-聚合和聚合根：怎样设计聚合？" class="headerlink" title="05-聚合和聚合根：怎样设计聚合？"></a>05-聚合和聚合根：怎样设计聚合？</h3><pre><code>聚合有一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，
定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的。
按照这种方式设计出来的微服务很自然就是“高内聚、低耦合”的

聚合在DDD分层架构里属于领域层，领域层包含了多个聚合，共同实现核心业务逻辑。
聚合内实体以充血模型实现个体业务能力，以及业务逻辑的高内聚。
</code></pre><h4 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a>聚合根</h4><pre><code>如果把聚合比作组织，那聚合根就是这个组织的负责人。
聚合根也称为根实体，它不仅是实体，还是聚合的管理者

首先它作为实体本身，拥有实体的属性和业务行为，实现自身的业务逻辑。其次它作为聚合的管理者，
在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。最后在聚合之间，
它还是聚合对外的接口人，以聚合根ID关联的方式接受外部任务和请求，在上下文内实现聚合之间的业务协同。
也就是说，聚合之间通过聚合根ID关联引用，如果需要访问其它聚合的实体，
就要先访问聚合根，再导航到聚合内部实体，外部对象不能直接访问聚合内实体。
</code></pre><h4 id="怎样设计聚合"><a href="#怎样设计聚合" class="headerlink" title="怎样设计聚合"></a>怎样设计聚合</h4><pre><code>DDD领域建模通常采用事件风暴，它通常采用用例分析、场景分析和用户旅程分析等方法，
通过头脑风暴列出所有可能的业务行为和事件，然后找出产生这些行为的领域对象，
并梳理领域对象之间的关系，找出聚合根，找出与聚合根业务紧密关联的实体和值对象，
再将聚合根、实体和值对象组合，构建聚合

聚合根的特点：聚合根是实体，有实体的特点，具有全局唯一标识，有独立的生命周期。
一个聚合只有一个聚合根，聚合根在聚合内对实体和值对象采用直接对象引用的方式进行组织和协调，
聚合根与聚合根之间通过ID关联的方式实现聚合之间的协同。

实体的特点：有ID标识，通过ID判断相等性，ID在聚合内唯一即可。
状态可变，它依附于聚合根，其生命周期由聚合根管理。
实体一般会持久化，但与数据库持久化对象不一定是一对一的关系。
实体可以引用聚合内的聚合根、实体和值对象。

值对象的特点：无ID，不可变，无生命周期，用完即扔。值对象之间通过属性值判断相等性。
它的核心本质是值，是一组概念完整的属性组成的集合，用于描述实体的状态和特征。值对象尽量只引用值对象。
</code></pre><h4 id="聚合的一些设计原则"><a href="#聚合的一些设计原则" class="headerlink" title="聚合的一些设计原则"></a>聚合的一些设计原则</h4><pre><code>总结：
一个事物只能修改一个聚合、聚合要小，聚合关联其他聚合的唯一标示，
业务操作中设计多个聚合状态修改，可以改成消息模式解耦
领域服务不能跨多个聚合调用，表设计的时候也不要跨多个表关联
</code></pre><h5 id="1-在一致性边界内建模真正的不变条件"><a href="#1-在一致性边界内建模真正的不变条件" class="headerlink" title="1.在一致性边界内建模真正的不变条件"></a>1.在一致性边界内建模真正的不变条件</h5><pre><code>聚合用来封装真正的不变性，而不是简单地将对象组合在一起。
在一个事务中只修改一个聚合实例
</code></pre><h5 id="2-设计小聚合"><a href="#2-设计小聚合" class="headerlink" title="2.设计小聚合"></a>2.设计小聚合</h5><pre><code>如果聚合设计得过大，聚合会因为包含过多的实体，导致实体之间的管理过于复杂，
高频操作时会出现并发冲突或者数据库锁，最终导致系统可用性变差。
</code></pre><h5 id="3-通过唯一标识引用其它聚合"><a href="#3-通过唯一标识引用其它聚合" class="headerlink" title="3.通过唯一标识引用其它聚合"></a>3.通过唯一标识引用其它聚合</h5><pre><code>当存在对象之间的关联时，建议引用其唯一标识而非引用其整体对象。
如果是外部上下文中的实体，引用其唯一标识或将需要的属性构造值对象。
 如果聚合创建复杂，推荐使用工厂方法来屏蔽内部复杂的创建逻辑
</code></pre><h5 id="4-在边界之外使用最终一致性"><a href="#4-在边界之外使用最终一致性" class="headerlink" title="4.在边界之外使用最终一致性"></a>4.在边界之外使用最终一致性</h5><pre><code>在一次事务中，最多只能更改一个聚合的状态。如果一次业务操作涉及多个聚合状态的更改，
应采用领域事件的方式异步修改相关的聚合，实现聚合之间的解耦
</code></pre><h5 id="5-通过应用层实现跨聚合的服务调用。"><a href="#5-通过应用层实现跨聚合的服务调用。" class="headerlink" title="5.通过应用层实现跨聚合的服务调用。"></a>5.通过应用层实现跨聚合的服务调用。</h5><pre><code>为实现微服务内聚合之间的解耦，以及未来以聚合为单位的微服务组合和拆分，
应避免跨聚合的领域服务调用和跨聚合的数据库表关联。
</code></pre><h3 id="06-领域事件：解耦微服务的关键"><a href="#06-领域事件：解耦微服务的关键" class="headerlink" title="06-领域事件：解耦微服务的关键"></a>06-领域事件：解耦微服务的关键</h3><pre><code>领域事件是对领域内发生的活动进行的建模。
领域事件是领域模型中非常重要的一部分，用来表示领域中发生的事件。
一个领域事件将导致进一步的业务操作，在实现业务解耦的同时，还有助于形成完整的业务闭环。
</code></pre><h4 id="1-微服务内的领域事件"><a href="#1-微服务内的领域事件" class="headerlink" title="1.微服务内的领域事件"></a>1.微服务内的领域事件</h4><pre><code>微服务内应用服务，可以通过跨聚合的服务编排和组合，以服务调用的方式完成跨聚合的访问，
这种方式通常应用于实时性和数据一致性要求高的场景
</code></pre><h4 id="2-微服务内的领域事件"><a href="#2-微服务内的领域事件" class="headerlink" title="2.微服务内的领域事件"></a>2.微服务内的领域事件</h4><pre><code>微服务之间的访问也可以采用应用服务直接调用的方式，实现数据和服务的实时访问，
弊端就是跨微服务的数据同时变更需要引入分布式事务，以确保数据的一致性。
</code></pre><h4 id="领域事件总体架构"><a href="#领域事件总体架构" class="headerlink" title="领域事件总体架构"></a>领域事件总体架构</h4><pre><code>领域事件处理包括：事件构建和发布、事件数据持久化、事件总线、消息中间件、事件接收和处理等
基于mq解耦
领域事件驱动机制可以实现一个发布方N个订阅方的模式，这在传统的直接服务调用设计中基本是不可能做到的
</code></pre><h3 id="07-DDD分层架构：有效降低层与层之间的依赖"><a href="#07-DDD分层架构：有效降低层与层之间的依赖" class="headerlink" title="07-DDD分层架构：有效降低层与层之间的依赖"></a>07-DDD分层架构：有效降低层与层之间的依赖</h3><pre><code>传统的四层架构；用户接口层--&gt;应用层--&gt; 领域层--&gt; 基础层
依赖倒置的四层架构：基础层--&gt; 用户接口层--&gt; 应用层--&gt; 领域层
</code></pre><h4 id="用户层"><a href="#用户层" class="headerlink" title="用户层"></a>用户层</h4><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><pre><code>应用层是很薄的一层，理论上不应该有业务规则或逻辑，主要面向用例和流程相关的操作
应用层也是微服务之间交互的通道，它可以调用其它微服务的应用服务，完成微服务之间的服务组合和编排
</code></pre><h4 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a>领域层</h4><pre><code>领域层的作用是实现企业核心业务逻辑，通过各种校验手段保证业务的正确性。
领域层主要体现领域模型的业务能力，它用来表达业务概念、业务状态和业务规则
</code></pre><h4 id="基础层"><a href="#基础层" class="headerlink" title="基础层"></a>基础层</h4><pre><code>基础层包含基础服务，它采用依赖倒置设计，封装基础资源服务，实现应用层、领域层与基础层的解耦，
降低外部资源变化对应用的影响

在传统架构设计中，由于上层应用对数据库的强耦合，很多公司在架构演进中最担忧的可能就是换数据库了，
因为一旦更换数据库，就可能需要重写大部分的代码，这对应用来说是致命的。那采用依赖倒置的设计以后，
应用层就可以通过解耦来保持独立的核心业务逻辑。当数据库变更时，我们只需要更换数据库基础服务就可以了
，这样就将资源变更对应用的影响降到了最低
</code></pre><h4 id="DDD分层架构最重要的原则是什么"><a href="#DDD分层架构最重要的原则是什么" class="headerlink" title="DDD分层架构最重要的原则是什么"></a>DDD分层架构最重要的原则是什么</h4><pre><code>每层只能与位于其下方的层发生耦合
架构根据耦合的紧密程度又可以分为两种：严格分层架构和松散分层架构
优化后的DDD分层架构模型就属于严格分层架构，任何层只能对位于其直接下方的层产生依赖。
而传统的DDD分层架构则属于松散分层架构，它允许某层与其任意下方的层发生依赖。

试想下，如果领域层中的某个服务发生了重大变更，那该如何通知所有调用方同步调整和升级呢？
但在严格分层架构中，你只需要逐层通知上层服务就可以了
</code></pre><h4 id="三层架构如何演变成四层架构"><a href="#三层架构如何演变成四层架构" class="headerlink" title="三层架构如何演变成四层架构"></a>三层架构如何演变成四层架构</h4><pre><code>三层架构向DDD分层架构演进，主要发生在业务逻辑层和数据访问层。
DDD分层架构将业务逻辑层的服务拆分到了应用层和领域层
应用层快速响应前端的变化，领域层实现领域模型的能力
另外一个重要的变化发生在数据访问层和基础层之间，三层架构数据访问采用DAO方式；
DDD分层架构的数据库等基础资源访问，采用了仓储（Repository）设计模式，通过依赖倒置实现各层对基础资源的解耦
</code></pre><h3 id="08微服务架构模型：几种常见模型的对比和分析"><a href="#08微服务架构模型：几种常见模型的对比和分析" class="headerlink" title="08微服务架构模型：几种常见模型的对比和分析"></a>08微服务架构模型：几种常见模型的对比和分析</h3><h4 id="整洁架构"><a href="#整洁架构" class="headerlink" title="整洁架构"></a>整洁架构</h4><pre><code>整洁架构又名“洋葱架构，整洁架构最主要的原则是依赖原则，
它定义了各层的依赖关系，越往里依赖越低，代码级别越高，越是核心能力。
外圆代码依赖只能指向内圆，内圆不需要知道外圆的任何情况
</code></pre><h4 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h4><pre><code>六边形架构又名“端口适配器架构”。追溯微服务架构的渊源，一般都会涉及到六边形架构
</code></pre><h1 id="网络编程实战"><a href="#网络编程实战" class="headerlink" title="网络编程实战"></a>网络编程实战</h1><h2 id="02-网络编程模型：认识客户端-服务器网络模型的基本概念"><a href="#02-网络编程模型：认识客户端-服务器网络模型的基本概念" class="headerlink" title="02 | 网络编程模型：认识客户端-服务器网络模型的基本概念"></a>02 | 网络编程模型：认识客户端-服务器网络模型的基本概念</h2><pre><code>无论是客户端，还是服务器端，它们运行的单位都是进程而不是机器
保留网段:
10.x 、192.168.x、172.x
子网掩码：
网络概念：192.168.1.1～192.168.1.255
主机概念：1到255就是可用到不同ip
</code></pre><h2 id="04-TCP三次握手：怎么使用套接字格式建立连接"><a href="#04-TCP三次握手：怎么使用套接字格式建立连接" class="headerlink" title="04 | TCP三次握手：怎么使用套接字格式建立连接"></a>04 | TCP三次握手：怎么使用套接字格式建立连接</h2><p><img src="https://static001.geekbang.org/resource/image/65/29/65cef2c44480910871a0b66cac1d5529.png" alt=""></p>
<pre><code>Seq: 顺序号字段
SYN：发起一个连接
ACK：确认序号有效
1、客户端向服务端发送syn包，并且告诉服务器端当前发送序号为seq=j,客户端进入sync_sent
2、服务端收到包后 进行ACK=j+1应答，同时也向客户端发送syn包 同时告诉客户端当前发送序号为seq=k,服务器进入sync_rcvd
3、客户端收到ack后检查ack是否为j+1，同时客户端因为发送应答包确认序号 ack=k+1，客户端进入established
4、服务端收到应答包后，检查ack是否为j+1,如果是就进入established
</code></pre><h2 id="10-TIME-WAIT：隐藏在细节下的魔鬼"><a href="#10-TIME-WAIT：隐藏在细节下的魔鬼" class="headerlink" title="10 | TIME_WAIT：隐藏在细节下的魔鬼"></a>10 | TIME_WAIT：隐藏在细节下的魔鬼</h2><p><img src="https://static001.geekbang.org/resource/image/f3/e1/f34823ce42a49e4eadaf642a75d14de1.png" alt=""></p>
<pre><code>Linux 系统停留在 TIME_WAIT 的时间为固定的60s
一般都是客户端发起fin请求
只有发起连接终止的一方会进入 TIME_WAIT 状态
为什么是四次挥手不是三次挥手？
挥手的时候是server端先发送ACK 然后再发送FIN
time_wait作用，为什么client接收到ack后不马上进入closed
1、确保最后的ack能让被动关闭方接收
</code></pre><h2 id="11-优雅地关闭还是粗暴地关闭"><a href="#11-优雅地关闭还是粗暴地关闭" class="headerlink" title="11 | 优雅地关闭还是粗暴地关闭 ?"></a>11 | 优雅地关闭还是粗暴地关闭 ?</h2><h1 id="如何设计一个秒杀系统"><a href="#如何设计一个秒杀系统" class="headerlink" title="如何设计一个秒杀系统"></a>如何设计一个秒杀系统</h1><h2 id="设计秒杀系统时应该注意的5个架构原则"><a href="#设计秒杀系统时应该注意的5个架构原则" class="headerlink" title="设计秒杀系统时应该注意的5个架构原则"></a>设计秒杀系统时应该注意的5个架构原则</h2><pre><code>4要1不要
1、数据尽量要少
    首先是指用户请求的数据能少就少。请求的数据包括上传给系统的数据和系统返回给用户的数据
2、请求数要尽量少
    例如，减少请求数最常用的一个实践就是合并CSS和JavaScript文件，把多个JavaScript文件合并成一个文件，
3、路径要尽量短
    所谓“路径”，就是用户发出请求到返回数据这个过程中，需求经过的中间的节点数
    要缩短访问路径有一种办法，就是多个相互强依赖的应用合并部署在一起，把远程过程调用（RPC）变成JVM内部之间的方法调用。
4、依赖要尽量少
    所谓依赖，指的是要完成一次用户请求必须依赖的系统或者服务，这里的依赖指的是强依赖
5、不要有单点
</code></pre><h3 id="不同场景下的不同架构案例"><a href="#不同场景下的不同架构案例" class="headerlink" title="不同场景下的不同架构案例"></a>不同场景下的不同架构案例</h3><h3 id="03二八原则：有针对性地处理好系统的“热点数据”"><a href="#03二八原则：有针对性地处理好系统的“热点数据”" class="headerlink" title="03二八原则：有针对性地处理好系统的“热点数据”"></a>03二八原则：有针对性地处理好系统的“热点数据”</h3><pre><code>热点分为热点操作和热点数据
 热点操作：大量的刷新页面与大量的添加购物车
 热点数据分为：&quot;静态热点数据与动态热点数据&quot;
</code></pre><h4 id="静态热点"><a href="#静态热点" class="headerlink" title="静态热点"></a>静态热点</h4><pre><code>数据是可以提前预测到到，比如某些商品将会大促
静态热点可以通过大数据进行计算，得到Top数据
</code></pre><h4 id="动态热点"><a href="#动态热点" class="headerlink" title="动态热点"></a>动态热点</h4><pre><code>数据是不可以预测的，比如微博某个大V突发事件
如何检测动态热点，
1、构建一个异步的系统，收集各个交易链路上产生的热点key,例如RPC、缓存
2、建立一个热点上报与下发的规范，主要是把已经发现的热带你key透传给下游系统
3、将上游系统收集的热点数据发送到热点服务台，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，
然后做热点保护

我们通过部署在每台机器上的Agent把日志汇总到聚合和分析集群中，然后把符合一定规则的热点数据，
通过订阅分发系统再推送到相应的系统中。你可以是把热点数据填充到Cache中，或者直接推送到应用服务器的内存中，
还可以对这些数据进行拦截，总之下游系统可以订阅这些数据，然后根据自己的需求决定如何处理这些数据


打造热点发现系统时，我根据以往经验总结了几点注意事项。这个热点服务后台抓取热点数据日志最好采用异步方式，因为“异步”一方面便于保证通用性
，另一方面又不影响业务系统和中间件产品的主流程。
热点服务发现和中间件自身的热点保护模块并存，每个中间件和应用还需要保护自己。热点服务台提供热点数据的收集和订阅服务，便于把各个系统的热点数据透明出来。
热点发现要做到接近实时（3s内完成热点数据的发现），因为只有做到接近实时，动态发现才有意义，才能实时地对下游系统提供保护。
</code></pre><h4 id="处理热点数据"><a href="#处理热点数据" class="headerlink" title="处理热点数据"></a>处理热点数据</h4><pre><code>处理热点数据通常有几种思路：一是优化，二是限制，三是隔离
1、业务隔离

2、系统隔离

3、数据隔离
</code></pre><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><h1 id="从0开始学架构"><a href="#从0开始学架构" class="headerlink" title="从0开始学架构"></a>从0开始学架构</h1><h2 id="1、框架是什么"><a href="#1、框架是什么" class="headerlink" title="1、框架是什么"></a>1、框架是什么</h2><pre><code>软件架构指软件系统的顶层结构
</code></pre><h3 id="系统与子系统"><a href="#系统与子系统" class="headerlink" title="系统与子系统"></a>系统与子系统</h3><h3 id="模块与组件"><a href="#模块与组件" class="headerlink" title="模块与组件"></a>模块与组件</h3><pre><code>模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已
</code></pre><h3 id="框架与架构"><a href="#框架与架构" class="headerlink" title="框架与架构"></a>框架与架构</h3><pre><code>框架关注的是“规范”，架构关注的是“结构”。
框架的英文是Framework，架构的英文是Architecture。SpringMVC的英文文档标题就是“WebMVCframework”
</code></pre><h2 id="3、架构设计目的"><a href="#3、架构设计目的" class="headerlink" title="3、架构设计目的"></a>3、架构设计目的</h2><pre><code>架构设计的根本目的是为了解决软件系统复杂度带来的问题
从性能、可扩展性、安全性、成本等多个人方面考虑
</code></pre><h2 id="4、复杂度来源-性能"><a href="#4、复杂度来源-性能" class="headerlink" title="4、复杂度来源-性能"></a>4、复杂度来源-性能</h2><pre><code>单台计算机内部为了高性能带来的复杂度；另一方面是多台计算机集群为了高性能带来的复杂度
</code></pre><h3 id="单机复杂度"><a href="#单机复杂度" class="headerlink" title="单机复杂度"></a>单机复杂度</h3><pre><code>从进程到线程，
多进程多线程虽然让多任务并行处理的性能大大提升，但本质上还是分时系统，并不能做到时间上真正的并行。
</code></pre><h3 id="集群的复杂度"><a href="#集群的复杂度" class="headerlink" title="集群的复杂度"></a>集群的复杂度</h3><pre><code>1、任务分配
    横向扩展
2、任务拆解
    当各个逻辑任务分解到独立的子系统后，整个系统的性能瓶颈更加容易发现，
    而且发现后只需要针对有瓶颈的子系统进行性能优化或者提升，不需要改动整个系统，风险会小很多。
</code></pre><h2 id="5、复杂度来源-高可用"><a href="#5、复杂度来源-高可用" class="headerlink" title="5、复杂度来源-高可用"></a>5、复杂度来源-高可用</h2><h3 id="计算高可用"><a href="#计算高可用" class="headerlink" title="计算高可用"></a>计算高可用</h3><pre><code>双机计算需要以下条件
1、需要增加一个任务分配器
2、任务分配器需要增加分配算法
   常见的双机算法有主备、主主，主备方案又可以细分为冷备、温备、热备
</code></pre><h3 id="存储高可用"><a href="#存储高可用" class="headerlink" title="存储高可用"></a>存储高可用</h3><pre><code>存储与计算相比，有一个本质上的区别：将数据从一台机器搬到到另一台机器，需要经过线路进行传输。
存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响
</code></pre><h3 id="高可用状态决策"><a href="#高可用状态决策" class="headerlink" title="高可用状态决策"></a>高可用状态决策</h3><pre><code>无论是计算高可用还是存储高可用，其基础都是“状态决策”，
即系统需要能够判断当前的状态是正常还是异常，如果出现了异常就要采取行动来保证高可用。如果状态决策本身都是有错误或者有偏差的，
</code></pre><h4 id="1-独裁式"><a href="#1-独裁式" class="headerlink" title="1.独裁式"></a>1.独裁式</h4><pre><code>独裁式决策指的是存在一个独立的决策主体，我们姑且称它为“决策者”，
负责收集信息然后进行决策；所有冗余的个体，我们姑且称它为“上报者”，都将状态信息发送给决策者
</code></pre><h4 id="2-协商式"><a href="#2-协商式" class="headerlink" title="2.协商式"></a>2.协商式</h4><pre><code>主备决策
主&lt;----&gt;备

这个架构的基本协商规则可以设计成：
2台服务器启动时都是备机。2台服务器建立连接。2台服务器交换状态信息。
某1台服务器做出决策，成为主机；另一台服务器继续保持备机身份。

如果备机在连接中断的情况下认为主机故障， 那么备机需要升级为主机，
但实际上此时主机并没有故障，那么系统就出现了两个主机，这与设计初衷（1主1备）是不符合的
</code></pre><h4 id="3-民主式"><a href="#3-民主式" class="headerlink" title="3.民主式"></a>3.民主式</h4><pre><code>民主式决策指的是多个独立的个体通过投票的方式来进行状态决策。
例如，ZooKeeper集群在选举leader时就是采用这种方式。
民主式决策还有一个固有的缺陷：脑裂。
脑裂式来自医学，指人体左右大脑被切断后，左右大脑无法交换信息，各自做出决定
例如脑裂患者更衣，一只手拉起裤子，一只瘦脱下裤子。
为了解决脑裂问题，民主决策一般都是采用投票节点数量超过系统总节点数一半
</code></pre><h2 id="6、复杂度来源-可扩展性"><a href="#6、复杂度来源-可扩展性" class="headerlink" title="6、复杂度来源-可扩展性"></a>6、复杂度来源-可扩展性</h2><h3 id="预测变化"><a href="#预测变化" class="headerlink" title="预测变化"></a>预测变化</h3><pre><code>不能每个设计点都可以考虑到可扩展性
不能完全不考虑可扩展性
所有到预测都存在出错都可能性
</code></pre><h3 id="应对变化"><a href="#应对变化" class="headerlink" title="应对变化"></a>应对变化</h3><pre><code>第一种应对变化都常见方案就是 将&quot;变化&quot;封装在一个&quot;变化层&quot;，将不变化的部分封装在一个 独立的稳定层。
无论是变化层依赖稳定层，还是稳定层依赖变化层都是可以的
例如系统会用到的nosql, 可能是redis,后面可能会切到mogo，所以我们就需要提前设计一个
repository层，用来隔离后面的变化
</code></pre><h4 id="复杂度-系统需要拆分出变化层和稳定层"><a href="#复杂度-系统需要拆分出变化层和稳定层" class="headerlink" title="复杂度-系统需要拆分出变化层和稳定层"></a>复杂度-系统需要拆分出变化层和稳定层</h4><pre><code>对于那些是变化层，那些是稳定层，不同的人有不一样的理解
</code></pre><h4 id="复杂度-需要设计变化层和稳定层之间的接口"><a href="#复杂度-需要设计变化层和稳定层之间的接口" class="headerlink" title="复杂度-需要设计变化层和稳定层之间的接口"></a>复杂度-需要设计变化层和稳定层之间的接口</h4><pre><code>提炼出一个“抽象层”和一个“实现层”。抽象层是稳定的，实现层可以根据具体业务需要定制开发，当加入新的功能时
</code></pre><h2 id="7、复杂度来源-低成本、安全、规模"><a href="#7、复杂度来源-低成本、安全、规模" class="headerlink" title="7、复杂度来源-低成本、安全、规模"></a>7、复杂度来源-低成本、安全、规模</h2><h3 id="低成本"><a href="#低成本" class="headerlink" title="低成本"></a>低成本</h3><pre><code>NoSQL（Memcache、Redis等）的出现是为了解决关系型数据库无法应对高并发访问带来的访问压力

全文搜索引擎（Sphinx、Elasticsearch、Solr）的出现是为了解决关系型数据库like搜索的低效的问题

Hadoop的出现是为了解决传统文件系统无法应对海量数据存储和计算的问题。

新浪微博将传统的Redis/MC+MySQL方式，扩展为Redis/MC+SSDCache+MySQL方式，

SSDCache作为L2缓存使用，既解决了MC/Redis成本过高，容量小的问题，也解决了穿透DB带来的数据库访问压力

Linkedin为了处理每天5千亿的事件，开发了高效的Kafka消息系统
</code></pre><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><h4 id="1、功能安全"><a href="#1、功能安全" class="headerlink" title="1、功能安全"></a>1、功能安全</h4><pre><code>xss、csrf、sql注入
</code></pre><h4 id="2、架构安全"><a href="#2、架构安全" class="headerlink" title="2、架构安全"></a>2、架构安全</h4><pre><code>防火墙，ddos
互联网系统的架构安全目前并没有太好的设计手段来实现，更多地是依靠运营商或者云服务商强大的带宽和流量清洗的能力，较少自己来设计和实现
</code></pre><h3 id="规模"><a href="#规模" class="headerlink" title="规模"></a>规模</h3><h4 id="1-功能越来越多，导致系统复杂度指数级上升"><a href="#1-功能越来越多，导致系统复杂度指数级上升" class="headerlink" title="1.功能越来越多，导致系统复杂度指数级上升"></a>1.功能越来越多，导致系统复杂度指数级上升</h4><pre><code>各个功能相互耦合
</code></pre><h4 id="2-数据越来越多，系统复杂度发生质变"><a href="#2-数据越来越多，系统复杂度发生质变" class="headerlink" title="2.数据越来越多，系统复杂度发生质变"></a>2.数据越来越多，系统复杂度发生质变</h4><pre><code>例如mysql数据量变多，就要考虑分库分表
</code></pre><h2 id="08架构设计三原则"><a href="#08架构设计三原则" class="headerlink" title="08架构设计三原则"></a>08架构设计三原则</h2><pre><code>业务千变万化，技术层出不穷，设计理念也是百花齐放，看起来似乎很难有一套通用的规范来适用所有的架构设计场景。
但是在研究了架构设计的发展历史、多个公司的架构发展过程（QQ、淘宝、Facebook等）、众多的互联网公司架构设计后，
我发现有几个共性的原则隐含其中，这就是：合适原则、简单原则、演化原则，架构设计时遵循这几个原则，有助于你做出最好的选择。
</code></pre><h3 id="合适原则（合适优于业界领先）"><a href="#合适原则（合适优于业界领先）" class="headerlink" title="合适原则（合适优于业界领先）"></a>合适原则（合适优于业界领先）</h3><pre><code>不能硬搬别人的架构，想达到业界领先的水平。因为你没有别人公司的团队配置，和积累，以及业务场景，所以不能硬套方案
</code></pre><h3 id="简单原则（简单优于复杂）"><a href="#简单原则（简单优于复杂）" class="headerlink" title="简单原则（简单优于复杂）"></a>简单原则（简单优于复杂）</h3><pre><code>结构复杂的系统几乎毫无例外具备两个特点：组成复杂系统的组件数量更多；同时这些组件之间的关系也更加复杂。
某个组件改动，会影响关联的所有组件
定位一个复杂系统中的问题总是比简单系统更加困难
</code></pre><h3 id="演化原则-（演化优于一步到位）"><a href="#演化原则-（演化优于一步到位）" class="headerlink" title="演化原则 （演化优于一步到位）"></a>演化原则 （演化优于一步到位）</h3><pre><code>架构师在进行架构设计时需要牢记这个原则，时刻提醒自己不要贪大求全，或者盲目照搬大公司的做法。
应该认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构

即使是大公司的团队，在设计一个新系统的架构时，也需要遵循演化的原则，而不应该认为团队人员多、资源多，
不管什么系统上来就要一步到位，因为业务的发展和变化是很快的，不管多牛的团队，也不可能完美预测所有的业务发展和变化路径。
</code></pre><h2 id="10、架构设计流程"><a href="#10、架构设计流程" class="headerlink" title="10、架构设计流程"></a>10、架构设计流程</h2><h3 id="架构设计第1步：识别复杂度"><a href="#架构设计第1步：识别复杂度" class="headerlink" title="架构设计第1步：识别复杂度"></a>架构设计第1步：识别复杂度</h3><pre><code>将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂度问题。
</code></pre><h4 id="识别复杂度（消息队列）"><a href="#识别复杂度（消息队列）" class="headerlink" title="识别复杂度（消息队列）"></a>识别复杂度（消息队列）</h4><pre><code>1、这个消息队列是否需要高性能
2、这个消息队列是否需要高可用性
3、这个消息队列是否需要高可扩展性
</code></pre><h3 id="架构设计第2步：设计备选方案"><a href="#架构设计第2步：设计备选方案" class="headerlink" title="架构设计第2步：设计备选方案"></a>架构设计第2步：设计备选方案</h3><pre><code>架构师的工作并不神秘，成熟的架构师需要对已经存在的技术非常熟悉，对已经经过验证的架构模式烂熟于心，
然后根据自己对业务的理解，挑选合适的架构模式进行组合，再对组合后的方案进行修改和调整
</code></pre><h4 id="技术组合"><a href="#技术组合" class="headerlink" title="技术组合"></a>技术组合</h4><pre><code>NoSQL：KeyValue的存储和数据库的索引其实是类似的，
Memcache只是把数据库的索引独立出来做成了一个缓存系统。
Hadoop大文件存储方案，基础其实是集群方案+数据复制方案。
Docker虚拟化，基础是LXC（LinuxContainers）。
LevelDB的文件存储结构是SkipList。
</code></pre><h4 id="场景误区"><a href="#场景误区" class="headerlink" title="场景误区"></a>场景误区</h4><h5 id="1、设计最优秀的答案"><a href="#1、设计最优秀的答案" class="headerlink" title="1、设计最优秀的答案"></a>1、设计最优秀的答案</h5><h5 id="2、只做一个方案"><a href="#2、只做一个方案" class="headerlink" title="2、只做一个方案"></a>2、只做一个方案</h5><pre><code>备选方案的数量以3~5个为最佳，
备选方案的差异要比较明显
备选方案的技术不要只局限于已经熟悉的技术
</code></pre><h5 id="3、备选方案过于详细"><a href="#3、备选方案过于详细" class="headerlink" title="3、备选方案过于详细"></a>3、备选方案过于详细</h5><h4 id="设计备选方案实战（消息队列）"><a href="#设计备选方案实战（消息队列）" class="headerlink" title="设计备选方案实战（消息队列）"></a>设计备选方案实战（消息队列）</h4><pre><code>1、采用开源的Kafka
2、集群+MySQL存储
3、集群+自研存储方案
</code></pre><h3 id="架构设计第3步：评估和选择备选方案"><a href="#架构设计第3步：评估和选择备选方案" class="headerlink" title="架构设计第3步：评估和选择备选方案"></a>架构设计第3步：评估和选择备选方案</h3><pre><code>列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案
常见的方案质量属性点有：性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性等。
在评估这些质量属性时，需要遵循架构设计原则1“合适原则”和原则2“简单原则”，避免贪大求全，
基本上某个质量属性能够满足一定时期内业务发展就可以了。
</code></pre><h3 id="架构设计第4步：详细方案设计"><a href="#架构设计第4步：详细方案设计" class="headerlink" title="架构设计第4步：详细方案设计"></a>架构设计第4步：详细方案设计</h3><pre><code>详细方案设计就是将方案涉及的关键技术细节给确定下来
</code></pre><h4 id="详细方案实战（消息队列）"><a href="#详细方案实战（消息队列）" class="headerlink" title="详细方案实战（消息队列）"></a>详细方案实战（消息队列）</h4><h5 id="1、数据库表如何设计"><a href="#1、数据库表如何设计" class="headerlink" title="1、数据库表如何设计"></a>1、数据库表如何设计</h5><pre><code>数据库设计两类表，一类是日志表，用于消息写入时快速存储到MySQL中；另一类是消息表，每个消息队列一张表。
业务系统发布消息时，首先写入到日志表，日志表写入成功就代表消息写入成功；
后台线程再从日志表中读取消息写入记录，将消息内容写入到消息表中。
业务系统读取消息时，从消息表中读取。
日志表表名为MQ_LOG，包含的字段：日志ID、发布者信息、发布时间、队列名称、消息内容。
</code></pre><h5 id="2、数据如何复制"><a href="#2、数据如何复制" class="headerlink" title="2、数据如何复制"></a>2、数据如何复制</h5><pre><code>直接采用MySQL主从复制即可，只复制消息存储表，不复制日志表
</code></pre><h5 id="3、业务服务器如何写入消息"><a href="#3、业务服务器如何写入消息" class="headerlink" title="3、业务服务器如何写入消息"></a>3、业务服务器如何写入消息</h5><pre><code>消息队列系统设计两个角色：生产者和消费者，每个角色都有唯一的名称。
消息队列系统提供SDK供各业务系统调用，SDK从配置中读取所有消息队列系统的服务器信息，
SDK采取轮询算法发起消息写入请求给主服务器。如果某个主服务器无响应或者返回错误，SDK将发起请求发送到下一台服务器。
</code></pre><h2 id="14、高性能数据库集群-读写分离"><a href="#14、高性能数据库集群-读写分离" class="headerlink" title="14、高性能数据库集群-读写分离"></a>14、高性能数据库集群-读写分离</h2><h3 id="读写分离的基本实现"><a href="#读写分离的基本实现" class="headerlink" title="读写分离的基本实现"></a>读写分离的基本实现</h3><ul>
<li>数据库服务器搭建主从集群，一主一从、一主多从都可以。</li>
<li>数据库主机负责读写操作，从机只负责读操作。数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。</li>
<li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机。</li>
</ul>
<blockquote>
<p>需要注意的是，这里用的是“主从集群”，而不是“主备集群”。“从机”的“从”可以理解为“仆从”，仆从是要帮主人干活的， “从机”是需要提供读数据的功能的；而“备机”一般被认为仅仅提供备份功能，不提供访问功能。 所以使用“主从”还是“主备”，是要看场景的，这两个词并不是完全等同的。</p>
<h3 id="复制延迟"><a href="#复制延迟" class="headerlink" title="复制延迟"></a>复制延迟</h3><pre><code>主从复制会有延迟，如果写入到主库的数据 要马上查询到，就需要强制走主库查询
</code></pre><h3 id="分配机制"><a href="#分配机制" class="headerlink" title="分配机制"></a>分配机制</h3><pre><code>中间件与代码封装
</code></pre></blockquote>
<h2 id="15、高性能数据库集群-分库分表"><a href="#15、高性能数据库集群-分库分表" class="headerlink" title="15、高性能数据库集群-分库分表"></a>15、高性能数据库集群-分库分表</h2><h3 id="业务分库"><a href="#业务分库" class="headerlink" title="业务分库"></a>业务分库</h3><p>   1、join操作问题<br>   2、事物问题<br>   3、成本问题</p>
<h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><pre><code>垂直分表和水平分表
</code></pre><h2 id="16、高性能NOSQL"><a href="#16、高性能NOSQL" class="headerlink" title="16、高性能NOSQL"></a>16、高性能NOSQL</h2><pre><code>常见的NoSQL方案分为4类。
KV存储：解决关系数据库无法存储数据结构的问题，以Redis为代表。
文档数据库：解决关系数据库强schema约束的问题，以MongoDB为代表。
列式数据库：解决关系数据库大数据场景下的I/O问题，以HBase为代表。
全文搜索引擎：解决关系数据库的全文搜索性能问题，以Elasticsearch为代表。
</code></pre><h3 id="mogodb"><a href="#mogodb" class="headerlink" title="mogodb"></a>mogodb</h3><pre><code>为了解决关系数据库schema带来的问题，文档数据库应运而生。文档数据库最大的特点就是noschema，可以存储和读取任意的数据。
所存即所见
优点：
1、新增字段简单
2、历史数据不会出错
3、可以很容易存储复杂数据
</code></pre>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/22/java8-lamad表达式一些用法/" rel="next" title="java8 lamad表达式一些用法">
                <i class="fa fa-chevron-left"></i> java8 lamad表达式一些用法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/06/分布式ID/" rel="prev" title="分布式ID">
                分布式ID <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatar.csdnimg.cn/1/E/3/ggj20ss.jpg"
               alt="ggj2010" />
          <p class="site-author-name" itemprop="name">ggj2010</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">42</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ggj2010" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/ggjlvzjy" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#10x程序员工作法"><span class="nav-number">1.</span> <span class="nav-text">10x程序员工作法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序员解决的问题，大多不是程序问题"><span class="nav-number">1.1.</span> <span class="nav-text">程序员解决的问题，大多不是程序问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序员是如何思考"><span class="nav-number">1.2.</span> <span class="nav-text">程序员是如何思考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#以终为始"><span class="nav-number">1.3.</span> <span class="nav-text">以终为始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你完成了工作，为什么他们还不满意？"><span class="nav-number">1.4.</span> <span class="nav-text">你完成了工作，为什么他们还不满意？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接到需求任务，你要先做哪件事"><span class="nav-number">1.5.</span> <span class="nav-text">接到需求任务，你要先做哪件事</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#持续集成：集成本身就是写代码的一个环节"><span class="nav-number">1.6.</span> <span class="nav-text">持续集成：集成本身就是写代码的一个环节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#精益创业：产品经理不靠谱，你该怎么办？"><span class="nav-number">1.7.</span> <span class="nav-text">精益创业：产品经理不靠谱，你该怎么办？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决了很多技术问题，为什么你依然在“坑”里？"><span class="nav-number">1.8.</span> <span class="nav-text">解决了很多技术问题，为什么你依然在“坑”里？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么说做事之前要先进行推演"><span class="nav-number">1.9.</span> <span class="nav-text">为什么说做事之前要先进行推演</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你的工作可以用数字衡量吗？"><span class="nav-number">1.10.</span> <span class="nav-text">你的工作可以用数字衡量吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代0-启动开发之前，你应该准备什么"><span class="nav-number">1.11.</span> <span class="nav-text">迭代0: 启动开发之前，你应该准备什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#答疑解惑-如何管理你的上级"><span class="nav-number">1.12.</span> <span class="nav-text">答疑解惑 | 如何管理你的上级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题-1：领导要求的，无力反驳怎么办？"><span class="nav-number">1.12.1.</span> <span class="nav-text">问题 1：领导要求的，无力反驳怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题-2：产品经理总拿老板说事，怎么办？"><span class="nav-number">1.12.2.</span> <span class="nav-text">问题 2：产品经理总拿老板说事，怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题-3：别人能做的，我们也要做"><span class="nav-number">1.12.3.</span> <span class="nav-text">问题 3：别人能做的，我们也要做</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向埃隆·马斯克学习任务分解"><span class="nav-number">1.13.</span> <span class="nav-text">向埃隆·马斯克学习任务分解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试也是程序员的事吗"><span class="nav-number">1.14.</span> <span class="nav-text">测试也是程序员的事吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#先写测试，就是测试驱动开发吗？"><span class="nav-number">1.15.</span> <span class="nav-text">先写测试，就是测试驱动开发吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大师级程序员的工作秘笈"><span class="nav-number">1.16.</span> <span class="nav-text">大师级程序员的工作秘笈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一起练习：手把手带你分解任务"><span class="nav-number">1.17.</span> <span class="nav-text">一起练习：手把手带你分解任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序员也可以“砍”需求吗"><span class="nav-number">1.18.</span> <span class="nav-text">程序员也可以“砍”需求吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求管理：太多人给你安排任务，怎么办"><span class="nav-number">1.19.</span> <span class="nav-text">需求管理：太多人给你安排任务，怎么办</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么世界和你的理解不一样"><span class="nav-number">1.20.</span> <span class="nav-text">为什么世界和你的理解不一样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#轻量级沟通：你总是在开会吗？"><span class="nav-number">1.21.</span> <span class="nav-text">轻量级沟通：你总是在开会吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可视化：一种更为直观的沟通方式"><span class="nav-number">1.22.</span> <span class="nav-text">可视化：一种更为直观的沟通方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速反馈：为什么你们公司总是做不好持续集成"><span class="nav-number">1.23.</span> <span class="nav-text">快速反馈：为什么你们公司总是做不好持续集成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发中的问题一再出现，应该怎么办"><span class="nav-number">1.24.</span> <span class="nav-text">开发中的问题一再出现，应该怎么办</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尽早暴露问题：-为什么被指责的总是你"><span class="nav-number">1.25.</span> <span class="nav-text">尽早暴露问题： 为什么被指责的总是你</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你的代码是怎么变混乱的"><span class="nav-number">1.26.</span> <span class="nav-text">你的代码是怎么变混乱的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面对遗留系统，你应该这样做"><span class="nav-number">1.27.</span> <span class="nav-text">面对遗留系统，你应该这样做</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#我们应该如何保持竞争力"><span class="nav-number">1.28.</span> <span class="nav-text">我们应该如何保持竞争力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#书单"><span class="nav-number">1.29.</span> <span class="nav-text">书单</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#代码精进之路"><span class="nav-number">2.</span> <span class="nav-text">代码精进之路</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#从条件运算符说起，反思什么是好代码"><span class="nav-number">2.1.</span> <span class="nav-text">从条件运算符说起，反思什么是好代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#把错误关在笼子里"><span class="nav-number">2.2.</span> <span class="nav-text">把错误关在笼子里</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写好声明的“八项纪律”"><span class="nav-number">2.3.</span> <span class="nav-text">写好声明的“八项纪律”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么用好Java注解？"><span class="nav-number">2.4.</span> <span class="nav-text">怎么用好Java注解？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理都有哪些陷阱"><span class="nav-number">2.5.</span> <span class="nav-text">异常处理都有哪些陷阱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写规范代码的检查清单"><span class="nav-number">2.6.</span> <span class="nav-text">编写规范代码的检查清单</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#技术管理实战36讲"><span class="nav-number">3.</span> <span class="nav-text">技术管理实战36讲</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#哪些人比较容易走上管理岗位？"><span class="nav-number">3.1.</span> <span class="nav-text">哪些人比较容易走上管理岗位？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#左耳听风"><span class="nav-number">4.</span> <span class="nav-text">左耳听风</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#技术变现"><span class="nav-number">4.1.</span> <span class="nav-text">技术变现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#技术领导力"><span class="nav-number">4.2.</span> <span class="nav-text">技术领导力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理"><span class="nav-number">4.3.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间管理"><span class="nav-number">4.4.</span> <span class="nav-text">时间管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#阿甘老师管理方法论整理"><span class="nav-number">5.</span> <span class="nav-text">阿甘老师管理方法论整理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#管理最有效能的事情还是让团队成长和提升"><span class="nav-number">5.1.</span> <span class="nav-text">管理最有效能的事情还是让团队成长和提升</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#人是企业最重要资产也是最重要的产品，就是要靠企业来培养"><span class="nav-number">5.2.</span> <span class="nav-text">人是企业最重要资产也是最重要的产品，就是要靠企业来培养</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过程比结果更重要。对。掌握正确的过程才能复制出好的结果，凡夫畏果，菩萨畏因"><span class="nav-number">5.3.</span> <span class="nav-text">过程比结果更重要。对。掌握正确的过程才能复制出好的结果，凡夫畏果，菩萨畏因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管理6个基本动作"><span class="nav-number">5.4.</span> <span class="nav-text">管理6个基本动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#领导力四要素"><span class="nav-number">5.5.</span> <span class="nav-text">领导力四要素</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#技术人的灵魂3问，阿里工程师如何解答？"><span class="nav-number">6.</span> <span class="nav-text">技术人的灵魂3问，阿里工程师如何解答？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何在业务中发现有技术价值的问题？"><span class="nav-number">6.1.</span> <span class="nav-text">如何在业务中发现有技术价值的问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#收集信息"><span class="nav-number">6.1.1.</span> <span class="nav-text">收集信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析问题"><span class="nav-number">6.1.2.</span> <span class="nav-text">分析问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发现问题到执行该如何衔接"><span class="nav-number">6.2.</span> <span class="nav-text">发现问题到执行该如何衔接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最后的技术结果跟业务结果如何衔接"><span class="nav-number">6.3.</span> <span class="nav-text">最后的技术结果跟业务结果如何衔接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#推荐书籍"><span class="nav-number">6.4.</span> <span class="nav-text">推荐书籍</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#程序员的成长路线Remix-HelloJava公众号"><span class="nav-number">7.</span> <span class="nav-text">程序员的成长路线Remix(HelloJava公众号)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编程能力的成长"><span class="nav-number">7.1.</span> <span class="nav-text">编程能力的成长</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#我在Uber运营大型分布式系统三年经验谈-InfoQ公众号"><span class="nav-number">7.2.</span> <span class="nav-text">我在Uber运营大型分布式系统三年经验谈(InfoQ公众号)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#项目管理实战20讲"><span class="nav-number">8.</span> <span class="nav-text">项目管理实战20讲</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DDD实战课"><span class="nav-number">9.</span> <span class="nav-text">DDD实战课</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、领域驱动设计：微服务设计为什么要选择DDD"><span class="nav-number">9.1.</span> <span class="nav-text">1、领域驱动设计：微服务设计为什么要选择DDD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#战略设计"><span class="nav-number">9.1.1.</span> <span class="nav-text">战略设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#战术设计"><span class="nav-number">9.1.2.</span> <span class="nav-text">战术设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三步划定领域模型和微服务的边界"><span class="nav-number">9.1.3.</span> <span class="nav-text">三步划定领域模型和微服务的边界</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、领域、子域、核心域、通用域、支撑域"><span class="nav-number">9.2.</span> <span class="nav-text">2、领域、子域、核心域、通用域、支撑域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何理解领域与子域"><span class="nav-number">9.2.1.</span> <span class="nav-text">如何理解领域与子域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何理解核心域、通用域和支撑域"><span class="nav-number">9.2.2.</span> <span class="nav-text">如何理解核心域、通用域和支撑域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、限界上下文：定义领域边界的利器"><span class="nav-number">9.3.</span> <span class="nav-text">3、限界上下文：定义领域边界的利器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通用语言"><span class="nav-number">9.3.1.</span> <span class="nav-text">通用语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是限界上下文？"><span class="nav-number">9.3.2.</span> <span class="nav-text">什么是限界上下文？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限界上下文和微服务的关系"><span class="nav-number">9.3.3.</span> <span class="nav-text">限界上下文和微服务的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、实体和值对象"><span class="nav-number">9.4.</span> <span class="nav-text">4、实体和值对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实体"><span class="nav-number">9.4.1.</span> <span class="nav-text">实体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-实体的业务形态"><span class="nav-number">9.4.1.1.</span> <span class="nav-text">1.实体的业务形态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-实体的代码形态"><span class="nav-number">9.4.1.2.</span> <span class="nav-text">2.实体的代码形态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-实体的运行形态"><span class="nav-number">9.4.1.3.</span> <span class="nav-text">3.实体的运行形态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-实体的数据库形态"><span class="nav-number">9.4.1.4.</span> <span class="nav-text">4.实体的数据库形态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#值对象"><span class="nav-number">9.4.2.</span> <span class="nav-text">值对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-值对象的业务形态"><span class="nav-number">9.4.2.1.</span> <span class="nav-text">1.值对象的业务形态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-值对象的代码形态"><span class="nav-number">9.4.2.2.</span> <span class="nav-text">2.值对象的代码形态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-值对象的运行形态"><span class="nav-number">9.4.2.3.</span> <span class="nav-text">3.值对象的运行形态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-值对象的数据库形态"><span class="nav-number">9.4.2.4.</span> <span class="nav-text">4.值对象的数据库形态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-值对象的优势和局限"><span class="nav-number">9.4.2.5.</span> <span class="nav-text">5.值对象的优势和局限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-实体和值对象的关系"><span class="nav-number">9.4.2.6.</span> <span class="nav-text">6.实体和值对象的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#05-聚合和聚合根：怎样设计聚合？"><span class="nav-number">9.4.3.</span> <span class="nav-text">05-聚合和聚合根：怎样设计聚合？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#聚合根"><span class="nav-number">9.4.3.1.</span> <span class="nav-text">聚合根</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#怎样设计聚合"><span class="nav-number">9.4.3.2.</span> <span class="nav-text">怎样设计聚合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#聚合的一些设计原则"><span class="nav-number">9.4.3.3.</span> <span class="nav-text">聚合的一些设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-在一致性边界内建模真正的不变条件"><span class="nav-number">9.4.3.3.1.</span> <span class="nav-text">1.在一致性边界内建模真正的不变条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-设计小聚合"><span class="nav-number">9.4.3.3.2.</span> <span class="nav-text">2.设计小聚合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-通过唯一标识引用其它聚合"><span class="nav-number">9.4.3.3.3.</span> <span class="nav-text">3.通过唯一标识引用其它聚合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-在边界之外使用最终一致性"><span class="nav-number">9.4.3.3.4.</span> <span class="nav-text">4.在边界之外使用最终一致性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-通过应用层实现跨聚合的服务调用。"><span class="nav-number">9.4.3.3.5.</span> <span class="nav-text">5.通过应用层实现跨聚合的服务调用。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#06-领域事件：解耦微服务的关键"><span class="nav-number">9.4.4.</span> <span class="nav-text">06-领域事件：解耦微服务的关键</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-微服务内的领域事件"><span class="nav-number">9.4.4.1.</span> <span class="nav-text">1.微服务内的领域事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-微服务内的领域事件"><span class="nav-number">9.4.4.2.</span> <span class="nav-text">2.微服务内的领域事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#领域事件总体架构"><span class="nav-number">9.4.4.3.</span> <span class="nav-text">领域事件总体架构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#07-DDD分层架构：有效降低层与层之间的依赖"><span class="nav-number">9.4.5.</span> <span class="nav-text">07-DDD分层架构：有效降低层与层之间的依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用户层"><span class="nav-number">9.4.5.1.</span> <span class="nav-text">用户层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用层"><span class="nav-number">9.4.5.2.</span> <span class="nav-text">应用层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#领域层"><span class="nav-number">9.4.5.3.</span> <span class="nav-text">领域层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基础层"><span class="nav-number">9.4.5.4.</span> <span class="nav-text">基础层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DDD分层架构最重要的原则是什么"><span class="nav-number">9.4.5.5.</span> <span class="nav-text">DDD分层架构最重要的原则是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三层架构如何演变成四层架构"><span class="nav-number">9.4.5.6.</span> <span class="nav-text">三层架构如何演变成四层架构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08微服务架构模型：几种常见模型的对比和分析"><span class="nav-number">9.4.6.</span> <span class="nav-text">08微服务架构模型：几种常见模型的对比和分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#整洁架构"><span class="nav-number">9.4.6.1.</span> <span class="nav-text">整洁架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六边形架构"><span class="nav-number">9.4.6.2.</span> <span class="nav-text">六边形架构</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络编程实战"><span class="nav-number">10.</span> <span class="nav-text">网络编程实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#02-网络编程模型：认识客户端-服务器网络模型的基本概念"><span class="nav-number">10.1.</span> <span class="nav-text">02 | 网络编程模型：认识客户端-服务器网络模型的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04-TCP三次握手：怎么使用套接字格式建立连接"><span class="nav-number">10.2.</span> <span class="nav-text">04 | TCP三次握手：怎么使用套接字格式建立连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-TIME-WAIT：隐藏在细节下的魔鬼"><span class="nav-number">10.3.</span> <span class="nav-text">10 | TIME_WAIT：隐藏在细节下的魔鬼</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-优雅地关闭还是粗暴地关闭"><span class="nav-number">10.4.</span> <span class="nav-text">11 | 优雅地关闭还是粗暴地关闭 ?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何设计一个秒杀系统"><span class="nav-number">11.</span> <span class="nav-text">如何设计一个秒杀系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#设计秒杀系统时应该注意的5个架构原则"><span class="nav-number">11.1.</span> <span class="nav-text">设计秒杀系统时应该注意的5个架构原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不同场景下的不同架构案例"><span class="nav-number">11.1.1.</span> <span class="nav-text">不同场景下的不同架构案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#03二八原则：有针对性地处理好系统的“热点数据”"><span class="nav-number">11.1.2.</span> <span class="nav-text">03二八原则：有针对性地处理好系统的“热点数据”</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态热点"><span class="nav-number">11.1.2.1.</span> <span class="nav-text">静态热点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态热点"><span class="nav-number">11.1.2.2.</span> <span class="nav-text">动态热点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理热点数据"><span class="nav-number">11.1.2.3.</span> <span class="nav-text">处理热点数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流量削峰"><span class="nav-number">11.1.3.</span> <span class="nav-text">流量削峰</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从0开始学架构"><span class="nav-number">12.</span> <span class="nav-text">从0开始学架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、框架是什么"><span class="nav-number">12.1.</span> <span class="nav-text">1、框架是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#系统与子系统"><span class="nav-number">12.1.1.</span> <span class="nav-text">系统与子系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块与组件"><span class="nav-number">12.1.2.</span> <span class="nav-text">模块与组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#框架与架构"><span class="nav-number">12.1.3.</span> <span class="nav-text">框架与架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、架构设计目的"><span class="nav-number">12.2.</span> <span class="nav-text">3、架构设计目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、复杂度来源-性能"><span class="nav-number">12.3.</span> <span class="nav-text">4、复杂度来源-性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单机复杂度"><span class="nav-number">12.3.1.</span> <span class="nav-text">单机复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群的复杂度"><span class="nav-number">12.3.2.</span> <span class="nav-text">集群的复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、复杂度来源-高可用"><span class="nav-number">12.4.</span> <span class="nav-text">5、复杂度来源-高可用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算高可用"><span class="nav-number">12.4.1.</span> <span class="nav-text">计算高可用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储高可用"><span class="nav-number">12.4.2.</span> <span class="nav-text">存储高可用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高可用状态决策"><span class="nav-number">12.4.3.</span> <span class="nav-text">高可用状态决策</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-独裁式"><span class="nav-number">12.4.3.1.</span> <span class="nav-text">1.独裁式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-协商式"><span class="nav-number">12.4.3.2.</span> <span class="nav-text">2.协商式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-民主式"><span class="nav-number">12.4.3.3.</span> <span class="nav-text">3.民主式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、复杂度来源-可扩展性"><span class="nav-number">12.5.</span> <span class="nav-text">6、复杂度来源-可扩展性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#预测变化"><span class="nav-number">12.5.1.</span> <span class="nav-text">预测变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应对变化"><span class="nav-number">12.5.2.</span> <span class="nav-text">应对变化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度-系统需要拆分出变化层和稳定层"><span class="nav-number">12.5.2.1.</span> <span class="nav-text">复杂度-系统需要拆分出变化层和稳定层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度-需要设计变化层和稳定层之间的接口"><span class="nav-number">12.5.2.2.</span> <span class="nav-text">复杂度-需要设计变化层和稳定层之间的接口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、复杂度来源-低成本、安全、规模"><span class="nav-number">12.6.</span> <span class="nav-text">7、复杂度来源-低成本、安全、规模</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#低成本"><span class="nav-number">12.6.1.</span> <span class="nav-text">低成本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全"><span class="nav-number">12.6.2.</span> <span class="nav-text">安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、功能安全"><span class="nav-number">12.6.2.1.</span> <span class="nav-text">1、功能安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、架构安全"><span class="nav-number">12.6.2.2.</span> <span class="nav-text">2、架构安全</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规模"><span class="nav-number">12.6.3.</span> <span class="nav-text">规模</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-功能越来越多，导致系统复杂度指数级上升"><span class="nav-number">12.6.3.1.</span> <span class="nav-text">1.功能越来越多，导致系统复杂度指数级上升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-数据越来越多，系统复杂度发生质变"><span class="nav-number">12.6.3.2.</span> <span class="nav-text">2.数据越来越多，系统复杂度发生质变</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#08架构设计三原则"><span class="nav-number">12.7.</span> <span class="nav-text">08架构设计三原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#合适原则（合适优于业界领先）"><span class="nav-number">12.7.1.</span> <span class="nav-text">合适原则（合适优于业界领先）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单原则（简单优于复杂）"><span class="nav-number">12.7.2.</span> <span class="nav-text">简单原则（简单优于复杂）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#演化原则-（演化优于一步到位）"><span class="nav-number">12.7.3.</span> <span class="nav-text">演化原则 （演化优于一步到位）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、架构设计流程"><span class="nav-number">12.8.</span> <span class="nav-text">10、架构设计流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#架构设计第1步：识别复杂度"><span class="nav-number">12.8.1.</span> <span class="nav-text">架构设计第1步：识别复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#识别复杂度（消息队列）"><span class="nav-number">12.8.1.1.</span> <span class="nav-text">识别复杂度（消息队列）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#架构设计第2步：设计备选方案"><span class="nav-number">12.8.2.</span> <span class="nav-text">架构设计第2步：设计备选方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#技术组合"><span class="nav-number">12.8.2.1.</span> <span class="nav-text">技术组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#场景误区"><span class="nav-number">12.8.2.2.</span> <span class="nav-text">场景误区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、设计最优秀的答案"><span class="nav-number">12.8.2.2.1.</span> <span class="nav-text">1、设计最优秀的答案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、只做一个方案"><span class="nav-number">12.8.2.2.2.</span> <span class="nav-text">2、只做一个方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、备选方案过于详细"><span class="nav-number">12.8.2.2.3.</span> <span class="nav-text">3、备选方案过于详细</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设计备选方案实战（消息队列）"><span class="nav-number">12.8.2.3.</span> <span class="nav-text">设计备选方案实战（消息队列）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#架构设计第3步：评估和选择备选方案"><span class="nav-number">12.8.3.</span> <span class="nav-text">架构设计第3步：评估和选择备选方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#架构设计第4步：详细方案设计"><span class="nav-number">12.8.4.</span> <span class="nav-text">架构设计第4步：详细方案设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#详细方案实战（消息队列）"><span class="nav-number">12.8.4.1.</span> <span class="nav-text">详细方案实战（消息队列）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、数据库表如何设计"><span class="nav-number">12.8.4.1.1.</span> <span class="nav-text">1、数据库表如何设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、数据如何复制"><span class="nav-number">12.8.4.1.2.</span> <span class="nav-text">2、数据如何复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、业务服务器如何写入消息"><span class="nav-number">12.8.4.1.3.</span> <span class="nav-text">3、业务服务器如何写入消息</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14、高性能数据库集群-读写分离"><span class="nav-number">12.9.</span> <span class="nav-text">14、高性能数据库集群-读写分离</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读写分离的基本实现"><span class="nav-number">12.9.1.</span> <span class="nav-text">读写分离的基本实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制延迟"><span class="nav-number">12.9.2.</span> <span class="nav-text">复制延迟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配机制"><span class="nav-number">12.9.3.</span> <span class="nav-text">分配机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15、高性能数据库集群-分库分表"><span class="nav-number">12.10.</span> <span class="nav-text">15、高性能数据库集群-分库分表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#业务分库"><span class="nav-number">12.10.1.</span> <span class="nav-text">业务分库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分表"><span class="nav-number">12.10.2.</span> <span class="nav-text">分表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16、高性能NOSQL"><span class="nav-number">12.11.</span> <span class="nav-text">16、高性能NOSQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mogodb"><span class="nav-number">12.11.1.</span> <span class="nav-text">mogodb</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ggj2010</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
