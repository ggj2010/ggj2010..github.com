<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="笔记," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="最近几年总觉得脑子不够用，一会想学这个，一会想看哪个，一天可能一行代码也没写就这么度过了。 这个文章就当自己的学习记录吧，想到什么写什么，虽然有有道笔记，但是里面的记录的东西太乱了， 感觉就是个查问题的笔记库，有时间再整理下吧。。。 201702221.关于数据库的分库分表，主从技术落地。 201702231.以后面试要首先问涨薪体系！2.批处理数据的时候，要控制数据的数量，比如批量插入的时候，每">
<meta name="keywords" content="笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="技术储备-长期记录">
<meta property="og:url" content="http://ggj2010.github.io/2017/02/22/技术储备-长期记录/index.html">
<meta property="og:site_name" content="高广金博客">
<meta property="og:description" content="最近几年总觉得脑子不够用，一会想学这个，一会想看哪个，一天可能一行代码也没写就这么度过了。 这个文章就当自己的学习记录吧，想到什么写什么，虽然有有道笔记，但是里面的记录的东西太乱了， 感觉就是个查问题的笔记库，有时间再整理下吧。。。 201702221.关于数据库的分库分表，主从技术落地。 201702231.以后面试要首先问涨薪体系！2.批处理数据的时候，要控制数据的数量，比如批量插入的时候，每">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://o8c5x5dg6.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170317152838.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172523808-1567363338.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172807745-742859090.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172901526-169091807.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172922917-1331181630.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172943917-133540408.png">
<meta property="og:updated_time" content="2019-04-04T08:22:38.969Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="技术储备-长期记录">
<meta name="twitter:description" content="最近几年总觉得脑子不够用，一会想学这个，一会想看哪个，一天可能一行代码也没写就这么度过了。 这个文章就当自己的学习记录吧，想到什么写什么，虽然有有道笔记，但是里面的记录的东西太乱了， 感觉就是个查问题的笔记库，有时间再整理下吧。。。 201702221.关于数据库的分库分表，主从技术落地。 201702231.以后面试要首先问涨薪体系！2.批处理数据的时候，要控制数据的数量，比如批量插入的时候，每">
<meta name="twitter:image" content="http://o8c5x5dg6.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170317152838.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ggj2010.github.io/2017/02/22/技术储备-长期记录/"/>





  <title> 技术储备-长期记录 | 高广金博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">高广金博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-webmagic">
          <a href="http://scedai.com/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            爬虫
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ggj2010.github.io/2017/02/22/技术储备-长期记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ggj2010">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ocg3iebmc.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160922230125.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高广金博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                技术储备-长期记录
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-22T12:41:14+08:00">
                2017-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javabase/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <pre><code>最近几年总觉得脑子不够用，一会想学这个，一会想看哪个，一天可能一行代码也没写就这么度过了。
这个文章就当自己的学习记录吧，想到什么写什么，虽然有有道笔记，但是里面的记录的东西太乱了，
感觉就是个查问题的笔记库，有时间再整理下吧。。。
</code></pre><h3 id="20170222"><a href="#20170222" class="headerlink" title="20170222"></a>20170222</h3><p>1.关于数据库的分库分表，主从技术落地。</p>
<h3 id="20170223"><a href="#20170223" class="headerlink" title="20170223"></a>20170223</h3><p>1.以后面试要首先问涨薪体系！<br>2.批处理数据的时候，要控制数据的数量，比如批量插入的时候，每次循环1000条插入一次，不要一次性插入N条，防止堆内存溢出。</p>
<h3 id="20170224"><a href="#20170224" class="headerlink" title="20170224"></a>20170224</h3><p>1.日志输出规范</p>
<h3 id="20170227"><a href="#20170227" class="headerlink" title="20170227"></a>20170227</h3><p>1.el字符串按照指定规则截取</p>
<pre><code>&lt;c:set value=&quot;${ fn:split(cate.services , &apos; &apos;) }&quot; var=&quot;service&quot; /&gt;
   &lt;c:forEach items=&quot;${service}&quot; var=&quot;s&quot;&gt;
      &lt;c:if test=&quot;${s==7}&quot;&gt;
         &lt;c:set var=&quot;freePost&quot; value=&quot;true&quot; /&gt;
    &lt;/c:if&gt;
 &lt;/c:forEach&gt;
</code></pre><p>2.mysql查询分页limit写法优化</p>
<pre><code>写法一：
 select * from tb_order  LIMIT 999999 ,10
写法二：
 select * from tb_order where id&gt;=(
 select id from tb_order LIMIT 999999,1) LIMIT 10
 mysql limit会扫描n行，如果这个n偏移量过大会导致性能下降，
 在id递增的情况下建议使用下面的写法
</code></pre><h3 id="20170228"><a href="#20170228" class="headerlink" title="20170228"></a>20170228</h3><p>1.防止xss需要对输入内容进行转译保存，页面显示是转译后的标签。</p>
<pre><code>StringEscapeUtils.escapeHtml4()
spring 可以这样写
@InitBinder
    protected void initBinder2(WebDataBinder binder) {
        // String类型转换，将所有传递进来的String进行HTML编码，防止XSS攻击
        binder.registerCustomEditor(String.class, new PropertyEditorSupport() {

            public String getAsText() {
                Object value = getValue();
                return value != null ? value.toString() : &quot;&quot;;
            }

            public void setAsText(String text) {
                setValue(text == null ? null : StringEscapeUtils.escapeHtml4(text.trim()));
            }
        });
    }
</code></pre><p>2.高并发下面redis的小问题</p>
<pre><code>redis因为是单线程的，如果在高并发的情况下 reidis服务器没有设置集群或者主从，连接数都是有限的，
在大量请求过来后，如果redis连接不够用会导致请求响应非常慢。我们可以在团购开始时间之前，将热数据
先从库同步到redis，同时定时也在项目里面缓存一份，拿数据的时候优先从本地缓存里面拿，定时再从redis
里面同步数据到本地缓存。
整个数据链路是  DB==&gt;REDIS==&gt;本地缓存
</code></pre><h3 id="20170301"><a href="#20170301" class="headerlink" title="20170301"></a>20170301</h3><p>1.tomcat的日志问题</p>
<pre><code>昨天线上突然挂机，想去看下tomcat挂机时候的日志，没想到catalina.log里面打了一堆乱七八糟的日志，
catalina.log会记录一些RunTimeException 和 System.out.println(） 和 e.printStackTrace()，为了防止
catalina.out日志过大，不要在代码里面这样输出内容。
</code></pre><h3 id="20170302"><a href="#20170302" class="headerlink" title="20170302"></a>20170302</h3><p>1.java垃圾回收知识点回顾</p>
<pre><code>java垃圾回收采用复制算法，将内存分为一块较大的eden空间和两块较小的survivor空间。每次都是使用eden和其中的一块survivor空间。
当回收时，将eden和survivor中还存活着的对象一次性的拷贝到另外一块survivor空间上，最后清理掉刚刚用掉的eden和survivor的空间
新生代=eden+surviror1+surviror2垃圾回收时候首先
先将eden+surviror1 移到surviror2  如果surviror2内存不够 就移到老年代  如果老年代还不够放，那就进行fulg
JVM的方法区，也被称为永久代。在这里都是放着一些被虚拟机加载的类信息，静态变量，常量等数据。这个区中的东西比老年代和新生代更不容易回收
当年轻代内存满时，会引发一次普通GC，该GC仅回收年轻代。需要强调的时，年轻代满是指Eden代满，Survivor满不会引发GC
当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代
当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载
q&amp;a surviror什么时候才会存放对象
 当eden第一次发生ygc的时候，会将eden区域的存活的对象拷贝到survivor from,survivor 放不下的会放到老年代
 当eden第二次ygc,会将eden区域的存活的对象和survivor from存活的对象拷贝到 survivor to,放不下的会放到老年代，然后清空survivor from
 这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。
 不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中
</code></pre><p>2.系统流量控制<br>     <a href="&#39;http://jinnianshilongnian.iteye.com/blog/2305117&#39;">参考博客</a></p>
<pre><code>分流：不需要我们控制，h5
降级：
    当业务系统挂了的时候，可以进行降级，降级方式有手动降级和自动降级
</code></pre><p>   <a href="&#39;http://iamzhongyong.iteye.com/blog/1897694?utm_source=tuicool&amp;utm_medium=referral&#39;">参考博客</a></p>
<pre><code>缓存：
    本地缓存==》redis缓存==》DB
限流：
    限流总并发/连接/请求数：Apache和tomcat做
    限流某个接口的总并发/请求数：apiAuthJAR可以做
    限流某个接口的时间窗请求数：apiAuthJAR可以做
    平滑限流某个接口的请求数：令牌桶算法可以应对突发请求 apiAuthJAR可以做

接入层：nginx限流
</code></pre><h3 id="20170306"><a href="#20170306" class="headerlink" title="20170306"></a>20170306</h3><ol>
<li><p>java 性能监控常用命令</p>
<ol>
<li>jstack 查看线程<br>   jstack pid  需要注意dump文件里面的 deadlock和blocked<br>   jstack pid &gt;a.txt<br>   grep -n -E10 ‘deadlock’ a.txt</li>
<li>jmap(查看内存)<br>  jmap -dump:format=b,file=/tmp/dump.dat 4813<br>  可以dump出java当前内存的情况，然后用工具MemoryAnalyzer或者HeapAnalyzer进行分析<br>  jmap -heap<br>  jmap -histo <pid>: 打印当前java堆中各个对象的数量、大小<br>  jmap -histo:live 20881 | grep QueryPartnerImpl</pid></li>
<li><p>jstat(性能分析)<br> jstat -gcutil 1756 1000<br> S0(from区)使用了41.74%；<br> S1(to区)使用了0；<br> E(Eden区)使用了54.35%；<br> O(Old，年老代)使用了62.41%；<br> P(Perment，永久代)使用了99.63%；<br> YGC(Young GC)了32次，<br> YGCT(Young GC Time)花销0.132秒；<br> FGC(Full GC)了1次，<br> FGCT(Full GC Time)花销0.102秒；<br> GCT(GC Time)总花销0.234秒。</p>
<p> jstat -gc 1688 3000<br>  S0C：年轻代中第一个survivor（幸存区）的容量 (字节)<br>  S1C：年轻代中第二个survivor（幸存区）的容量 (字节)<br>  S0U：年轻代中第一个survivor（幸存区）目前已使用空间 (字节)<br>  S1U：年轻代中第二个survivor（幸存区）目前已使用空间 (字节)<br>  EC：年轻代中Eden（伊甸园）的容量 (字节)<br>  EU：年轻代中Eden（伊甸园）目前已使用空间 (字节)<br>  OC：Old代的容量 (字节)<br>  OU：Old代目前已使用空间 (字节)<br>  PC：Perm(持久代)的容量 (字节)<br>  PU：Perm(持久代)目前已使用空间 (字节)<br>  MC: 元空间(Metaspace) Metaspace capacity (kB),一般是方法区，不在虚拟机中，而是使用本地内存，<br>  jdk8移除了PermGen，取而代之的是MetaSpace<br>  CCSC: Compressed class space capacity (kB).</p>
</li>
<li><p>查询最占用cpu的方法<br> ps -mp 28155 -o THREAD,tid,time<br> 查询出最耗时的tid 28159<br> 然后 jstack 28155 &gt; test.txt 将当期pid的栈信息打印到text.txt里面<br> 然后 grep <code>printf &quot;%x\n&quot; 28159</code> test -A 30</p>
</li>
</ol>
</li>
<li><p>jvm 性能优化</p>
<ol>
<li>堆和栈常用参数<pre><code>java堆：
-Xms2560m -Xmx2560m 限制java堆大小为 2560MB，且不可扩展，如果程序Headp
 java栈：
-Xss256k  设置java线程栈的大小，如果程序 StackOverflow就需要将xss设置大一点
 java年轻代：
 -XX:NewSize=1024m # 年轻代默认初始大小 jdk（1.3/1.4有用）
 -XX:MaxNewSize=1024m # 年轻代最大值 （1.3/1.4有用）
 以上两个等于-Xmn1024M（jdk1.4有用） 年轻代大小
java永久代
-XX:PermSize=384m # 永久代默认初始大小（方法区，类、接口、方法等）
-XX:MaxPermSize=512m # 永久代最大值
SurvivorRatio=8 则就是2：8 一个Survivor则为1/10 新生代=一个eden+两个survivor区
如果是SurvivorRatio=4 则就是2：4 一个Survivor则为1/6
-XX:SurvivorRatio=8  设置年轻中Eden区与Survivor区的大小比值
-XX:NewRatio=3  表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）
</code></pre></li>
<li><p>垃圾回收信息和内存溢出dump</p>
<pre><code>stop-the-world耗时过长可能是由于GC参数不合理或者代码实现不正确
使用-XX:+PrintFlagsFinal and -XX:+PrintFlagsInitial 可以打印jvm启动时候加载的配置项
gc时候打印详情
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationConcurrentTime
-XX:+PrintHeapAtGC -Xloggc:/data/applogs/heap_trace.txt
内存溢出dump
-XX:-HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/data/applogs/HeapDumpOnOutOfMemoryError
</code></pre></li>
<li><p>垃圾收集器</p>
<pre><code>使用 ParNew 收集器 （只有 Serial 和 ParNew 这两个年轻代收集器可以和老年代的 CMS 收集器一起使用，ParNew 是多线程的）
-XX:+UseParNewGC：设置并行收集器
使用 ParNew + CMS + Serial Old，Serial Old 会在 CMS 预留内存超过 CMSInitiatingOccupancyFraction 设置的比例时触发使用
-XX:+UseConcMarkSweepGC  设置并发收集器
 CMS 无法做彻底清除，需预留一部分空间供并发收集时程序使用，这个设置预留比例40%
-XX:CMSInitiatingOccupancyFraction=60
如果没有这个参数, 只有第一次会使用 CMSInitiatingPermOccupancyFraction=70 这个值，后面的情况会自动调整
-XX:+UseCMSInitiatingOccupancyOnly
设置永久代使用超过 70% 触发 CMS GC
-XX:CMSInitiatingPermOccupancyFraction=70
</code></pre></li>
<li><p>并发收集器设置</p>
<pre><code> 并行 GC 时进行内存回收的线程数
-XX:ParallelGCThreads=4

设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代
 对象每坚持一次 Minor GC 后年龄+1，当超过这个数值后进入老年代
 晋升年龄最大阈值，默认15。在新生代中对象存活次数(经过YGC的次数)后仍然存活，就会晋升到老年代。每经过一次YGC，年龄加1，
 当survivor区的对象年龄达到TenuringThreshold时，表示该对象是长存活对象，就会直接晋升到老年代。
-XX:MaxTenuringThreshold=9

# 为了减少 CMS 重新标记的暂停时间，开启并行remark
-XX:+CMSParallelRemarkEnabled

# 当使用 CMS 时希望又保留部分 System.gc() 的功能，只不过这种情况下触发的不是系统GC，而是 CMS GC
-XX:+ExplicitGCInvokesConcurrent

 # 早期版本也需要设置这个才会回收永久代
-XX:+CMSPermGenSweepingEnabled

 # 只有设置才会让永久代触发 CMS GC
-XX:+CMSClassUnloadingEnabled
</code></pre></li>
</ol>
</li>
<li><p>调优总结</p>
<pre><code>[参考文章](&quot;http://www.importnew.com/13954.html&quot;)
</code></pre><ol>
<li><p>年轻代大小选择</p>
<pre><code>响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制
吞吐量优先的应用：尽可能的设置大
</code></pre></li>
<li><p>年老代大小选择</p>
<pre><code>吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代
</code></pre></li>
</ol>
</li>
</ol>
<h3 id="20170308"><a href="#20170308" class="headerlink" title="20170308"></a>20170308</h3><ol>
<li><p>linux常用命令值删除多个进程</p>
<pre><code>grep -v 是用来排除某一行数据的
ps -ef|grep  &apos;java&apos; |grep -v grep|cut -c 9-15|xargs kill -9
</code></pre></li>
<li><p>elasticsearch 安装插件</p>
<pre><code>安装集群管理软件
elasticsearch/bin/plugin install mobz/elasticsearch-head
安装zk分词
git checkout tags/{version}
mvn package
copy and unzip target/releases/elasticsearch-analysis-ik-{version}.zip to your-es-root/plugins/ik
</code></pre><p>3.ela启动不能用root</p>
<pre><code>因为安全问题elasticsearch 不让用root用户直接运行，所以要创建新用户
userAdd ela
启动时候 切换到su ela用户
./elasticserach -d 需要修改配置文件的端口号和elasticserarch.sh里面启动的Xms和Xmx的堆大小
</code></pre></li>
<li>wc -l -n</li>
</ol>
<h3 id="20170309-redis回顾"><a href="#20170309-redis回顾" class="headerlink" title="20170309-redis回顾"></a>20170309-redis回顾</h3><pre><code>redis支持多种数据格式，还支持Geo坐标经纬度，HyperLogLog（基数统计）、Pub/Sub。
redis的key和string类型value限制均为512MB。
</code></pre><ol>
<li><p>redis两种持久化方式</p>
<p>一、Snapshot</p>
</li>
</ol>
<pre><code>以快照的形式保存某一时刻的数据在磁盘,
save &lt;seconds&gt; &lt;changes&gt;
#在bgsave遇到error的时候是否停止持久化，默认是yes代表是，no代表不是
stop-writes-on-bgsave-error yes
#是否压缩，默认是yes代表是，no代表不是，如果想节省CPU的话就设为no，但是rdb文件会比较大
rdbcompression yes
#持久化的文件名字，默认是dump.rdb
dbfilename dump.rdb
#文件存放目录默认是redis.conf所在的目录./
dir ./
save &lt;seconds&gt; &lt;changes&gt;：在X秒内如果key有至少X次改变就触发持久化，
例如save 900 1的话就是在900秒如果key有至少1次改变就触发持久化。
如果想关闭此功能的话，可以把全部save行都注释或删除或者使用save
</code></pre><p>   二、append-only file(aof)</p>
<pre><code>以追加的方式记录所有写操作的命令到磁盘文件里面，
#appendonly：是否启动aof，默认是no代表不启用，yes代表启用
appendonly no
#aof的文件名，默认是appendonly.aof
appendfilename &quot;appendonly.aof&quot;
#触发的间隔，默认是everysec代表每秒，另外还有always代表有改变都触发，性能最差但数据最安全，
#no代表让OS自己决定什么时候执行，性能最好但数据不安全
appendfsync everysec
dir ./

Redis会定期做aof重写，压缩aof文件日志大小
</code></pre><p>   三、Snapshot和AOF的对比</p>
<pre><code>snapshot 如果在保存前服务器down了，那么在上次snapshot之后修改的数据会丢失。
而AOF是记录所有的写操作，在数据完整性来说，AOF比snapshot要好
aof一般是比rdb文件较大，恢复时间较长，因为要重新执行所有的写操作
所以如果你可以容忍数据丢失的话，可以使用snapshot方式，
而且也是比AOF要节省资源，否则的话就使用AOF方式，
或者同时使用2种方式（重启的时候会优先使用AOF）。
</code></pre><ol>
<li><p>redis 关闭命令</p>
<pre><code> 以前都是kill 太暴力了
src/redis-cli -a gaoguangjin shutdown
</code></pre></li>
<li>redis 批量处理</li>
</ol>
<pre><code>如批量根据key查询结果或者批量插入 用pipeline管道操作。
</code></pre><ol>
<li>redis hgetAll 有性能问题，不能一次性存储大量数据。</li>
<li>redis pipeline原理</li>
</ol>
<pre><code>一开始觉得redis transation 与redis的pipeline类似，都是把所有命令打包后，再一起发给服务端，其实这种理解是错误的。
一般情况下redis是request-&gt;response request-&gt;response request-&gt;response 这种阻塞是请求流程，当如果有批量的操作的时候
这种请求模式会有性能瓶颈的。
pipeline模式不用等待请求结果，一直发送命令，最后一次性获取。
transtaion模式是一次性发，一次性取，保证操作一致性。
如果有非常多的命令，也并不是一次性全部发送完最好，毕竟服务器是需要维护一个队列存储结果的，
如果命令太多，最好是分批，redis对此的建议是一万个
</code></pre><ol>
<li>redis transtaion</li>
</ol>
<pre><code>redis的事物被提交，事物中的所有操作会顺序执行，且事物执行期间，其他client的操作会被阻塞，这样可以保证所有命令可以被执行
但redis的事物也是个伪事物，如果执行过程中某个命令有错误，只是不执行这个命令，其他命令还是会按顺序执行。
</code></pre><ol>
<li>HyperLogLog</li>
</ol>
<pre><code>Redis 的基数统计，这个结构可以非常省内存的去统计各种计数，
比如注册 IP 数、每日访问 IP 数、页面实时UV）、在线用户数等。但是它也有局限性，
就是只能统计数量，而没办法去知道具体的内容是什么。
当然用集合也可以解决这个问题。但是一个大型的网站，每天 IP 比如有 100 万，粗算一个 IP 消耗 15 字节，
那么 100 万个 IP 就是 15M。而 HyperLogLog 在 Redis 中每个键占用的内容都是 12K，
理论存储近似接近 2^64 个值，不管存储的内容是什么，它一个基于基数估算的算法，只能比较准确的估算出基数，
可以使用少量固定的内存去存储并识别集合中的唯一元素。而且这个估算的基数并不一定准确，
是一个带有 0.81% 标准错误的近似值。
这个数据结构的命令有三个：PFADD、PFCOUNT、PFMERGE

PFADD RDBMS &quot;MySQL&quot; &quot;MSSQL&quot; &quot;PostgreSQL&quot; 存放3个数据
PFADD nosql &quot;Redis&quot; &quot;MongoDB&quot; &quot;Memcached&quot; 存放3个数据
PFCOUNT nosql   统计值为3
PFMERGE  databases RDBMS nosql 可以将两个集合数据合并
</code></pre><ol>
<li>使用scan代替keys</li>
</ol>
<pre><code>当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时，
它们可能会阻塞服务器达数秒之久。
假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来，
用keys会导致线程阻塞一段时间
可以使用 scan 0 match key* count 1
</code></pre><p>  9.redis如何实现延时队列</p>
<pre><code>使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。
</code></pre><h3 id="20170310"><a href="#20170310" class="headerlink" title="20170310"></a>20170310</h3><ol>
<li><p>nginx安装ssl模块</p>
<pre><code>nginx -V 可以查看原来编译时都带了哪些参数
原来的参数：
--prefix=/app/nginx
添加的参数:
--with-http_stub_status_module --with-http_ssl_module --with-http_realip_module
步骤如下：
1. 使用参数重新配置:
./configure --prefix=/app/nginx -user=nobody -group=nobody --with-http_stub_status_module \
--with-http_ssl_module --with-http_realip_module \
--add-module=../nginx_upstream_hash-0.3.1/ \
--add-module=../gnosek-nginx-upstream-fair-2131c73/
2. 编译:
make
#不要make install，否则就是覆盖安装
3. 替换nginx二进制文件:./objs/是新编译后文件的目录
cp /app/nginx/sbin/nginx /app/nginx/sbin/nginx.bak
cp ./objs/nginx /app/nginx/sbin/
</code></pre><ol>
<li><p>nginx开启websocket与https</p>
<p>#websocket<br>proxy_http_version 1.1;<br>proxy_set_header Upgrade $http_upgrade;<br>proxy_set_header Connection “Upgrade”;<br>#https<br>listen 443 ssl ;<br>#注意证书目录<br>ssl_certificate   cert/214040861080304.pem;<br>ssl_certificate_key  cert/214040861080304.key;<br>ssl_session_timeout 5m;<br>ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;<br>ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>ssl_prefer_server_ciphers on;</p>
</li>
</ol>
</li>
</ol>
<h3 id="20170313"><a href="#20170313" class="headerlink" title="20170313"></a>20170313</h3><ol>
<li><p>instanceof 与 isinstanceof()</p>
<pre><code>instanceof 是一个操作符（类似new， ==等)
 if (ins instanceof String) {
      //logic
  }
isInstance是Class类的一个方法:
if (String.class.isInstance(ins)){
}
</code></pre></li>
</ol>
<h3 id="20170314-浅拷贝和深拷贝"><a href="#20170314-浅拷贝和深拷贝" class="headerlink" title="20170314-浅拷贝和深拷贝"></a>20170314-浅拷贝和深拷贝</h3><pre><code>浅拷贝是指拷贝对象时仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。
深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。
举例来说更加清楚：
对象A1中包含对B1的引用，B1中包含对C1的引用。
浅拷贝A1得到A2，A2 中依然包含对B1的引用，B1中依然包含对C1的引用。
深拷贝则是对浅拷贝的递归，深拷贝A1得到A2，A2中包含对B2（B1的copy）的引用，B2 中包含对C2（C1的copy）的引用。

所谓浅复制：则是只复制对象的引用，两个引用仍然指向同一个对象，在内存中占用同一块内存。
被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。
换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。
深复制：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。
那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。
换言之，深复制把要复制的对象所引用的对象都复制了一遍。

java中如果要实现深拷贝，必须要重写clone()方法来拷贝对象里面的应用类型变量
</code></pre><h3 id="20170317-java-spi机制"><a href="#20170317-java-spi机制" class="headerlink" title="20170317-java spi机制"></a>20170317-java spi机制</h3><pre><code>SPI为某个接口寻找服务实现的机制,例如日志模块的方案，xml解析模块、jdbc模块。
当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。
该文件里就是实现该服务接口的具体实现类。
而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。
基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。jdk提供服务实现查找的一个工具类：java.util.ServiceLoader
在项目class目录下面 META-INF/services/ 会有待实现的接口，文件名称就是接口名称例如：java.sql.Driver
文件里面存放的内容就是接口的实现类名称。
ServiceLoader.load(XX.class) 就可以得到该类的实现类了
</code></pre><p> <img src="http://o8c5x5dg6.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170317152838.png" alt="截图" title="截图"></p>
<h3 id="20170323"><a href="#20170323" class="headerlink" title="20170323"></a>20170323</h3><ol>
<li><p>苹果javaPan推送时候报错：Received fatal alert: certificate_revoked</p>
<pre><code>证书过期了，没有及时更新接收推送的设备的客户端的证书和token
</code></pre></li>
</ol>
<h3 id="20170327"><a href="#20170327" class="headerlink" title="20170327"></a>20170327</h3><ol>
<li><p>java日志框架兼容</p>
<pre><code>commons-logging和slf4j 都是定义日志框架的接口
log4j和logback 都是实现上面接口的类
java-util-logging：俗称jul
commons-logging:简称 jcl
**-over-slf4j都是为了适配用的，比如log4j-over-slf4j是将原来log4j打印的转换成logback打印
使用以下架包可以兼容使用logback时候的各种冲突
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre></li>
</ol>
<h3 id="20170330"><a href="#20170330" class="headerlink" title="20170330"></a>20170330</h3><ol>
<li><p>代码性能监控类StopWatch</p>
<pre><code>spring提供的StopWatch可以很容易实现对多个方法调用时间的监控，比较简单明了。当然如果代码里面有多线程代码肯定是不适用的。
</code></pre></li>
</ol>
<h3 id="20170412"><a href="#20170412" class="headerlink" title="20170412"></a>20170412</h3><ol>
<li><p>集合类初始容量和负载因子设置</p>
<pre><code>容器类：初始长度/扩容倍数 默认的。如果设置不到导致频繁的resize扩容
- ArrayList：10/1.5 没有扩容因子
- ArrayDeque：8/2
- BitSet：64/2
- HashMap：16/2 扩容因子0.75
- HashSet/TreeSet：同HashMap(基于HashMap实现，value为空Object) 扩容因子0.75
- Hashtable：11/2 扩容因子0.75
- WeakHashMap：同HashMap 扩容因子0.75
- PriorityQueue：11/Double size if small; else grow by 50%
- StringBuilder：16/按需
</code></pre><h3 id="20170418"><a href="#20170418" class="headerlink" title="20170418"></a>20170418</h3></li>
<li><p>ThreadLocal内存溢出</p>
<pre><code>使用ThreadLocal的时候 记得手动调用remove方法
</code></pre></li>
</ol>
<h3 id="20170425"><a href="#20170425" class="headerlink" title="20170425"></a>20170425</h3><ol>
<li>关于代码解耦</li>
</ol>
<pre><code>1、可以使用spring的事件驱动模型，订阅者和消费者。
ApplicationContextAware是用来实现发布消息的，ApplicationListener是用来订阅消息的
2、使用google的eventbus 轻量级别的代码层次解耦。
</code></pre><h3 id="20170510-hs-err-pid-log"><a href="#20170510-hs-err-pid-log" class="headerlink" title="20170510-hs_err_pid.log"></a>20170510-hs_err_pid.log</h3><ol>
<li><p>JVM致命错误日志（hs_err_pid.log）解读</p>
<pre><code>一般错误原因在第一行就可以看到
# There is insufficient memory for the Java Runtime Environment to continue.
# Native memory allocation (mmap) failed to map 6987776 bytes for committing reserved memory.
# Possible reasons:
#   The system is out of physical RAM or swap space
#   In 32 bit mode, the process size limit was hit
# Possible solutions:
#   Reduce memory load on the system
#   Increase physical memory or swap space
#   Check if swap backing store is full
#   Use 64 bit Java on a 64 bit OS
#   Decrease Java heap size (-Xmx/-Xms)
#   Decrease number of Java threads
#   Decrease Java thread stack sizes (-Xss)
#   Set larger code cache with -XX:ReservedCodeCacheSize=
# This output file may be truncated or incomplete.
#
#  Out of Memory Error (os_linux.cpp:2627), pid=15974, tid=139667856946944
</code></pre></li>
</ol>
<h3 id="20170512-高可用消息推送平台"><a href="#20170512-高可用消息推送平台" class="headerlink" title="20170512-高可用消息推送平台"></a>20170512-高可用消息推送平台</h3><p>1.公司现有的推送系统和<a href="http://www.infoq.com/cn/articles/HA-mobile-message-push-platform#anch147737" target="_blank" rel="external">参考文章</a></p>
<h3 id="20170605-mybatis动态参数"><a href="#20170605-mybatis动态参数" class="headerlink" title="20170605-mybatis动态参数"></a>20170605-mybatis动态参数</h3><p>1.对于日期类型判断只能判断是否为空，不能这样判断 <if test="createTime != null and createTime !='' "></if></p>
<pre><code>&lt;if test=&quot;createTime != null&quot;&gt;
  date(create_time) = date(#{createTime,jdbcType=TIMESTAMP})
&lt;/if&gt;
如果类型为Integer类型，就去掉 ！= ”的判断，只判断!=null即可。
如果是字符串类型比较
&lt;if test=&quot; name==&apos;你好&apos; &quot;&gt;
&lt;if&gt;
这样会有问题，换成
&lt;if test=&apos; name==&quot;你好&quot; &apos;&gt;
&lt;if&gt;
</code></pre><p>2.mybatis特殊字符处理<br>    &lt;![CDATA[ ]]&gt;<br>3.mybatis 批量插入和插入后获取主键的id值</p>
<pre><code>useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;
&lt;insert id=&quot;saveBatchArticle&quot; parameterType=&quot;java.util.List&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
   insert into tb_article (custom_id,
    media_name,title, custom_name,
    custom_price,  verify_url,
   status, flag, create_date,
   verify_date)
   &lt;foreach collection=&quot;list&quot; item=&quot;article&quot; separator=&quot; union all &quot;&gt;
     select
     #{article.customId},#{article.mediaName},#{article.title},#{article.customName},
     #{article.customPrice},#{article.verifyUrl},#{article.status},#{article.flag},
     #{article.createDate},#{article.verifyDate} from dual
   &lt;/foreach&gt;
 &lt;/insert&gt;
</code></pre><p>4.mybatis in（1,2）条件特殊处理</p>
<pre><code>&lt;select id=&quot;findByIdsMap&quot; resultMap=&quot;BaseResultMap&quot;&gt;
 Select
 &lt;include refid=&quot;Base_Column_List&quot; /&gt;
 from jria where ID in
 &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
  #{item}
 &lt;/foreach&gt;
&lt;/select&gt;
</code></pre><h3 id="20170614-表添加索引"><a href="#20170614-表添加索引" class="headerlink" title="20170614-表添加索引"></a>20170614-表添加索引</h3><p>1.好久没有写sql,提个数据库修改单还得按照dba的要求来。</p>
<pre><code>添加索引有以下两种方式
ALTER TABLE API_USERTOKEN add index idx_API_USERTOKEN_TOKEN (TOKEN);
create index  IDX_API_USERTOKEN_TOKEN on API_USERTOKEN(TOKEN);
</code></pre><p>2.删除指定日期数据</p>
<pre><code>delete from MQTT_PUSH_INFO where create_time&lt;(select DATE_FORMAT(date_add(now(), interval -3 MONTH),&apos;%Y-%m-%d 00:00:00&apos;))
</code></pre><p>3.删除大量数据,truncate不记录日志速度快</p>
<pre><code>truncate table MB_LOG_WAP_VISIT;
</code></pre><h3 id="20170615-equal和hashcode"><a href="#20170615-equal和hashcode" class="headerlink" title="20170615-equal和hashcode"></a>20170615-equal和hashcode</h3><pre><code>如果两个对象equal相等则hashCode一定相等，因为对象的equal比较的是引用地址，
而object的hashcode是native方法返回的也是object的引用地址
String类型重写了native的hashCode方法，只要长度一致，hashCode都是一样的。
如果判断两个对象是否相等最好重写equal和hashCode方法，例如set和map里面的key值
</code></pre><h3 id="20170615-replace空指针"><a href="#20170615-replace空指针" class="headerlink" title="20170615-replace空指针"></a>20170615-replace空指针</h3><pre><code>如果有多个replace例如
&quot;test&quot;.replace(&quot;param1&quot;,params.getParam1()).replace(&quot;param2&quot;,params.getParam2()).
       replace(&quot;param3&quot;,params.getParam3()).replace(&quot;param4&quot;,params.getParam4()).
       replace(&quot;param5&quot;,params.getParam5())
 params.getParam1()..params.getParam5()的值不可以为null
</code></pre><h3 id="20170619-为什么HashMap里面的数组size必须是2的次幂？"><a href="#20170619-为什么HashMap里面的数组size必须是2的次幂？" class="headerlink" title="20170619-为什么HashMap里面的数组size必须是2的次幂？"></a>20170619-为什么HashMap里面的数组size必须是2的次幂？</h3><pre><code>//http://nanguocoffee.iteye.com/blog/907824
//hashMap里面有这段源码，将number改成2的次幂
 private static int roundUpToPowerOf2(int number) {
      // assert number &gt;= 0 : &quot;number must be non-negative&quot;;
      return number &gt;= MAXIMUM_CAPACITY
              ? MAXIMUM_CAPACITY
              : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;
  }
    //然后将number-1 得到2进制1的个数越多，hash分布的就越均匀
    static int indexFor(int h, int length) {
         // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;
         return h &amp; (length-1);
     }
 //最终都是为了让hash分布的更加均匀点
</code></pre><h3 id="20170620-http协议复习"><a href="#20170620-http协议复习" class="headerlink" title="20170620-http协议复习"></a>20170620-http协议复习</h3><h3 id="20170621-深入java虚拟机复习"><a href="#20170621-深入java虚拟机复习" class="headerlink" title="20170621-深入java虚拟机复习"></a>20170621-深入java虚拟机复习</h3><h4 id="java虚拟机运行时数据区域"><a href="#java虚拟机运行时数据区域" class="headerlink" title="java虚拟机运行时数据区域"></a>java虚拟机运行时数据区域</h4><pre><code>1、程序计数器：
    【1】作用可以定义成查看当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计时器的值来选取下一条需要执行的字节码指令。例如分支，循环异常。线程恢复等功能，
    【2】因为多线程是通过线程轮流切换来实现的。在任何一个指定的时刻，一个处理器指挥处理一条线程中的指令，所以每个线程都需要一个独立的程序计数器，是 线程私有
    【3】如果线程执行的是ntive方法 则计数器为空。此区域是唯一一个在虚拟机规范中没有任何OutMeoryError

2、java虚拟机栈(Xss) stack
   【1】线程私有，描述的是Java方法的内存模型。每个方法被执行都会创建一个栈帧用来存放局部变量表，操作栈、动态链接等。
   【2】局部变量表存放了各种基本数据类型 boolean byte char short int float long double 、对象的引用 reference类型（可能是对象起始地址的引用指针）
   【3】64位的长度long和double的数据会占用两个局部变量空间（Sloat）【会导致线程安全问题】，其余的都只占用一个。
   【4】局部变量表所需要的内存空间都是在编译器完成分配的，在方法运行期间不会改变局部变量表的大小。全局变量是在堆里面，
   【5】 线程请求栈深度大于虚拟机允许的深度会抛出StackOverFlowError。如果虚拟机可以动态扩展，当扩展无法申请到足够的内存会抛出OutOfMemoryError异常

3、本地方法栈
  【1】 与虚拟机栈发挥作用相似，区别在于本地方法栈执行的是虚拟机使用到的Native方法。而虚拟机栈使用的是java方法服务 。
  【2】 线程请求栈深度大于虚拟机允许的深度会抛出StackOverFlowError。如果虚拟机可以动态扩展，当扩展无法申请到足够的内存会抛出OutOfMemoryError异常


4、java堆（-Xmx  和-Xms）heap
 【1】Java Heap 是java虚拟机中管理内存最大的一块，所有线程共享的一块内存区域。虚拟机启动时候创建，目的就是存放对象实例，几乎所有对象都在这里分配内存。
 【2】Java 虚拟机规范中描述：所有的对象实例以及数组都要在堆上面分配内存。
 【3】Java 堆是垃圾收集器管理的主要区域。java堆可分为：新生代和老年代。  再细致点有Eden空间、From Survivor 空间、To Survivor空间,
 【4】Java 堆处于物理上不连续的内存空间中。可以通过设定 -Xmx 和 -Xms设定jvm内存大小


5、方法区
 【1】、多个线程共享内存区域，用于存储已被虚拟机加载的类信息、静态变量，及时编译器后的代码。
 【2】、垃圾收集行为在这个区域是比较少出现的

6、运行时常量池(-XX:PermSize -XX:MaxPremSize)
 【1】、是方法区的一个部分，.class文件中除了有类的版本、字段、方法、接口等信息外，
 还有常量池用于存放编译期生成的各种字面量的符号引用，这部分内容将在类加载后存放到方法区的运行时常量池，可以在运行期间将常量放入池中。

7、本机内存（-XX:MaxDirectMemorySize指定。）如果不指定那就是默认和java堆的最大值一样（-Mmx）
java.lang.OutOfMemoryError
</code></pre><h4 id="java垃圾回收知识点"><a href="#java垃圾回收知识点" class="headerlink" title="java垃圾回收知识点"></a>java垃圾回收知识点</h4><ul>
<li><p>垃圾回收判断</p>
<pre><code>判断对象已死根据引用计数算法是不行的，因为如果两个对象相互引用那么他们的计数就不可能为0，
根据可达性分析算法，如果一个对象无法到达其GC ROOTs时候，则可以判断这个对象为可回收对象，
可作为GC ROOTS的对象有 方法区中静态属性引用的对象和常量引用的对象，还有虚拟机栈中引用的对象和本地方法栈引用的对象
一个对象的死亡会经历两次标记，如果对象在进行可达性分析后没有与GC ROOTS相连接的引用链，会进行第一次标记和进行
一次刷选， 刷选的条件就是此对象是否有必要执行finalize()方法，当对象没有重写finalize()或者finalize（）方法已经被
执行过了，这就没必要执行刷选了。如果对象在finalize（）方法里面重写与引用链上的对象关联，就不会被回收。
如果对象没有必要执行finalize（）则这些对象会放到F-quenen队列中，由虚拟机去触发执行 然后进行第二次标记
</code></pre></li>
<li><p>垃圾收集算法</p>
<pre><code>标记-清除算法：标率低，会有不连续的内存碎片
复制算法：将内存分成一半，代价就是内存缩下一半了，如果对象存活率较高就需要进行过多的复制操作
标记-整理算法： 和标记清除算法类似
分代收集算法：新生代使用复制算法，老年代因为对象存活高使用标记-清理或者标记-整理算法
</code></pre></li>
<li><p>垃圾收集器</p>
<pre><code>新生代：
    Serial收集器：单线程的
    ParNew收集器：多线程的
    CMS收集器：并发收集、低停顿 一般互联网网站使用多，重视服务响应速度，
    收集的时候是一种以最短回收停顿时间为目标的收集器，是基于“标记-清除”算法实现的
    G1收集器：
</code></pre></li>
</ul>
<h4 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h4><ul>
<li><p>类的生命周期</p>
<pre><code>加载-》【验证-&gt;准备-&gt;解析】（可以合并为连接）-》初始化=》使用=》卸载
</code></pre></li>
<li><p>类必须要进行初始化</p>
<pre><code>1、遇到new，getstatic等字节码指令。生成这些字节码的java 场景有new关键字，设置一个类的静态子段。
2、利用reflect方法对类进行反射调用。
3、当初始化一个类，如果父类没初始化，首先初始化父类
4、虚拟机启动时候，需要指定一个要执行的类，也就是main方法。
</code></pre></li>
<li><p>加载</p>
<pre><code>1、通过类名去获取定义此类的二进制字节流。
2、将这个字节流所代表的静态存储结构转换成运行时方法区的数据结构。
3、在java堆中生成代表这个类的对象，作为方法区这些参数访问的入口。
</code></pre></li>
<li><p>验证</p>
<pre><code>1、文件格式验证，是否以魔数开头，主版本是否在当前虚拟机处理范围内。
2、元数据验证
3、字节码验证
4、符号引用验证
</code></pre></li>
<li><p>准备</p>
<pre><code>为类变量分配内存，并设置类变量初始值。（static修饰的变量）例如给int赋值0
</code></pre></li>
<li><p>解析</p>
<pre><code>类和接口的解析、字段解析、类方法解析、接口方法解析
</code></pre></li>
<li><p>初始化</p>
<pre><code>调用static{}方法，如果有父类的话会先调用父类的static方法
</code></pre></li>
<li><p>类的加载器</p>
<pre><code>双亲委派模型：是为了安全考虑而设计的
某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，
如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。
加载器有 启动类加载器（bootstarp classLoader）==&gt;
扩展类加载器（Extension ClassLoader）==&gt;应用程序加载器（Application ClassLoader）==&gt;自定义类加载器

启动（Bootstrap）类加载器：是用本地代码实现的类装入器，它负责将 &lt;Java_Runtime_Home&gt;/lib下面的类库加载到内存中（比如rt.jar）。
由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。

标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。
它负责将&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。

系统（System）类加载器：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。
它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。
</code></pre></li>
</ul>
<h4 id="早期编译器优化"><a href="#早期编译器优化" class="headerlink" title="早期编译器优化"></a>早期编译器优化</h4><ul>
<li><p>泛型与类型擦除</p>
<pre><code>泛型的代码通过反编译后查看编译后的字节码，所有的类型都变成了原生类型，并且在相应的地方进行强制转换
</code></pre></li>
<li><p>自动装箱、拆箱与遍历循环</p>
<pre><code>遍历循环会变成迭代器实现方式
int方法会自动装箱变成integer
</code></pre><h4 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h4><pre><code>java多线程会出现线程安全的问题，而可见性是由java的内存模型决定的，因为每个线程都有一个私有的本地内存，
同时也会导致共享变量竞争的问题。
java线程-&gt;工作内存-》（save和load操作）-》主内存
java线程-&gt;工作内存-》（save和load操作）-》主内存
java线程-&gt;工作内存-》（save和load操作）-》主内存
java线程-&gt;工作内存-》（save和load操作）-》主内存

java内存操作指令：
lock/unlock/read/write 主内存
load/user/assign/store 工作内存
read and load 从主存赋值变量到工作内存
user and assign 执行代码和改变共享变量（可能出现多次）
store and write  写到工作内存，同时拷贝到主内存
</code></pre><h4 id="并发编程三个概念"><a href="#并发编程三个概念" class="headerlink" title="并发编程三个概念"></a>并发编程三个概念</h4><p>   原子性：一个操作要么全部执行，并且执行过程中不被打断，要么不执行。synchronized和java.util.concurrent包中的锁都能够保证操作的原子性<br>   synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性<br>   可见性：多个线程对变量操作之后，别的线程可以立即感知到。</p>
<pre><code>volatile,synchronized和Lock也能够保证可见性
</code></pre><p>   有序性：在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br>   防止指令重排序,它只会对不存在数据依赖性的指令进行重排序，编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的<br>   两个操作的执行顺序，synchronized和Lock来保证有序性，volatile禁止重排序<br>   volatile关键字通过提供“内存屏障”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，<br>   会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
</li>
</ul>
<h4 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h4><h4 id="happens-before原则（先行发生原则"><a href="#happens-before原则（先行发生原则" class="headerlink" title="happens-before原则（先行发生原则)"></a>happens-before原则（先行发生原则)</h4><pre><code>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
</code></pre><h3 id="20170622-transient关键字"><a href="#20170622-transient关键字" class="headerlink" title="20170622-transient关键字"></a>20170622-transient关键字</h3><pre><code>transient 修饰的变量都不参与序列化，当反序列化的时候所有transient 修饰的成员变量字段值都是null
</code></pre><h3 id="20170622-数据库复习"><a href="#20170622-数据库复习" class="headerlink" title="20170622-数据库复习"></a>20170622-数据库复习</h3><h4 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h4><pre><code>数据库事务的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，
这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。
读未提交（会出现脏读、重复读、幻读）、读已提交（会出现重复读、幻读）、重复读（会出现幻读）、序列化
读未提交场景：A、B同时开启事物，A修改数据但没提交，B这时候读取到A修改的数据继续后面的操作，
但是如果A事物回滚了，就会导致B读取到的脏数据
读已提交：可以解决脏读的情况，但是会有重复读的情况
大多数数据库的默认级别就是Read committed。
重复读：A、B同时开启事物，A将某表字段值从1000修改成500 ，但是还没提交事物，B这时候读取到是1000，这时候
A再提交事物，B再重新读取该字段，发现值变成了500，这就会导致重复读的情况了。这是MySQL的默认事务隔离级别。
如果将事物级别设置成重复读，在同一个事务内的查询都是事务开始时刻一致的，也就是无论查询多少次值都是一样的，
也就可以解决重复读的情况

幻读情况：虽然数据库事物级别设置成重复读，但是如果会出现幻读的情况 比如A事物执行select * from table,返回了
5条数据，这时候另外一个操作往这个表里面添加一条数据，再次执行select * from table,发现返回了6条数据，这就是
幻读的情况！
</code></pre><h4 id="死锁情况"><a href="#死锁情况" class="headerlink" title="死锁情况"></a>死锁情况</h4><pre><code>不同表相同记录行锁冲突
相同表相同记录行
不同索引锁冲突
比如 update table where id&gt;1 和 update table where id=2  会导致死锁
</code></pre><h4 id="spring事物传播特性"><a href="#spring事物传播特性" class="headerlink" title="spring事物传播特性"></a>spring事物传播特性</h4><pre><code>PROPAGATION_REQUIRED ：用的最多的，如果当前方法没有事物那就先建立一个事物，如果有，那就加入到这个事物。
PROPAGATION_SUPPORTS ：支持当前事务，如果当前没有事务，就以非事务方式执行。
PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。
PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。
PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作
</code></pre><h3 id="20170622-动态代理"><a href="#20170622-动态代理" class="headerlink" title="20170622-动态代理"></a>20170622-动态代理</h3><pre><code>底层原理：
都是在代理类目录生成一个**$**.class带有$的代理编译后的类，调用的时候就是调用这个代理类
spring aop使用的有jdk和cglib，jdk创建代理对象的时间比cglib短，但是代理方法的执行时间比cglib慢
如果spring里面用到的对象单例模式的比较多，就建议使用cglib模式，虽然启动时间会长点，但是提高程序效率
dubbo里面使用较多的就是avassist代理，因为有时候不需要代理整个类，只用代理某个方法
</code></pre><h4 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h4><pre><code>针对接口进行代理的，不可以对普通类进行代理
核心代码：
InterfaceInvocationHandler implements InvocationHandler{
public Object invoke(Object object, Method method, Object[] objects){}
}
Interface jdkProxy = (Interface) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),
new Class[] { Interface.class }, new InterfaceInvocationHandler(interfaceImp))
</code></pre><h4 id="cglib"><a href="#cglib" class="headerlink" title="cglib"></a>cglib</h4><pre><code>针对类进行代理的，比较自由
核心代码：
Enhancer enhancer = new Enhancer();
enhancer.setCallback(new CglibInterceptor(delegate));
enhancer.setInterfaces(new Class[] { CountService.class });
CountService cglibProxy = (CountService) enhancer.create();
class CglibInterceptor implements MethodInterceptor {
public Object intercept(Object object, Method method,
        Object[] objects,MethodProxy methodProxy) throws Throwable {
}
</code></pre><h4 id="JAVAASSIST字节码"><a href="#JAVAASSIST字节码" class="headerlink" title="JAVAASSIST字节码"></a>JAVAASSIST字节码</h4><pre><code>只需用字符串拼接出Java源码，便可生成相应字节码
</code></pre><h3 id="20170703-for-each原理和java迭代注意"><a href="#20170703-for-each原理和java迭代注意" class="headerlink" title="20170703-for each原理和java迭代注意"></a>20170703-for each原理和java迭代注意</h3><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>For-each语法内部，对collection是用nested iteratoration来实现的，对数组是用下标遍历来实现。
</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><pre><code>对于集合尽量不要用for each 因为本质都是转换成iterator
LinkedHashMap 不要在迭代器iterator里面使用get方法，因为get()方法会修改LinkedHashMap中的链表结构，
以便将最近访问的元素放置到链表的末尾
在集合内部维护一个字段modCount用于记录集合被修改的次数，每当集合内部结构发生变化(add,remove，set)时，modCount+1。
List在迭代器内部也维护一个字段expectedModCount，同样记录当前集合修改的次数，初始化为集合的modCount值。
当我们在调用Iterator进行遍历操作时，如果有其他线程修改list会出现modCount!=expectedModCount的情况，
就会报并发修改异常java.util.ConcurrentModificationException。
</code></pre><h4 id="for-each对象"><a href="#for-each对象" class="headerlink" title="for each对象"></a>for each对象</h4><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(1);
for (Integer i : list) {
    System.out.println(&quot;&quot; + i);
}
通过编译后的字节码，虚拟机将以上代码转换成了迭代器
INVOKEINTERFACE java/util/List.iterator ()Ljava/util/Iterator;
FRAME APPEND [java/util/List java/util/Iterator]
INVOKEINTERFACE java/util/Iterator.hasNext ()Z
INVOKEINTERFACE java/util/Iterator.next ()Ljava/lang/Object;
</code></pre><h3 id="20170704-linux线程gc查询"><a href="#20170704-linux线程gc查询" class="headerlink" title="20170704-linux线程gc查询"></a>20170704-linux线程gc查询</h3><pre><code>jstat -gc pid 250 4 //每隔250ms 打印四次Java垃圾回收详情
jstat -gc pid 250 //每隔250ms 打印Java垃圾回收详情
S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC     CCSU      YGC     YGCT    FGC    FGCT     GCT
6080.0 6080.0  0.0   3014.3 48640.0  22188.1   121148.0   62950.3   62720.0 61800.1 7936.0 7742.1    277    1.328   6      0.784    2.111
6080.0 6080.0  0.0   3014.3 48640.0  22190.5   121148.0   62950.3   62720.0 61800.1 7936.0 7742.1    277    1.328   6      0.784    2.111
S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）
EC、EU：Eden区容量和使用量
OC、OU：年老代容量和使用量
PC、PU：永久代容量和使用量
YGC、YGT：年轻代GC次数和GC耗时
FGC、FGCT：Full GC次数和Full GC耗时
GCT：GC总耗时
</code></pre><h3 id="20170705-java对象的强、软、弱、虚引用"><a href="#20170705-java对象的强、软、弱、虚引用" class="headerlink" title="20170705-java对象的强、软、弱、虚引用"></a>20170705-java对象的强、软、弱、虚引用</h3><pre><code>强引用：垃圾回收期不会主动去回收，哪怕Java虚拟机报OutOfMemoryError
软引用：当Java堆内存不够的时候，才会进行回收
弱引用：比软引用更容易被回收，当垃圾回收期线程执行的时候，不管当前堆内存是否够，都会回收
不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
</code></pre><h4 id="ThreadLocal原理与内存泄露"><a href="#ThreadLocal原理与内存泄露" class="headerlink" title="ThreadLocal原理与内存泄露"></a>ThreadLocal原理与内存泄露</h4><pre><code>    ThreadLocal为每一个线程创建的单独变量副本，底层是有ThreadLocal.ThreadLocalMap去维护的，每一个
线程都有一个独立的ThreadLocalMap，ThreadLocal实例就是map对应的key。
例如set的时候，首先获取当前线程的ThreadLocalMap 然后再放值。
    ThreadLocalMap的key是弱引用，当我们吧threadLocal置为null时候，thread会被gc,
  但是value缺不会被回收，因为还有value还有强引用，只有当当前thread结束后，value
  才会被回收。比如我们使用线程池的时候，Thread是不会被回收的，所以就会发生内存泄露的。
  最好的方法就是手动调用remove();
</code></pre><h3 id="20170706-设计模式回顾"><a href="#20170706-设计模式回顾" class="headerlink" title="20170706-设计模式回顾"></a>20170706-设计模式回顾</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><pre><code>懒汉、饿汉、doublecheck、匿名类
</code></pre><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><pre><code>简单工厂：例如获取jdbc的方式
工厂方法模式：父类定义抽象接口，子类负责生成具体的对象，将类的实例化操作延迟到子类。
抽象工厂模式：抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。
它针对的是有多个产品的等级结构。而工厂方法模式针对的是一个产品的等级结构。
在只有一个产品族的情况下，抽象工厂模式实际上退化到工厂方法模式
</code></pre><h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><pre><code>例如 io流 new FileInputStream（new File()）
</code></pre><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><pre><code>例如jdk的动态代理
</code></pre><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><pre><code>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化
</code></pre><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><pre><code>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换
</code></pre><h4 id="迭代模式"><a href="#迭代模式" class="headerlink" title="迭代模式"></a>迭代模式</h4><pre><code>list迭代器
</code></pre><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><pre><code>spring 里面用到了ApplicationEvent 和ApplicationListener，
applicationContext.publishEvent（Event）;
观察者订阅，订阅者发生变动时候通知所有观察者。
</code></pre><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><pre><code>当第三方定义好了接口AInterface，但是并没有给具体的实现，我们就可以定义一个适配类Adapter，
适配器类也实现了AInterface的所有方法。
AInterfaceImp extends Adapter implement AInterface{
     method (){
     super.method();
     }
}
</code></pre><h3 id="20170707-通过Java字节码去看原理"><a href="#20170707-通过Java字节码去看原理" class="headerlink" title="20170707-通过Java字节码去看原理"></a>20170707-通过Java字节码去看原理</h3><pre><code>idea 可以安装ASM ByteCode 插件直接查看编译后的字节码
将一个局部变量加载到操纵栈的指令包括：iload、iload_、lload…
将一个数值从操作数栈存储到局部变量表的指令包括：istore、istore_、lstore…
一般都是先将局部变量加载到操作数栈，然后对操作数栈这个数据进行处理后再
将操作数栈的数据存储到局部变量表
</code></pre><h4 id="i-与-i的原理"><a href="#i-与-i的原理" class="headerlink" title="i++与++i的原理"></a>i++与++i的原理</h4><pre><code>①int i = 0;  ②int i = 0;  3、int i = 0;
  i = i++;    i = ++i;      i++
 对应的字节码。
   ①iconst_0        ②iconst_0
    istore_1          istore_1
    iload_1           iinc 1,1 该命令给局部变量表的1号位置的int值增加1
    iinc 1,1          iload_1
    istore_1          istore_1
 ①虽然都有 iinc 1,1的操作，但是1在自增后没有将局部变量i自增后的值load到操作数栈（缺少 iload_1命令），
 导致自增的值被istore_1 原来操作数栈0的值给覆盖了。
 2与3的效果作用一样，都是包含iload的操作
</code></pre><h4 id="for-each的处理"><a href="#for-each的处理" class="headerlink" title="for each的处理"></a>for each的处理</h4><pre><code>For-each语法内部，对collection是用nested iteratoration来实现的，对数组是用下标遍历来实现。
</code></pre><h4 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h4><pre><code>Integer i = 10;
int n = i;
对应的字节码：装箱的时候是用到包装类的valueof(),拆箱时候用到的是包装类的intValue();
INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
INVOKEVIRTUAL java/lang/Integer.intValue ()
Integer包装类在加载的时候会初始化-128到127的缓存对象值，所以比较==的时候需要注意。
</code></pre><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><pre><code>List&lt;String&gt; list=new ArrayList&lt;&gt;();
list.add(&quot;1&quot;);
String a=list.get(1);
对应字节码：没有一点泛型的信息。
INVOKEINTERFACE java/util/List.add (Ljava/lang/Object;)Z
ALOAD 0
ICONST_1
INVOKEINTERFACE java/util/List.get (I)Ljava/lang/Object;
CHECKCAST java/lang/String
ASTORE 1
java泛型的实现原理是类型擦除。Java的泛型是伪泛型。在编译期间，所有的泛型信息都会被擦除掉。
JAVA的泛型只是一个语法糖，实际上在运行时还是有类型转换的过程，从JVM生成的代码来看，
和传递一个Object（或者extends的类型）没什么区别。当然泛型的最大好处是编绎期的类型错误检查
</code></pre><h3 id="20170711-linux常用命令复习"><a href="#20170711-linux常用命令复习" class="headerlink" title="20170711-linux常用命令复习"></a>20170711-linux常用命令复习</h3><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><pre><code>例如 777 rwx rwx rwx
从左至右，1-3位数字代表文件所有者的权限，4-6位数字代表同组用户的权限，7-9数字代表其他用户的权限。
r=4，w=2，x=1
</code></pre><h3 id="20170712-QPS"><a href="#20170712-QPS" class="headerlink" title="20170712-QPS"></a>20170712-QPS</h3><pre><code>qps类似于tps，是可以反映系统吞吐量的重要指标。
QPS（TPS）= 并发数/平均响应时间    或者   并发数 = QPS*平均响应时间。
qps是和并发数有关的，相同qps的如果并发数越大，证明系统性能越好。
当别人说系统qps的时候先问下是在多大并发下的指标
</code></pre><h3 id="20170713-TCP-IP相关"><a href="#20170713-TCP-IP相关" class="headerlink" title="20170713-TCP/IP相关"></a>20170713-TCP/IP相关</h3><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><pre><code>https使用对称加密+非对称加密+CA(赛门铁克CA)认证 三个技术合并到一起，才保证数据传输的安全。
首先使用RSA算法生产一对秘钥 K1和K2，K1是公钥，k2是秘钥，K1加密后的数据必须要K2才可以解密。
服务端发送K1到目的地，然后目的地在生成一个用来对称加密传输的秘钥K3,然后再用k1就加密k3
再传输给服务端，服务端再用k2去解密得到秘钥k3,这样双方就可以进行aes对称加密算法进行传输
</code></pre><h4 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h4><pre><code>200 - 服务器成功返回网页
404 - 请求的网页不存在
503 - 服务器超时
3xx -重定向
</code></pre><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><pre><code>应用层：应用软件使用的协议，例如pop3/smtp/http协议
表示层： 决定数据的展现方式，比如图片可以是jpeg/bmp/png
会话层:为两端通信实体建立连接
传输层：将数据分成很多小段，进行传输
网络层：路由选择，选择通信使用协议http,ftp ，指定路由策略
数据链路层：根据端口与MAC地址，做分组（VLAN）隔离、端口安全、访问控制。
物理层：将数据最终编码为用0、1标识的比特流，然后传输
</code></pre><h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h4><pre><code>应用层：
    FTP、DNS、HTTP协议
    可以对应osi的应用层、表示层、会话层。
传输层：tcp与udp协议
网络层：
链路层：硬件部分如 网卡、光纤
</code></pre><h4 id="TCP数据段格式"><a href="#TCP数据段格式" class="headerlink" title="TCP数据段格式"></a>TCP数据段格式</h4><pre><code> 顺序号字段：Seq序号，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。　　
 确认号字段：只有ACK标志为1时，确认号字段才有效。　
 SYN：发起一个连接
 ACK：确认序号有效
 FIN:释放一个连接
 需要注意的是：
（A）不要将确认序号Ack与标志位中的ACK搞混了。
（B）确认方Ack=发起方Req+1，两端配对。
</code></pre><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><pre><code>    第一次握手：client端将标志位syn置为1，随机产生一个序号seq=j,然后将该数据包发送给
server端，client进入syn_sent状态，等待server确认。
     第二次握手：server端收到数据包后，通过标志位syn=1知道client端要请求建立连接，server
端将标志位SYN和ACK都置为1，ack=j+1（确认序号）,随机产生一个seq=K,并将该数据包发给client以确认请求，
server端进入syn_rcvd状态。
      第三次握手：client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将ACK置为1，
ack=K+1，并将该数据包发给server，server检查ack是否为K+1,ACK是否为1，如果正确则建立成功
，client和server进入established状态，完成三次握手，随后进行数据传输。established
</code></pre><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><pre><code>主动关闭流程，客户端先发起申请
第一次挥手：client端发送FIN，用来关闭client到server端的数据传输，client进入fin_wait_!状态。
第二次挥手：server端收到FIN后，发送一个ACK到client端，确认序号为收到序号+1，server进入close_wait状态
第三次挥手：server发送一个FIN,用来关闭server到client的数据传输，server进入last_ack状态
第四次挥手：client收到FIN，client进入TIME_WAIT状态，接着发送一个ACK给server 确认序号为收到序号+1，
server进入closed状态，完成四次挥手。
为什么建立连接是三次握手，而关闭连接却是四次挥手呢
服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，
仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，
也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。
通俗说就是挥手的时候是server端先发送ACK 然后再发送FIN
</code></pre><h4 id="syn攻击"><a href="#syn攻击" class="headerlink" title="syn攻击"></a>syn攻击</h4><pre><code>    在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，
当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，
Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，
这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。
SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，
使用如下命令可以让之现行：
#netstat -nap | grep SYN_RECV
</code></pre><h4 id="与http相关协议"><a href="#与http相关协议" class="headerlink" title="与http相关协议"></a>与http相关协议</h4><pre><code>ip协议:使用 ARP 协议凭借 MAC 地址进行通信
tcp协议:TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对,
为了确保信息能够确保准确无误的到达，TCP采用了著名的三次握手策略.
dns:DNS(Domain names System) 和HTTP协议一样是处于应用层的服务，提供域名到IP地址之间的解析服务
</code></pre><h4 id="time-wait与close-wait"><a href="#time-wait与close-wait" class="headerlink" title="time_wait与close_wait"></a>time_wait与close_wait</h4><pre><code>服务器在处理客户端请求的时候，如果你的程序设计为服务器主动关闭，那么你才有可能需要关注这个TIMEWAIT状态过多的问题。
如果你的服务器设计为被动关闭，那么你首先要关注的是CLOSE_WAIT。
</code></pre><h5 id="time-wait"><a href="#time-wait" class="headerlink" title="time_wait"></a>time_wait</h5><pre><code>主动正常关闭TCP连接，都会出现TIMEWAIT。
在高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接这个场景下，会出现大量socket处于TIMEWAIT状态。
如果客户端的并发量持续很高，此时部分客户端就会显示连接不上
高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。
如何尽量处理TIMEWAIT过多
linux没有在sysctl或者proc文件系统暴露修改这个TIMEWAIT超时时间的接口，可以修改内核协议栈代码中关于这个TIMEWAIT的超时时间参数，重编内核，让它缩短超时时间，加快回收
sysctl改两个内核参数就行了，如下：
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
</code></pre><h5 id="close-wait"><a href="#close-wait" class="headerlink" title="close_wait"></a>close_wait</h5><pre><code>    服务器A是一台爬虫服务器，它使用简单的HttpClient去请求资源服务器B上面的apache获取文件资源，正常情况下，如果请求成功，那么在抓取完 资源后，
服务器A会主动发出关闭连接的请求，这个时候就是主动关闭连接，服务器A的连接状态我们可以看到是TIME_WAIT。
如果一旦发生异常呢？假设 请求的资源服务器B上并不存在，那么这个时候就会由服务器B发出关闭连接的请求，服务器A就是被动的关闭了连接，
如果服务器A被动关闭连接之后程序员忘了 让HttpClient释放连接，那就会造成CLOSE_WAIT的状态了
</code></pre><h4 id="tcp粘包、拆包"><a href="#tcp粘包、拆包" class="headerlink" title="tcp粘包、拆包"></a>tcp粘包、拆包</h4><p>   <a href="&quot;https://my.oschina.net/andylucc/blog/625315&quot;">TCP粘包拆包问题</a></p>
<pre><code>客户端和服务器建立一个连接，客户端连续发送两条消息，客户端关闭与服务端的连接。
如果服务端只收到一个数据包，这个数据包包含客户端的两条消息，这时候就发生了TCP粘包。
如果服务端收到两个数据包，第一个数据包包含数据的一部分，第二个数据包包含第一台消息的后半部分和第二条消息，这时候就发生TCP拆包
发生TCP粘包、拆包主要是由于下面一些原因：
 1、应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。
 2、应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
 3、进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包。
 4、接收方法不及时读取套接字缓冲区数据，这将发生粘包。
 如何处理粘包、拆包问题：
 使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。
 设置定长消息，服务端每次读取既定长度的内容作为一条完整消息。
 设置消息边界，服务端从网络流中按消息编辑分离出消息内容。
</code></pre><h4 id="如何提高单机短连接QPS"><a href="#如何提高单机短连接QPS" class="headerlink" title="如何提高单机短连接QPS"></a>如何提高单机短连接QPS</h4><pre><code>http://weibo.com/ttarticle/p/show?id=2309404037884855362229
tcp应该有客户端发起连接关闭，默认情况下客户端关闭TCP连接后本地的临时端口
会进入time_wait状态，这对qps提升有很大限制
增加临时端口的数量，增加可被消耗的临时端口资源
sysctl -w &quot;net.ipv4.ip_local_port_range=1024 65535”
第一种方法是启用tw_reuse，tw_reuse能加速TIME_WAIT状态端口在几秒时间内安全的回收
sysctl -w net.ipv4.tcp_timestamps=1
sysctl -w net.ipv4.tcp_tw_reuse=1
2.6.32内核下启动tw_reuse短连接可以达到2w，性能并不稳定；
第二种方法更激进些，启用tw_recycle，tw_recycle允许在两个RTT。当多个客户端处于NAT后时，在服务器端开启tw_recycle会引起丢包问题，如果丢SYN包，就会造成新建连接失败
sysctl -w net.ipv4.tcp_timestamps=1
sysctl -w net.ipv4.tcp_tw_recycle=1
2.6.32内核下启动tw_recycle短连接可以达到6w，比较稳定；
</code></pre><h4 id="etc-sysctl-conf"><a href="#etc-sysctl-conf" class="headerlink" title="/etc/sysctl.conf"></a>/etc/sysctl.conf</h4><pre><code>#对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃,不应该大于255，默认值是5，对应于180秒左右时间
net.ipv4.tcp_syn_retries=2
#net.ipv4.tcp_synack_retries=2
#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为300秒
net.ipv4.tcp_keepalive_time=1200
net.ipv4.tcp_orphan_retries=3
#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间
net.ipv4.tcp_fin_timeout=30
#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。
net.ipv4.tcp_max_syn_backlog = 4096
#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭
net.ipv4.tcp_syncookies = 1

#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭
net.ipv4.tcp_tw_reuse = 1
#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭
net.ipv4.tcp_tw_recycle = 1

##减少超时前的探测次数
net.ipv4.tcp_keepalive_probes=5
##优化网络设备接收队列
net.core.netdev_max_backlog=3000
修改完之后执行/sbin/sysctl -p让参数生效。
这里头主要注意到的是net.ipv4.tcp_tw_reuse
net.ipv4.tcp_tw_recycle
net.ipv4.tcp_fin_timeout
net.ipv4.tcp_keepalive_*
这几个参数。
net.ipv4.tcp_tw_reuse和net.ipv4.tcp_tw_recycle的开启都是为了回收处于TIME_WAIT状态的资源。
net.ipv4.tcp_fin_timeout这个时间可以减少在异常情况下服务器从FIN-WAIT-2转到TIME_WAIT的时间。
net.ipv4.tcp_keepalive_*一系列参数，是用来设置服务器检测连接存活的相关配置。
</code></pre><h3 id="20170714-mysql相关"><a href="#20170714-mysql相关" class="headerlink" title="20170714-mysql相关"></a>20170714-mysql相关</h3><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><pre><code>1. 优化更需要优化的Query；
2. 定位优化对象的性能瓶颈；
3. 明确的优化目标；
4. 从Explain 入手；
5. 多使用profile
6. 永远用小结果集驱动大的结果集；
7. 尽可能在索引中完成排序；
8. 只取出自己需要的Columns；
9. 仅仅使用最有效的过滤条件；
10. 尽可能避免复杂的Join 和子查询；
</code></pre><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><pre><code>1. MyISAM 存储引擎索引键长度总和不能超过1000 字节；
2. BLOB 和TEXT 类型的列只能创建前缀索引；
3. MySQL 目前不支持函数索引；
4. 使用不等于（!= 或者&lt;&gt;）的时候MySQL 无法使用索引；
5. 过滤字段使用了函数运算后（如abs(column)），MySQL 无法使用索引；
6. Join 语句中Join 条件字段类型不一致的时候MySQL 无法使用索引；
7. 使用LIKE 操作的时候如果条件以通配符开始（ &apos;%abc...&apos;）MySQL 无法使用索引；
8. 使用非等值查询的时候MySQL 无法使用Hash 索引；
9. 某字段类型为varchar类型，根据查询关键字段查询时，写入值为Int类型，导致无法命中索引
10.查询条件左边写入函数，导致无法命中索引
</code></pre><h4 id="10条SQL技巧"><a href="#10条SQL技巧" class="headerlink" title="10条SQL技巧"></a>10条SQL技巧</h4><pre><code>1.负向条件查询不能使用索引
select * from order where status!=0 and stauts!=1
    not in/not exists/&lt;&gt; 都不行
    可以优化为in查询：
    select * from order where status in(2,3)
2.前导模糊查询不能使用索引
    select * from order where desc like &apos;%XX&apos;
   而非前导模糊查询则可以：
    select * from order where desc like &apos;XX%&apos;
3.数据区分度不大的字段不宜使用索引
    select * from user where sex=1
    原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。
    经验上，能过滤80%数据时就可以使用索引。
    对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。
4.在属性上进行计算不能命中索引
    select * from order where YEAR(date) &lt; = &apos;2017&apos;
    可以改成属性右边的函数
    select * from order where date &lt; = CURDATE()
    或者：
    select * from order where date &lt; = &apos;2017-01-01&apos;
5.允许为null的列，查询有潜在大坑(特别注意)
    单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集
    select * from user where name != &apos;shenjian&apos;
    如果name允许为null，索引不存储null值，结果集中不会包含这些记录，会导致查询的结果缺少结果集
6.复合索引最左前缀，并不是值SQL语句的where顺序要和复合索引一致
7.如果明确知道只有一条结果返回，limit 1能够提高效率
     select * from user where login_name=?
     可以优化为：
     select * from user where login_name=? limit 1
    你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动
8.把计算放到业务层而不是数据库层，除了节省数据的CPU，还有意想不到的查询缓存优化效果
    释放了数据库的CPU
    多次调用，传入的SQL相同，才可以利用查询缓存
9.强制类型转换会全表扫描
    select * from user where phone=13800001234;
        改成
    select * from user where phone=&quot;13800001234&quot;;
</code></pre><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre><code>较频繁的作为查询条件的字段应该创建索引
唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件；
更新非常频繁的字段不适合创建索引
单键索引还是组合索引
</code></pre><h5 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h5><pre><code>主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引
聚簇索引的叶子节点就是数据节点.
特点是存储数据的顺序和索引顺序一致
</code></pre><h5 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h5><pre><code>叶子节点仍然是索引节点，只不过有指向对应数据块的指针,索引表中的顺序通常与实际的页码顺序是不一致
</code></pre><h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h5><pre><code>多个字段建立的索引，组合索引的第一个字段必须出现在查询组句中，不然会导致索引失效
比如组合索引create index index_a_b_c on table（a,b,c）
a|(a,b|b,a)|a,b,c等等 但是如果是 b,c索引就不会生效了。
最左前缀就是最左的索引列优先，b,a都会被数据库引擎优化成ab这种顺序，
</code></pre><h5 id="左前缀索引"><a href="#左前缀索引" class="headerlink" title="左前缀索引"></a>左前缀索引</h5><pre><code>追加Index时，计算数据唯一性巧妙添加左前缀索引，提高索引命中率，保证索引字段唯一性
//以此算出城市拼音缩写长度为3时，命中率和唯一性比较高，则写下如下SQL：
例如 ALTER TABLE `city` ADD INDEX `index_on_pinyinInitial` USING BTREE (pinyin_initial(3));
</code></pre><h5 id="explain参数分析"><a href="#explain参数分析" class="headerlink" title="explain参数分析"></a>explain参数分析</h5><pre><code>select_type：执行类型 simple为简单查询类型
type: const 标示查询结果最多匹配一行，查询很快，从最好到最差的连接类型为
const（常量查询）、eq_reg（使用唯一索引查找(主键或唯一索引)）、ref（非唯一索引访问(只有普通索引)）
、range（一般用于&gt;= &lt;= ）、index和ALL（都全表扫描）
key： 实际使用的索引。如果为NULL，则没有使用索引
rows：MySQL认为必须检查的用来返回请求数据的行数
key_len的长度计算公式：
所有的索引字段，如果没有设置not null，则需要加一个字节。
定长字段，int占四个字节、date占三个字节、char(n)占n个字符。
对于变成字段varchar(n)，则有n个字符+两个字节。
不同的字符集，一个字符占用的字节数不同。latin1编码的，一个字符占用一个字节，gbk编码的，一个字符占用两个字节，utf8编码的，一个字符占用三个字节。
varchr(10)变长字段且允许NULL    =  10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)
varchr(10)变长字段且不允许NULL =  10 *( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)
char(10)固定字段且允许NULL        =  10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)
char(10)固定字段且不允许NULL        =  10 * ( character set：utf8=3,gbk=2,latin1=1)
</code></pre><h3 id="20170715-springmvc相关"><a href="#20170715-springmvc相关" class="headerlink" title="20170715-springmvc相关"></a>20170715-springmvc相关</h3><h4 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h4><pre><code>1、如果其他类实现了BeanFactoryPostProcessor，那就先调用postProcessBeanFactory（）
BeanFactoryPostProcessor是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的
实现该接口，可以在spring的bean创建之前，修改bean的定义属性。
如果是当前类实现了BeanFactoryPostProcessor，那么会在afterPropertiesSet之后被调用
2、然后调用对象的构造方法，实例化
3、如果类实现了BeanNameAware 则调用setBeanName()
4、如果类实现了BeanPostProcessor 则调用postProcessBeforeInitialization
5、如果累实现了InitializingBean 则调用afterPropertiesSet（）
7、如果指定了init方法也会调用
6、如果类实现了BeanPostProcessor 则调用postProcessAfterInitialization（）
9、如果bean实现了ApplicationContextAware，则可以把上下文环境传过去。
9、如果累实现了DisposableBean 执行 destroy方法

如果我们在bean加载之后扩展这个bean，就可以通过BeanFactoryPostProcessor实现
通过postProcessBeforeInitialization和postProcessAfterInitialization
在bean加载之前或加载之后进行代理
</code></pre><h4 id="url请求流程"><a href="#url请求流程" class="headerlink" title="url请求流程"></a>url请求流程</h4><pre><code>1、用户发送url请求，然后请求被dispatchServlet拦截。
2、dispartchServlet解析url,根据url调用HandleMapping获取该handler配置的
相关拦截器，根据handler获取handlerAdapter调用controller里面的对应方法，
3，controller执行完后返回ModerAndView,然后视图解析器viewReslove解析后返回具体
的view
4,dispartcherServlet根据view来渲染视图，再将渲染结果返回给客户端。
</code></pre><h3 id="20170717-接口幂等性"><a href="#20170717-接口幂等性" class="headerlink" title="20170717-接口幂等性"></a>20170717-接口幂等性</h3><pre><code>接口的幂等性在于无论接口被调用多少次，返回的值都是一样的。
幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的。
</code></pre><h4 id="接口幂等场景"><a href="#接口幂等场景" class="headerlink" title="接口幂等场景"></a>接口幂等场景</h4><pre><code>重复下单，可以使用token去控制，
重复支付，根据生成的seq去调用支付，可以防止重复支付，如果是因为第三方平台没有及时返回支付成功状态，可以使用对账
重复调用推送接口，比如消息推送接口，如果别人多次调用可能导致用户收到重复的内容，为了防止运营的手误重复点击，对
推送内容增加判断，对推送内容进行md5加密 ，如果推送内容md5一样就直接返回推送成功，保证系统只处理一次推送请求。
</code></pre><h3 id="20170718-线程池大小如何设置"><a href="#20170718-线程池大小如何设置" class="headerlink" title="20170718-线程池大小如何设置"></a>20170718-线程池大小如何设置</h3><pre><code>如果是CPU密集型应用，则线程池大小设置为N+1
如果是IO密集型应用，则线程池大小设置为2N+1
</code></pre><h3 id="20170731-mysql删除"><a href="#20170731-mysql删除" class="headerlink" title="20170731-mysql删除"></a>20170731-mysql删除</h3><pre><code>delete语句删除的时候 表名称不能加别名例如：
DELETE from tb_media_settlement a where a.article_id in(
select t.id from tb_article t where t.custom_id=47 and t.media_id is null
)
只能用
DELETE from tb_media_settlement where article_id in(
  select t.id from tb_article t where t.custom_id=47 and t.media_id is null
)
</code></pre><h3 id="20170802-window删除大量文件和文件"><a href="#20170802-window删除大量文件和文件" class="headerlink" title="20170802-window删除大量文件和文件"></a>20170802-window删除大量文件和文件</h3><pre><code>删除文件和删除文件夹命令
del /f/s/q foldername &gt; nul
rmdir /s/q foldername
</code></pre><h3 id="20170829-findbugs插件提示的优化代码"><a href="#20170829-findbugs插件提示的优化代码" class="headerlink" title="20170829-findbugs插件提示的优化代码"></a>20170829-findbugs插件提示的优化代码</h3><pre><code>1、Map迭代的时候，最好用 map.entrySet的形式
Map.Entry&lt;Integer, CategoryVO&gt; entry : map.entrySet()
2、用到equals的时候需要留个心眼，如果其他组提供的XXDTO需要比较的这个字段是Integer类型
 ,而你定义临时变量类型是String类型，这时候需要把Integer类型的变量转换成String类型再比较
 if((shop.getShopId() + &quot;&quot;).equals(shopId))
 或者
 Integer i=1;
 i.equals(&quot;1&quot;) 肯定是false,因为Integer重写了equals方法。

 Integer a=1;
 int b=1;
 Integer和int比都会自动拆箱
</code></pre><h3 id="20170918-Comparable与Comparator"><a href="#20170918-Comparable与Comparator" class="headerlink" title="20170918-Comparable与Comparator"></a>20170918-Comparable与Comparator</h3><pre><code>平常用到一些map的排序，可能需要重写他的排序规则。
Comparable：内比较器，一些类只要实现了这个接口，就可以自己和自己比较。
Comparator：外比较器，比如某些类没有实现Comparable接口，只能使用类似这样的写法
Map&lt;Date, EduGoodHourStockDTO&gt; map = new TreeMap&lt;Date, EduGoodHourStockDTO&gt;(new Comparator&lt;Date&gt;() {
    @Override

    public int compare(Date o1, Date o2) {
        return 0;
    }
 });

 public static class TreeValue implements Comparable&lt;TreeValue&gt; {
         int score;
         public TreeValue(int score) {
             this.score = score;
         }

         public int compareTo(TreeValue o) {
             //从小到大
             if (this.score&gt;o.score  )
                 return 1;
                 //当前值小于被比较的值 返回-1 从小到大
             else if (this.score &lt;o.score )
                 return -1;
             else
                 return 0;
         }
 }
 或者
 Collections.sort(configLoaders, OrderComparator.INSTANCE);
 public class OrderComparator implements Comparator&lt;Object&gt; {
     public static final Comparator&lt;Object&gt; INSTANCE = new OrderComparator();

     public OrderComparator() {
     }

     public static Comparator&lt;Object&gt; getInstance() {
         return INSTANCE;
     }
     //lhs first object to be compared  ,rhs second
     public int compare(Object lhs, Object rhs) {
         Order lhsOrder = (Order)lhs.getClass().getAnnotation(Order.class);
         Order rhsOrder = (Order)rhs.getClass().getAnnotation(Order.class);
         if (lhsOrder == null &amp;&amp; rhsOrder == null) {
             return 0;
         } else if (rhsOrder == null) {
             return 1;
         } else {
             return lhsOrder == null ? -1 : Integer.signum(lhsOrder.value() - rhsOrder.value());
         }
     }
 }

 默认是从小到大
</code></pre><h3 id="20170924-static修饰符"><a href="#20170924-static修饰符" class="headerlink" title="20170924-static修饰符"></a>20170924-static修饰符</h3><pre><code>static修饰的对象或者变量都是全局共享的，一个类中，一个static变量只会有一个内存空间，虽然有多个类实例，
但这些类实例中的这个static变量会共享同一个内存空间。
static的变量是在类装载的时候就会被初始化，即，只要类被装载，不管是否使用了static变量，都会被初始化
</code></pre><h3 id="20170925-Exception与RuntimeException"><a href="#20170925-Exception与RuntimeException" class="headerlink" title="20170925-Exception与RuntimeException"></a>20170925-Exception与RuntimeException</h3><pre><code>自定义异常继承了Exception就必须要强制检查
自定义异常继承了RuntimeException 不需要强制检查
</code></pre><h3 id="20170928-公司同事guva分享记录"><a href="#20170928-公司同事guva分享记录" class="headerlink" title="20170928-公司同事guva分享记录"></a>20170928-公司同事guva分享记录</h3><pre><code>字符串截取： &quot;,a,,b,c&quot; 按照逗号截取
</code></pre><h3 id="20171012-包装类比较"><a href="#20171012-包装类比较" class="headerlink" title="20171012-包装类比较"></a>20171012-包装类比较</h3><pre><code>Integer包装类比较的时候最好用equals去比较，因为equals会将Integer转换成int类型去比较
</code></pre><h3 id="20171018-String-replace注意"><a href="#20171018-String-replace注意" class="headerlink" title="20171018-String.replace注意"></a>20171018-String.replace注意</h3><pre><code>String 自带有好几种替换方式，
例如 replace(),replaceFirst(),replaceAll()
如果我们使用replace() 参数就是CharSequence
如果使用replaceFirst(),replaceAll() 被比较的参数就是regex正则后的字符串.
比如&quot;$&quot;这个字符属于特殊字符 那么可以使用 replace(&quot;$&quot;) 和replaceFirst(&quot;\\$&quot;)
</code></pre><h3 id="20171024-map-putIfAbsent-key-value"><a href="#20171024-map-putIfAbsent-key-value" class="headerlink" title="20171024-map.putIfAbsent(key,value)"></a>20171024-map.putIfAbsent(key,value)</h3><pre><code>map 其实有一个方法叫map.putIfAbsent(key,value)，
如果已经存在了，就不会再添加了，返回旧的value
如果不存在，就返回空的value类型（null或者&quot;&quot;）
map.put(key,value) 返回的是oldValue;
</code></pre><h3 id="20171106-URLEncoder-encode（）与decode"><a href="#20171106-URLEncoder-encode（）与decode" class="headerlink" title="20171106- URLEncoder.encode（）与decode()"></a>20171106- URLEncoder.encode（）与decode()</h3><pre><code>url encode与decode 有两大功能
1、解决中文在get提交的时候乱码问题，只要encode和decode的字符集一样，肯定不会出现乱码情况，而且某些特殊
字符也不允许出现在url里面
2、解决url里面带url的情况
比如： http://www.baidu.com?param1=aa&amp;redirectUrl=http://www.dianping.com?p1=bb&amp;&amp;p2=cc&amp;&amp;param2=dd
我们想要的是：redirectUrl=http://www.dianping.com?p1=bb&amp;&amp;p2=cc
但是如果不encode最终传输的url解析到的就是redirectUrl=http://www.dianping.com?p1=bb
p2=cc这个参数就会被丢失。
</code></pre><h3 id="20171122-utf-8与gbk"><a href="#20171122-utf-8与gbk" class="headerlink" title="20171122- utf-8与gbk"></a>20171122- utf-8与gbk</h3><pre><code>一个中文在uft-8下面占用三个字节，在gbk下面占用2个字节
</code></pre><h3 id="20180119-maven依赖原则"><a href="#20180119-maven依赖原则" class="headerlink" title="20180119-maven依赖原则"></a>20180119-maven依赖原则</h3><pre><code>1.间接依赖路径最短优先
一个项目test依赖了a和b两个jar包。其中a-b-c1.0 ， d-e-f-c1.1 。由于c1.0路径最短，所以项目test最后使用的是c1.0。
2.pom文件中申明顺序优先
有人就问了如果 a-b-c1.0 ， d-e-c1.1 这样路径都一样怎么办？其实maven的作者也没那么傻，会以在pom文件中申明的顺序那选，
如果pom文件中先申明了d再申明了a，test项目最后依赖的会是c1.1
所以maven依赖原则总结起来就两条：路径最短，申明顺序其次。
</code></pre><h3 id="20180122-简单的linux脚本"><a href="#20180122-简单的linux脚本" class="headerlink" title="20180122-简单的linux脚本"></a>20180122-简单的linux脚本</h3><pre><code>for i in {1..27}
do
   curl -o $i.txt http://www.dianping.com/sitemap/education/mt/shop/$i.txt
done
</code></pre><h3 id="20180208-mysql-utf8-unicode-ci、utf8-general-ci的区别"><a href="#20180208-mysql-utf8-unicode-ci、utf8-general-ci的区别" class="headerlink" title="20180208-mysql utf8_unicode_ci、utf8_general_ci的区别"></a>20180208-mysql utf8_unicode_ci、utf8_general_ci的区别</h3><pre><code>i是 case insensitive, 即 &quot;大小写不敏感&quot;, a 和 A 会在字符判断中会被当做一样的;
bin 是二进制, a 和 A 会别区别对待.
例如你运行:
SELECT * FROM table WHERE txt = &apos;a&apos;
那么在utf8_bin中你就找不到 txt = &apos;A&apos; 的那一行, 而 utf8_general_ci 则可以.
utf8_general_ci 不区分大小写，这个你在注册用户名和邮箱的时候就要使用。
utf8_general_cs 区分大小写，如果用户名和邮箱用这个 就会照成不良后果
utf8_bin:字符串每个字符串用二进制数据编译存储。 区分大小写，而且可以存二进制的内容
</code></pre><h3 id="20180306-mysql-unique与primary"><a href="#20180306-mysql-unique与primary" class="headerlink" title="20180306- mysql unique与primary"></a>20180306- mysql unique与primary</h3><pre><code>数据基础知识了，primary key = unique +  not null
unique修饰的key 可以为空
一个表只能有一个主键，但是可以有好多个UNIQUE
insert into values与value
values 插入单条记录快
value 插入多条记录快
</code></pre><h3 id="20180307-mysql-longText与text类型"><a href="#20180307-mysql-longText与text类型" class="headerlink" title="20180307- mysql longText与text类型"></a>20180307- mysql longText与text类型</h3><pre><code>longText：4294967295/3=1431655765个汉字，14亿，存储空间占用：4294967295/1024/1024/1024=4G的数据；
 text：65535/3=21845个汉字，约20000，存储空间占用：65535/1024=64K的数据；
</code></pre><h3 id="20180308-less倒序"><a href="#20180308-less倒序" class="headerlink" title="20180308- less倒序"></a>20180308- less倒序</h3><pre><code>less  xx.log, shift+g移动到最后一行,ctrl+b往前
</code></pre><h3 id="20180313-字符串以逗号隔开"><a href="#20180313-字符串以逗号隔开" class="headerlink" title="20180313-字符串以逗号隔开"></a>20180313-字符串以逗号隔开</h3><pre><code>StringUtils.join(list,&quot;,&quot;)
</code></pre><h3 id="20180402-mysql-bit"><a href="#20180402-mysql-bit" class="headerlink" title="20180402-mysql bit"></a>20180402-mysql bit</h3><pre><code>mysql长度int(m) M指示最大显示宽度。最大有效显示宽度是255。显示宽度与存储大小或类型包含的值的范围无关;
我们建立这个长度是为了告诉MYSQL数据库我们这个字段的存储的数据的宽度为5位数,  当然如果你不是5位数(只要在该类型的存储范围之内)MYSQL也能正常存储,
MySQL5.0以前,BIT只是TINYINT的同义词而已。但是在MySQL5.0以及之后的版本,BIT是一个完全不同的数据类型
tinyint 1字节，smallint 2字节，mediumint 默认3字节，int 4字节，bigint 8字节
BIT(M)类型允许存储M位值,M为位数，默认为4，如果M位1，那就是0或者1，可以用来表示是否删除字段
TINYINT 一个字节，支持 -128到127(SIGNED)，0到255(UNSIGNED)
bigint 8个字节带符号的 9223372036854774807，不带符号的18446744073709551615
BOOL——同TINYINT(1)
DATETIME 8个字节 固定格式格式：&apos;YYYY-MM-DD HH:MM:SS&apos;  范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
TIMESTAMP 4个字节   范围为1970-01-01 08:00:01到2038-01-19 ,timestamp会跟随设置的时区变化而变化，而datetime保存的是绝对值不会变化。
VARCHAR(M)   M是字符数，在utf-8模式下 一个中文等于一个3字节
TINYBLOB, TINYTEXT   L+1 字节, 在此L&lt; 2 ^ 8
BLOB, TEXT   L+2 字节, 在此L&lt; 2 ^ 16
</code></pre><h3 id="20180412-不停机数据迁移与分表"><a href="#20180412-不停机数据迁移与分表" class="headerlink" title="20180412- 不停机数据迁移与分表"></a>20180412- 不停机数据迁移与分表</h3><pre><code>随着业务递增，单表查询效率降低，所以需要进行分表操作，同时因为这个表的特殊性，需要将表从A库迁移到B库之后再分表。
一、数据迁移
 1、上线双写代码，所有写操作都会写A库同时，也会写一份到B库，但是查只查A库
 2、进行数据迁移，用脚本或者job将A库的全量数据，同步到B库
 3、A与B库数据一致性比对job。
 4、上线取消写A库代码的数据源，同时改成查B库，下线A库，
 二、分表
 1、新增分表键字段，根据分表键取模%128 新建多128分表
 2、上线分表代码，表新的写操作都会写入不同的表,读只读主表。
 3、job将主表的数据全量同步到给个分表,可以同步java代码，也可以通过读取全量的binlog日志
 4、上线分表代码，根据分表键读取不同的表。
</code></pre><h3 id="20180417-Resource与-Autowired等常用注解"><a href="#20180417-Resource与-Autowired等常用注解" class="headerlink" title="20180417- @Resource与@Autowired等常用注解"></a>20180417- @Resource与@Autowired等常用注解</h3><pre><code>@Resource、@PostConstruct以及@PreDestroy 是JSR-250规范定义的注解
@Resource与@Autowried的区别在于 @Resource是基于bean的ame进行注入的，而@Autowried是基于bean类型注入的
@Resource有两个参数name和type，默认都不填则按照bean的name进行注入的。
使用场景，比如一个接口多个实现：
可以使用 @Autowired+@Qualifie 或者@Resource+不同的bean的name
@Autowired默认是按照类型来找的，如果一个接口两个实现，因为类型一致，Autowired的兜底方案是根据@Autowired变量的byname去找
@Service用于标注业务层组件
@Controller用于标注控制层组件（如struts中的action）
@Repository用于标注数据访问组件，即DAO组件F
@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。
</code></pre><h3 id="20180421-Java泛型中E、T、K、V等的含义"><a href="#20180421-Java泛型中E、T、K、V等的含义" class="headerlink" title="20180421- Java泛型中E、T、K、V等的含义"></a>20180421- Java泛型中E、T、K、V等的含义</h3><pre><code>E表示element 数组、集合之类
T表示 Type（Java 类）
K - Key（键）
V - Value（值）
N - Number（数值类型）
？ -  表示不确定的java类型
S、U、V  - 2nd、3rd、4th types
</code></pre><h3 id="20180502-BigDecimal注意事项"><a href="#20180502-BigDecimal注意事项" class="headerlink" title="20180502- BigDecimal注意事项"></a>20180502- BigDecimal注意事项</h3><pre><code>new BigDecimal(0.03) 会出现丢失精度，最好使用   new BigDecimal(&quot;&quot;）
BigDecimal的比较要用compareTo ，不能用equal
BigDecimal的除法要养成习惯去设置精度，以免出现无限循环小数而抛异常。
</code></pre><h3 id="20180509-jvm异常退出hook线程"><a href="#20180509-jvm异常退出hook线程" class="headerlink" title="20180509- jvm异常退出hook线程"></a>20180509- jvm异常退出hook线程</h3><pre><code>jvm强制退出的时候 等待ShutdownHook程序执行完全,
但如过JVM由于某些内部错误而崩溃，或（Unix / Linux中的kill -9）或TerminateProcess（Windows）），
那么应用程序需要立即终止而不会甚至等待任何清理活动
关闭钩子本质上是一个线程（也称为Hook线程），对于一个JVM中注册的多个关闭钩子它们将会并发执行，
所以JVM并不保证它们的执行顺序；由于是并发执行的，那么很可能因为代码不当导致出现竞态条件或死锁等问题，
为了避免该问题，强烈建议在一个钩子中执行一系列操作
Runtime.getRuntime().addShutdownHook（）
</code></pre><h3 id="20180523-java位移运算与与运算"><a href="#20180523-java位移运算与与运算" class="headerlink" title="20180523- java位移运算与与运算"></a>20180523- java位移运算与与运算</h3><pre><code>首先位移运算肯定是高效的，jdk源码有大量使用
（1）机器都是使用补码，运算也是使用补码运算。
（2）正数的原码补码反码都一样。
（2）补码与原码相互转换，其运算过程是相同。
带符号左位移运算符&lt;&lt; ,数值的补码全部往左移动X位: a&lt;&lt;1 等于a*2 ，左移n位就相当于乘以2的n次方
例如1&lt;&lt;1 等于0001向左边位移一位，00010
带符号右位移运算符&gt;&gt;  a&gt;&gt;1 等于a/2  ，右移n位就相当于除以2的n次方
&amp;与运算，就是按位与运算，两个1才是1，否则都是0
例如2&amp;1 等于0010和0001 与运算，结果就是0000。
一般常用的就是某个数a&amp;1,那么结果要么是0要么是1。
</code></pre><h3 id="20180524-spring事物-Transactional"><a href="#20180524-spring事物-Transactional" class="headerlink" title="20180524- spring事物@Transactional"></a>20180524- spring事物@Transactional</h3><pre><code>spring的事物默认回滚非运行时异常RunTimeException,如果指定了rollbackFor的异常类型，例如Exception.class 那就需要
在try catch 之后再 throw exception，才会回滚。
注意1：
如果在controller层调用service层（service层没有加类级别的@transtaionl注解）的A方法（没有加@transtaionl），
A方法里面再调用B方法（加了@Transactional propagation = Propagation.REQUIRES_NEW)）
这时候B方法的事物也不会起效的。）

注意2：spring 事务REQUIRES_NEW 不起作用
如果在同一个类里面，A方法（有事务）调用B方法（要独立新事务） 这时候B的事务REQUIRES_NEW是不会新建的。
解决方法：需要将两个方法分别写在不同的类里。或者 方法写在同一个类里，但调用B方法的时候，将service自己注入自己，用这个注入对象来调用B方法

注意3：spring对于Propagation.REQUIRES_NEW的回滚策略
    不同的Service调用方法时：
    如果被调用方法是Propagation.REQUIRES_NEW，被catch后不抛出，事务可以正常提交；
    如果被调用方法是Propagation.REQUIRED，被catch后不抛出，后面的代码虽然可以执行下去，但最终还是会分出rollback-only异常；
    同一个Service中调用方法时：
    不论被调用方法注解是Propagation.REQUIRES_NEW 还是 Propagation.REQUIRED，其结果都是一样的，就是都被忽略掉了，等于没写。
    当其抛出异常时，只需catch住不抛出，事务就可以正常提交。

注意4：有事物的A方法调用没有事物的B方法（假设A、B不在同一个类），因为事物的传播特性，B方法的执行也是在A方法的事物里面的。


 在一个Service内部，事务方法之间的嵌套调用，普通方法和事务方法之间的嵌套调用，都不会开启新的事务.
 是因为spring采用动态代理机制来实现事务控制，而动态代理最终都是要调用原始对象的，而原始对象在去调用方法时，是不会再触发代理了！
 如果最外层方法有事物，那么其他的方法都是用同一个事物，如果最外层方法没有事物，那就以非事物行为调用。

 注意5：使用事物的时候最好设置事物的超时时间，比如批量插入和更新，或者一些rpc服务调用，都会长时间占用连接，导致数据库连接不够用。
</code></pre><h3 id="20180524-spring-Transactional注解被加载初始化顺序"><a href="#20180524-spring-Transactional注解被加载初始化顺序" class="headerlink" title="20180524- spring @Transactional注解被加载初始化顺序"></a>20180524- spring @Transactional注解被加载初始化顺序</h3><pre><code>了解事物初始化顺序需要先了解一些其他东西。
</code></pre><ul>
<li>InfrastructureAdvisorAutoProxyCreator</li>
</ul>
<pre><code>这个类的父类AbstractAutoProxyCreator实现了BeanPostProcessor而BeanPostProces的接口postProcessAfterInstantiation（）
会在所有bean你都实例化完成后被调用到。
AbstractAutoProxyCreator的父类是AbstractAdvisorAutoProxyCreator
它会自动获取spring容器中注册的所有的Advisor类（除了子类中isEligibleAdvisorBean（）
方法指定的不满足条件的Advisor除外。），然后自动给spring容器中满足Advisor中pointCut创建代理。
</code></pre><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><pre><code>注册InfrastructureAdvisorAutoProxyCreator和advisor BeanFactoryTransactionAttributeSourceAdvisor
</code></pre><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><pre><code>spring Bean实例化后调用BeanPostProcessor的回调函数postProcessAfterInitialization
然后根据BeanFactoryTransactionAttributeSourceAdvisor 对满足条件的bean进行增强代理
</code></pre><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><pre><code>若目标类的方法上存在@Transactional事务注解，那么就是满足条件的，会用TransactionAttributeSourcePointcut对类生成advisorProxyFactory生成代理
  AbstractAutoProxyCreator 创建增强类相关代码
  protected Object createProxy(
              Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {

          if (this.beanFactory instanceof ConfigurableListableBeanFactory) {
              AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
          }

          ProxyFactory proxyFactory = new ProxyFactory();
          proxyFactory.copyFrom(this);

          if (!proxyFactory.isProxyTargetClass()) {
              if (shouldProxyTargetClass(beanClass, beanName)) {
                  proxyFactory.setProxyTargetClass(true);
              }
              else {
                  evaluateProxyInterfaces(beanClass, proxyFactory);
              }
          }

          Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
          for (Advisor advisor : advisors) {
              proxyFactory.addAdvisor(advisor);
          }

          proxyFactory.setTargetSource(targetSource);
          customizeProxyFactory(proxyFactory);

          proxyFactory.setFrozen(this.freezeProxy);
          if (advisorsPreFiltered()) {
              proxyFactory.setPreFiltered(true);
          }

          return proxyFactory.getProxy(getProxyClassLoader());
      }
</code></pre><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><pre><code>根据目标类和BeanFactoryTransactionAttributeSourceAdvisor（回调链中的一个）生成代理代理类被调用，触发回调函数
</code></pre><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><pre><code>最后调用BeanFactoryTransactionAttributeSourceAdvisor中advice（TransactionInterceptor）的回调函数
TransactionInterceptor完成事务的管理

BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor();
advisor.setTransactionAttributeSource(transactionAttributeSource());
advisor.setAdvice(transactionInterceptor());
advisor.setOrder(this.enableTx.&lt;Integer&gt;getNumber(&quot;order&quot;));
BeanFactoryTransactionAttributeSourceAdvisor里面的advice是TransactionInterceptor
</code></pre><h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><pre><code>所有@Transation事物的拦截都是调用TransactionInterceptor的 invoke（）方法
</code></pre><h3 id="20180525-git回滚代码"><a href="#20180525-git回滚代码" class="headerlink" title="20180525-git回滚代码"></a>20180525-git回滚代码</h3><pre><code>1、删除远程分支再提交
   第一种方法不建议，比较麻烦。
   1.1 先两步保证当前工作区是干净的，并且和远程分支代码一致
        git pull origin master
   1.2 创建备份当前分支
        git branch olderMaster
        git branch revertBranch
        git chekout revertBranch
   1.3 reset到待提交的分支
      git log 找到待会滚的提交versio
      git reset --hard resetVersionHash
   1.4 删除当前分支的远程分支
       git push orgin:master
       如果删除失败，可能当前分支就一个，需要切换到其他分支去删除
       删除本地分支
       git branch -D master
   1.5 当前分支提交到远端
        当前分支名称修改为master
        git branch -m master
        git push origin master

2、强制push远程分支
    1.reset到待提交的分支
    2、把当前分支强制提交到远程
      git push -f origin currentBranch

3、从回滚位置生成新的commit hash
   1、git revert 到等待回滚的versio
   2、git push origin
</code></pre><h3 id="20180529-Arrays-asList-xx"><a href="#20180529-Arrays-asList-xx" class="headerlink" title="20180529- Arrays.asList(xx)"></a>20180529- Arrays.asList(xx)</h3><pre><code>对于Arrays.asList()生成的list，如果我们在对其get再add操作会报错java.lang.UnsupportedOperationException
因为Arrays.asList()生成的是匿名类的Arrays.ArrayList而不是java.util.ArrayList
</code></pre><h3 id="20180628-避免mybatis-SUM求和返回null"><a href="#20180628-避免mybatis-SUM求和返回null" class="headerlink" title="20180628- 避免mybatis SUM求和返回null"></a>20180628- 避免mybatis SUM求和返回null</h3><pre><code>select COALESCE(SUM(ScanCount),0)  from table
</code></pre><h3 id="20180712-mysql对于null的处理"><a href="#20180712-mysql对于null的处理" class="headerlink" title="20180712- mysql对于null的处理"></a>20180712- mysql对于null的处理</h3><pre><code>select 1 is null, 1 is not null, 1 &lt;=&gt; null ,null &lt;=&gt;null, 1 = null, 1 != null, 1 &lt;&gt; null from dual
任何值与null做=或!=或&lt;&gt;运算，所得结果均为null，在判断中即为false。
例如 select * from db where a!=&apos;ddd&apos; ,如果db表里面有三条数据，a字段值都为null,那么查询结果返回是0行数据
</code></pre><h3 id="20180815-mybatis批量插入时候自增主键"><a href="#20180815-mybatis批量插入时候自增主键" class="headerlink" title="20180815-mybatis批量插入时候自增主键"></a>20180815-mybatis批量插入时候自增主键</h3><pre><code>https://github.com/mybatis/mybatis-3/pull/324
注意点，dao去掉@param   mapper里面 parameterType=&quot;java.util.List&quot;
&lt;insert id=&quot;saveList&quot;  useGeneratedKeys=&quot;true&quot; keyProperty=&quot;vcourseId&quot; parameterType=&quot;java.util.List&quot;&gt;
    insert into EduVCourse (VCourseName, VCourseDesc,IsDeleted, AddTime) values
    &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt;
    (#{item.vcourseName},#{item.vcourseDesc},0, now() )
    &lt;/foreach&gt;
  &lt;/insert&gt;
</code></pre><h3 id="20180905-mysql支持emoj"><a href="#20180905-mysql支持emoj" class="headerlink" title="20180905-mysql支持emoj"></a>20180905-mysql支持emoj</h3><pre><code>有两种方式：升级MySQL到5.6或更高版本，并且将表字符集切换至utf8mb4。
第二种方法就是在把内容存入到数据库之前做一次过滤，将Emoji字符替换成一段特殊的文字编码，
然后再存入数据库中。之后从数据库获取或者前端展示时再将这段特殊文字编码转换成Emoji显示。
</code></pre><h3 id="20180906-一致性hash"><a href="#20180906-一致性hash" class="headerlink" title="20180906-一致性hash"></a>20180906-一致性hash</h3><pre><code>当我们设计分布式存储时候，肯定会遇到数据平均存储的问题，一般采用Hash算法。
假设初始节点数为 N，则传统的对 N 取模的映射方式存在一个问题，当节点增删，即 N 值变化时，
整个哈希表（Hash Table）需要重新映射，这便意味着大部分数据需要在节点之间移动。
比如有三台机器，假设每条待存储的数据都有一个唯一key,那么我们可以根据机器数量取模 shardNO=key%number得到hash值
那么shardNO无非就是0，1，2。
  如果从三台扩成6台，数据迁移是这样的：
        原来机器0的数据迁移到（0，3），机器1的数据迁移到（1，4），机器2的数据迁移到（2，6）
如果从三台库扩容4台，数据迁移是这样的：
    0==&gt;(1，2)，1==&gt;(0，3),2==&gt;(0，1)，数据需要迁移6次
如果从三台库到5台，数据迁移是这样的
    0==&gt;(1，2，4)，1==&gt;(0，2，4),2==&gt;(0，3，1)，数据需要迁移9次
考虑到性能，最好是是指数级别扩容需要迁移数据最少。
但是这种方式有两个缺点，一个是指数级别扩容，当指数级别比较大就是浪费，一个是需要数据扩容，数据迁移也是成本。
</code></pre><h4 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h4><pre><code>参考：https://my.oschina.net/lionets/blog/288066
当增删节点时，只影响到与变动节点相邻的一个或两个节点，散列表的其他部分与原来保持一致。
某种程度上可以将其理解为：一致性哈希算法的哈希函数与节点数 N 无关。
一致性hash算法通过一个叫作一致性hash环的数据结构实现。这个环的起点是0，终点是2^32 - 1，并且起点与终点连接，
环的中间的整数按逆时针分布，故这个环的整数分布范围是[0, 2^32-1]。
下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或主机名作为关键字进行哈希，
这样每台机器就能确定其在哈希环上的位置，假设将四台服务器使用ip地址哈希后在环空间的位置如下
接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，
从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。
</code></pre><p>   <img src="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172523808-1567363338.png" alt=""></p>
<pre><code>例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：
</code></pre><p>   <img src="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172807745-742859090.png" alt=""></p>
<pre><code>根据一致性哈希算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。
下面分析一致性哈希算法的容错性和可扩展性。现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，
只有C对象被重定位到Node D。一般的，在一致性哈希算法中，如果一台服务器不可用，
则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。

 如果这时候新增一台服务器Node X
</code></pre><p>   <img src="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172901526-169091807.png" alt=""></p>
<pre><code>此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X 。一般的，在一致性哈希算法中，
如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，
其它数据也不会受到影响。综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。
</code></pre><h4 id="一致性Hash算法优化"><a href="#一致性Hash算法优化" class="headerlink" title="一致性Hash算法优化"></a>一致性Hash算法优化</h4><pre><code>致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。例如系统中只有两台服务
</code></pre><p><img src="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172922917-1331181630.png" alt=""></p>
<pre><code>此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上
为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，
称为虚拟节点。
 具体做法可以在服务器ip或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，
 于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点
</code></pre><p>   <img src="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172943917-133540408.png" alt=""></p>
<pre><code>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题
</code></pre><h3 id="20180911-集合求并结果集"><a href="#20180911-集合求并结果集" class="headerlink" title="20180911-集合求并结果集"></a>20180911-集合求并结果集</h3><pre><code>例如有两个集合A（1，2，3），B集合（3，4，5），A和B的并集是3，常用方法是就是循环A，然后再去看B里面有没有，其实jdk里面提供了求并集的方法
 list.retainAll(list2)
</code></pre><h3 id="20180920-Java位运算的使用场景"><a href="#20180920-Java位运算的使用场景" class="headerlink" title="20180920-Java位运算的使用场景"></a>20180920-Java位运算的使用场景</h3><pre><code>1、乘法 a * (2^n) 等价于 a &lt;&lt; n
    3*2=3&lt;&lt;1
    3*4=3&lt;&lt;2
2、除法  a / (2^n) 等价于 a&gt;&gt; n
    8/2=8&gt;&gt;1
    8/4=8&gt;&gt;2
3、取模运算，采用位运算实现 a % (2^n) 等价于 a &amp; (2^n - 1)
    9%4=9&amp;3
</code></pre><h3 id="20180921-网络ping命令"><a href="#20180921-网络ping命令" class="headerlink" title="20180921-网络ping命令"></a>20180921-网络ping命令</h3><pre><code>traceroute命令用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是40字节
ping命令用来测试主机之间网络的连通性
</code></pre><h3 id="20180927-amp-amp-与"><a href="#20180927-amp-amp-与" class="headerlink" title="20180927-&amp;&amp;与||"></a>20180927-&amp;&amp;与||</h3><pre><code>最近发现脑子不够用
a()&amp;&amp;b()&amp;&amp;c() 表示a()方法为true,才会执行b(),如果a()为false,就不会执行后面的
a()||b()||() 表示a()方法为true,就不会执行后面的，如果为false才会执行后面的
</code></pre><h3 id="20180928-BeanUtils-copyProperties浅拷贝"><a href="#20180928-BeanUtils-copyProperties浅拷贝" class="headerlink" title="20180928 BeanUtils.copyProperties浅拷贝"></a>20180928 BeanUtils.copyProperties浅拷贝</h3><pre><code>spring提供的bean对象拷贝是浅拷贝，如果对象里面有引用或者集合对象是不会被拷贝的。
可以自己重新clone()或者利用jdk的ByteArrayOutputStream和ByteArrayInputStream 序列化对象
</code></pre><h3 id="20181018-hashcode冲突解决方法"><a href="#20181018-hashcode冲突解决方法" class="headerlink" title="20181018 hashcode冲突解决方法"></a>20181018 hashcode冲突解决方法</h3><pre><code>1、链表方法
  创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可,例如HashMap
2、线性探测
   根据key的得到hashValue,若不冲突，则直接填入数组,若冲突，则使 hashValue++ ，也就是往后找，
   直到找到第一个 data[hashValue] 为空的情况,则填入。若到了尾部可循环到前面
 private static void add(String str,String value) {
        int ix= str.hashCode()&amp;size;
        System.out.println(str+&quot;:hashcode:&quot;+ix);
        //如果冲突就获取下一个array[]的值
        for (Entry st=array[ix];st!=null;st=array[ix=ix+1]) {
            if(st.key==str){
                st.value=value;
                return;
            }
        }
        array[ix]=new Entry(null,str,value);
    }
</code></pre><h3 id="20181026-spring自定义添加bean"><a href="#20181026-spring自定义添加bean" class="headerlink" title="20181026-spring自定义添加bean"></a>20181026-spring自定义添加bean</h3><pre><code>ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) applicationContext;
DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) cwac.getBeanFactory();
// 自己注册bean
BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder
        .genericBeanDefinition(CustomBean.class.getName());
//设置依赖bean 这个bean前提是已经被spring代理了
beanDefinitionBuilder.addPropertyReference(&quot;refrenceBean&quot;,&quot;refrenceBean&quot;);
beanFactory.registerBeanDefinition(&quot;customBean&quot;, beanDefinitionBuilder.getBeanDefinition());
// 去除beani
// beanFactory.removeBeanDefinition(&quot;customBean&quot;);
</code></pre><h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><h3 id="20190122-数据统计"><a href="#20190122-数据统计" class="headerlink" title="20190122-数据统计"></a>20190122-数据统计</h3><pre><code>最近接手一个作业系统，里面表结构设计有很多冗余字段，冗余但统计字段无法保证数据的准确性，所以设计的时候就不改将统计的信息
放到表的字段里面，统计的信息最好是通过base表实时查，这样牺牲性能保证一致性，当然企业级开发不需要考虑这么全，数据量大了需要
专门走bi进行查询统计，让业务部门来做统计的事情本来就很重。
</code></pre><h3 id="20190325-linux-脚本"><a href="#20190325-linux-脚本" class="headerlink" title="20190325-linux 脚本"></a>20190325-linux 脚本</h3><pre><code>临时变量
单引号：在单引号中，变量不能被解析；
双引号：在双引号中变量可以被解析
反引号：反引号的作用是将反引号括起来的命令（括起来的内容会被当成命令执行）,然后将结果赋值给一个变量。
#!/bin/bash
tempPath=`pwd`
gradle clean build -x test -Dprofile=dev
echo -e &apos;密码&apos;
scp -P 5044 &quot;${tempPath}&quot;/homework-api/build/libs/homework-api.jar dev@xxx:/home/dev/download
</code></pre>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/笔记/" rel="tag"># 笔记</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/21/工作中遇到的坑-长期记录/" rel="next" title="工作中遇到的坑-长期记录">
                <i class="fa fa-chevron-left"></i> 工作中遇到的坑-长期记录
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/04/JavaPNS-2-2内存溢出定位和解决/" rel="prev" title="JavaPNS_2.2内存泄露定位和解决">
                JavaPNS_2.2内存泄露定位和解决 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ocg3iebmc.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720160922230125.jpg"
               alt="ggj2010" />
          <p class="site-author-name" itemprop="name">ggj2010</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ggj2010" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/ggjlvzjy" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#20170222"><span class="nav-number">1.</span> <span class="nav-text">20170222</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170223"><span class="nav-number">2.</span> <span class="nav-text">20170223</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170224"><span class="nav-number">3.</span> <span class="nav-text">20170224</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170227"><span class="nav-number">4.</span> <span class="nav-text">20170227</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170228"><span class="nav-number">5.</span> <span class="nav-text">20170228</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170301"><span class="nav-number">6.</span> <span class="nav-text">20170301</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170302"><span class="nav-number">7.</span> <span class="nav-text">20170302</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170306"><span class="nav-number">8.</span> <span class="nav-text">20170306</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170308"><span class="nav-number">9.</span> <span class="nav-text">20170308</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170309-redis回顾"><span class="nav-number">10.</span> <span class="nav-text">20170309-redis回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170310"><span class="nav-number">11.</span> <span class="nav-text">20170310</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170313"><span class="nav-number">12.</span> <span class="nav-text">20170313</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170314-浅拷贝和深拷贝"><span class="nav-number">13.</span> <span class="nav-text">20170314-浅拷贝和深拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170317-java-spi机制"><span class="nav-number">14.</span> <span class="nav-text">20170317-java spi机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170323"><span class="nav-number">15.</span> <span class="nav-text">20170323</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170327"><span class="nav-number">16.</span> <span class="nav-text">20170327</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170330"><span class="nav-number">17.</span> <span class="nav-text">20170330</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170412"><span class="nav-number">18.</span> <span class="nav-text">20170412</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170418"><span class="nav-number">19.</span> <span class="nav-text">20170418</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170425"><span class="nav-number">20.</span> <span class="nav-text">20170425</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170510-hs-err-pid-log"><span class="nav-number">21.</span> <span class="nav-text">20170510-hs_err_pid.log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170512-高可用消息推送平台"><span class="nav-number">22.</span> <span class="nav-text">20170512-高可用消息推送平台</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170605-mybatis动态参数"><span class="nav-number">23.</span> <span class="nav-text">20170605-mybatis动态参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170614-表添加索引"><span class="nav-number">24.</span> <span class="nav-text">20170614-表添加索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170615-equal和hashcode"><span class="nav-number">25.</span> <span class="nav-text">20170615-equal和hashcode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170615-replace空指针"><span class="nav-number">26.</span> <span class="nav-text">20170615-replace空指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170619-为什么HashMap里面的数组size必须是2的次幂？"><span class="nav-number">27.</span> <span class="nav-text">20170619-为什么HashMap里面的数组size必须是2的次幂？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170620-http协议复习"><span class="nav-number">28.</span> <span class="nav-text">20170620-http协议复习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170621-深入java虚拟机复习"><span class="nav-number">29.</span> <span class="nav-text">20170621-深入java虚拟机复习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java虚拟机运行时数据区域"><span class="nav-number">29.1.</span> <span class="nav-text">java虚拟机运行时数据区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java垃圾回收知识点"><span class="nav-number">29.2.</span> <span class="nav-text">java垃圾回收知识点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟机类加载机制"><span class="nav-number">29.3.</span> <span class="nav-text">虚拟机类加载机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#早期编译器优化"><span class="nav-number">29.4.</span> <span class="nav-text">早期编译器优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java内存模型"><span class="nav-number">29.5.</span> <span class="nav-text">java内存模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发编程三个概念"><span class="nav-number">29.6.</span> <span class="nav-text">并发编程三个概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令重排序"><span class="nav-number">29.7.</span> <span class="nav-text">指令重排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#happens-before原则（先行发生原则"><span class="nav-number">29.8.</span> <span class="nav-text">happens-before原则（先行发生原则)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170622-transient关键字"><span class="nav-number">30.</span> <span class="nav-text">20170622-transient关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170622-数据库复习"><span class="nav-number">31.</span> <span class="nav-text">20170622-数据库复习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#事物隔离级别"><span class="nav-number">31.1.</span> <span class="nav-text">事物隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁情况"><span class="nav-number">31.2.</span> <span class="nav-text">死锁情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring事物传播特性"><span class="nav-number">31.3.</span> <span class="nav-text">spring事物传播特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170622-动态代理"><span class="nav-number">32.</span> <span class="nav-text">20170622-动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk动态代理"><span class="nav-number">32.1.</span> <span class="nav-text">jdk动态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cglib"><span class="nav-number">32.2.</span> <span class="nav-text">cglib</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JAVAASSIST字节码"><span class="nav-number">32.3.</span> <span class="nav-text">JAVAASSIST字节码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170703-for-each原理和java迭代注意"><span class="nav-number">33.</span> <span class="nav-text">20170703-for each原理和java迭代注意</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">33.1.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意"><span class="nav-number">33.2.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for-each对象"><span class="nav-number">33.3.</span> <span class="nav-text">for each对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170704-linux线程gc查询"><span class="nav-number">34.</span> <span class="nav-text">20170704-linux线程gc查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170705-java对象的强、软、弱、虚引用"><span class="nav-number">35.</span> <span class="nav-text">20170705-java对象的强、软、弱、虚引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal原理与内存泄露"><span class="nav-number">35.1.</span> <span class="nav-text">ThreadLocal原理与内存泄露</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170706-设计模式回顾"><span class="nav-number">36.</span> <span class="nav-text">20170706-设计模式回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单例模式"><span class="nav-number">36.1.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工厂模式"><span class="nav-number">36.2.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装饰模式"><span class="nav-number">36.3.</span> <span class="nav-text">装饰模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代理模式"><span class="nav-number">36.4.</span> <span class="nav-text">代理模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命令模式"><span class="nav-number">36.5.</span> <span class="nav-text">命令模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#策略模式"><span class="nav-number">36.6.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代模式"><span class="nav-number">36.7.</span> <span class="nav-text">迭代模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#观察者模式"><span class="nav-number">36.8.</span> <span class="nav-text">观察者模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#适配器模式"><span class="nav-number">36.9.</span> <span class="nav-text">适配器模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170707-通过Java字节码去看原理"><span class="nav-number">37.</span> <span class="nav-text">20170707-通过Java字节码去看原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#i-与-i的原理"><span class="nav-number">37.1.</span> <span class="nav-text">i++与++i的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for-each的处理"><span class="nav-number">37.2.</span> <span class="nav-text">for each的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装箱与拆箱"><span class="nav-number">37.3.</span> <span class="nav-text">装箱与拆箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型"><span class="nav-number">37.4.</span> <span class="nav-text">泛型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170711-linux常用命令复习"><span class="nav-number">38.</span> <span class="nav-text">20170711-linux常用命令复习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件权限"><span class="nav-number">38.1.</span> <span class="nav-text">文件权限</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170712-QPS"><span class="nav-number">39.</span> <span class="nav-text">20170712-QPS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170713-TCP-IP相关"><span class="nav-number">40.</span> <span class="nav-text">20170713-TCP/IP相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS"><span class="nav-number">40.1.</span> <span class="nav-text">HTTPS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http状态码"><span class="nav-number">40.2.</span> <span class="nav-text">http状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSI七层模型"><span class="nav-number">40.3.</span> <span class="nav-text">OSI七层模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-IP四层模型"><span class="nav-number">40.4.</span> <span class="nav-text">TCP/IP四层模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP数据段格式"><span class="nav-number">40.5.</span> <span class="nav-text">TCP数据段格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三次握手"><span class="nav-number">40.6.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四次挥手"><span class="nav-number">40.7.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#syn攻击"><span class="nav-number">40.8.</span> <span class="nav-text">syn攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#与http相关协议"><span class="nav-number">40.9.</span> <span class="nav-text">与http相关协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#time-wait与close-wait"><span class="nav-number">40.10.</span> <span class="nav-text">time_wait与close_wait</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#time-wait"><span class="nav-number">40.10.1.</span> <span class="nav-text">time_wait</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#close-wait"><span class="nav-number">40.10.2.</span> <span class="nav-text">close_wait</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp粘包、拆包"><span class="nav-number">40.11.</span> <span class="nav-text">tcp粘包、拆包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何提高单机短连接QPS"><span class="nav-number">40.12.</span> <span class="nav-text">如何提高单机短连接QPS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#etc-sysctl-conf"><span class="nav-number">40.13.</span> <span class="nav-text">/etc/sysctl.conf</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170714-mysql相关"><span class="nav-number">41.</span> <span class="nav-text">20170714-mysql相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优化"><span class="nav-number">41.1.</span> <span class="nav-text">优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引失效"><span class="nav-number">41.2.</span> <span class="nav-text">索引失效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10条SQL技巧"><span class="nav-number">41.3.</span> <span class="nav-text">10条SQL技巧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引"><span class="nav-number">41.4.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#聚簇索引"><span class="nav-number">41.4.1.</span> <span class="nav-text">聚簇索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#非聚簇索引"><span class="nav-number">41.4.2.</span> <span class="nav-text">非聚簇索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#联合索引"><span class="nav-number">41.4.3.</span> <span class="nav-text">联合索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#左前缀索引"><span class="nav-number">41.4.4.</span> <span class="nav-text">左前缀索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#explain参数分析"><span class="nav-number">41.4.5.</span> <span class="nav-text">explain参数分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170715-springmvc相关"><span class="nav-number">42.</span> <span class="nav-text">20170715-springmvc相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bean的生命周期"><span class="nav-number">42.1.</span> <span class="nav-text">bean的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#url请求流程"><span class="nav-number">42.2.</span> <span class="nav-text">url请求流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170717-接口幂等性"><span class="nav-number">43.</span> <span class="nav-text">20170717-接口幂等性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口幂等场景"><span class="nav-number">43.1.</span> <span class="nav-text">接口幂等场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170718-线程池大小如何设置"><span class="nav-number">44.</span> <span class="nav-text">20170718-线程池大小如何设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170731-mysql删除"><span class="nav-number">45.</span> <span class="nav-text">20170731-mysql删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170802-window删除大量文件和文件"><span class="nav-number">46.</span> <span class="nav-text">20170802-window删除大量文件和文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170829-findbugs插件提示的优化代码"><span class="nav-number">47.</span> <span class="nav-text">20170829-findbugs插件提示的优化代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170918-Comparable与Comparator"><span class="nav-number">48.</span> <span class="nav-text">20170918-Comparable与Comparator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170924-static修饰符"><span class="nav-number">49.</span> <span class="nav-text">20170924-static修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170925-Exception与RuntimeException"><span class="nav-number">50.</span> <span class="nav-text">20170925-Exception与RuntimeException</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20170928-公司同事guva分享记录"><span class="nav-number">51.</span> <span class="nav-text">20170928-公司同事guva分享记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20171012-包装类比较"><span class="nav-number">52.</span> <span class="nav-text">20171012-包装类比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20171018-String-replace注意"><span class="nav-number">53.</span> <span class="nav-text">20171018-String.replace注意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20171024-map-putIfAbsent-key-value"><span class="nav-number">54.</span> <span class="nav-text">20171024-map.putIfAbsent(key,value)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20171106-URLEncoder-encode（）与decode"><span class="nav-number">55.</span> <span class="nav-text">20171106- URLEncoder.encode（）与decode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20171122-utf-8与gbk"><span class="nav-number">56.</span> <span class="nav-text">20171122- utf-8与gbk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180119-maven依赖原则"><span class="nav-number">57.</span> <span class="nav-text">20180119-maven依赖原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180122-简单的linux脚本"><span class="nav-number">58.</span> <span class="nav-text">20180122-简单的linux脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180208-mysql-utf8-unicode-ci、utf8-general-ci的区别"><span class="nav-number">59.</span> <span class="nav-text">20180208-mysql utf8_unicode_ci、utf8_general_ci的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180306-mysql-unique与primary"><span class="nav-number">60.</span> <span class="nav-text">20180306- mysql unique与primary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180307-mysql-longText与text类型"><span class="nav-number">61.</span> <span class="nav-text">20180307- mysql longText与text类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180308-less倒序"><span class="nav-number">62.</span> <span class="nav-text">20180308- less倒序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180313-字符串以逗号隔开"><span class="nav-number">63.</span> <span class="nav-text">20180313-字符串以逗号隔开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180402-mysql-bit"><span class="nav-number">64.</span> <span class="nav-text">20180402-mysql bit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180412-不停机数据迁移与分表"><span class="nav-number">65.</span> <span class="nav-text">20180412- 不停机数据迁移与分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180417-Resource与-Autowired等常用注解"><span class="nav-number">66.</span> <span class="nav-text">20180417- @Resource与@Autowired等常用注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180421-Java泛型中E、T、K、V等的含义"><span class="nav-number">67.</span> <span class="nav-text">20180421- Java泛型中E、T、K、V等的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180502-BigDecimal注意事项"><span class="nav-number">68.</span> <span class="nav-text">20180502- BigDecimal注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180509-jvm异常退出hook线程"><span class="nav-number">69.</span> <span class="nav-text">20180509- jvm异常退出hook线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180523-java位移运算与与运算"><span class="nav-number">70.</span> <span class="nav-text">20180523- java位移运算与与运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180524-spring事物-Transactional"><span class="nav-number">71.</span> <span class="nav-text">20180524- spring事物@Transactional</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180524-spring-Transactional注解被加载初始化顺序"><span class="nav-number">72.</span> <span class="nav-text">20180524- spring @Transactional注解被加载初始化顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1"><span class="nav-number">72.1.</span> <span class="nav-text">1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2"><span class="nav-number">72.2.</span> <span class="nav-text">2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3"><span class="nav-number">72.3.</span> <span class="nav-text">3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4"><span class="nav-number">72.4.</span> <span class="nav-text">4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5"><span class="nav-number">72.5.</span> <span class="nav-text">5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6"><span class="nav-number">72.6.</span> <span class="nav-text">6</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180525-git回滚代码"><span class="nav-number">73.</span> <span class="nav-text">20180525-git回滚代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180529-Arrays-asList-xx"><span class="nav-number">74.</span> <span class="nav-text">20180529- Arrays.asList(xx)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180628-避免mybatis-SUM求和返回null"><span class="nav-number">75.</span> <span class="nav-text">20180628- 避免mybatis SUM求和返回null</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180712-mysql对于null的处理"><span class="nav-number">76.</span> <span class="nav-text">20180712- mysql对于null的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180815-mybatis批量插入时候自增主键"><span class="nav-number">77.</span> <span class="nav-text">20180815-mybatis批量插入时候自增主键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180905-mysql支持emoj"><span class="nav-number">78.</span> <span class="nav-text">20180905-mysql支持emoj</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180906-一致性hash"><span class="nav-number">79.</span> <span class="nav-text">20180906-一致性hash</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一致性Hash算法"><span class="nav-number">79.1.</span> <span class="nav-text">一致性Hash算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一致性Hash算法优化"><span class="nav-number">79.2.</span> <span class="nav-text">一致性Hash算法优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180911-集合求并结果集"><span class="nav-number">80.</span> <span class="nav-text">20180911-集合求并结果集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180920-Java位运算的使用场景"><span class="nav-number">81.</span> <span class="nav-text">20180920-Java位运算的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180921-网络ping命令"><span class="nav-number">82.</span> <span class="nav-text">20180921-网络ping命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180927-amp-amp-与"><span class="nav-number">83.</span> <span class="nav-text">20180927-&&与||</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20180928-BeanUtils-copyProperties浅拷贝"><span class="nav-number">84.</span> <span class="nav-text">20180928 BeanUtils.copyProperties浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20181018-hashcode冲突解决方法"><span class="nav-number">85.</span> <span class="nav-text">20181018 hashcode冲突解决方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20181026-spring自定义添加bean"><span class="nav-number">86.</span> <span class="nav-text">20181026-spring自定义添加bean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2019"><span class="nav-number"></span> <span class="nav-text">2019</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#20190122-数据统计"><span class="nav-number">1.</span> <span class="nav-text">20190122-数据统计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20190325-linux-脚本"><span class="nav-number">2.</span> <span class="nav-text">20190325-linux 脚本</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ggj2010</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
